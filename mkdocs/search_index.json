{
    "docs": [
        {
            "location": "/", 
            "text": "Sandstorm documentation\n\n\nWhat is Sandstorm? See \nsandstorm.io\n\n\nSandstorm is an open source platform for personal servers.\n\n\nSandstorm lets you run your own server and install apps like\nEtherCalc, GitLab, Etherpad, Wekan, and more as easily as you'd\ninstall apps on your phone. Sandstorm handles login \n access control,\nand can run any web app that runs on Linux, though some apps may need\nchanges to work within the Sandstorm sandbox.\n\n\nSandstorm is very new and a lot of features have yet to be developed;\nhowever, many people are already using it for real work every day.\n\n\nChoose your adventure\n\n\n\n\nLearn how to use Sandstorm \n\n\nDevelop apps for Sandstorm or understand the platform \n\n\nRun \n maintain your own server \n\n\nGet involved", 
            "title": "Home"
        }, 
        {
            "location": "/#sandstorm-documentation", 
            "text": "", 
            "title": "Sandstorm documentation"
        }, 
        {
            "location": "/#what-is-sandstorm-see-sandstormio", 
            "text": "Sandstorm is an open source platform for personal servers.  Sandstorm lets you run your own server and install apps like\nEtherCalc, GitLab, Etherpad, Wekan, and more as easily as you'd\ninstall apps on your phone. Sandstorm handles login   access control,\nand can run any web app that runs on Linux, though some apps may need\nchanges to work within the Sandstorm sandbox.  Sandstorm is very new and a lot of features have yet to be developed;\nhowever, many people are already using it for real work every day.", 
            "title": "What is Sandstorm? See sandstorm.io"
        }, 
        {
            "location": "/#choose-your-adventure", 
            "text": "Learn how to use Sandstorm   Develop apps for Sandstorm or understand the platform   Run   maintain your own server   Get involved", 
            "title": "Choose your adventure"
        }, 
        {
            "location": "/using/", 
            "text": "Using Sandstorm\n\n\nSandstorm as a user: learn to create documents, grant access, and more\n\n\nIf you want to learn how to put Sandstorm to use so you can create\nonline documents with it read, read these documents.\n\n\n\n\nUsing Sandstorm\n: \nGuided tour\n | \nTop bar\n\n\nTechnical details\n: \nHow it works\n | \nSecurity practices", 
            "title": "Overview"
        }, 
        {
            "location": "/using/#using-sandstorm", 
            "text": "", 
            "title": "Using Sandstorm"
        }, 
        {
            "location": "/using/#sandstorm-as-a-user-learn-to-create-documents-grant-access-and-more", 
            "text": "If you want to learn how to put Sandstorm to use so you can create\nonline documents with it read, read these documents.   Using Sandstorm :  Guided tour  |  Top bar  Technical details :  How it works  |  Security practices", 
            "title": "Sandstorm as a user: learn to create documents, grant access, and more"
        }, 
        {
            "location": "/guided-tour/", 
            "text": "Guided tour of Sandstorm, including install\n\n\nFormat: Self-driven hands-on tutorial\n\n\nIf you have 15 minutes and want to learn more about Sandstorm, enjoy this hands-on tour. After you work through it, you will:\n\n\n\n\nUnderstand how installing apps and creating documents/instances works in Sandstorm.\n\n\nUnderstand how app instance sharing works in Sandstorm.\n\n\nUnderstand the current limits of Sandstorm, and where the project is headed in the future.\n\n\n(If desired) have a free-of-cost virtual machine, hosted by Amazon, to run Sandstorm on for a year, or at DigitalOcean with a coupon code.\n\n\n\n\nOptional: Install Sandstorm\n\n\nYou can proceed through this tutorial using the \nSandstorm demo server\n at https://demo.sandstorm.io. By default, we will have you do that.\n\n\nIf you wish, you could take the time now to install Sandstorm on a Linux server of your own. Amazon offers a free-of-cost one year trial where you can use their hosting services for free. To do that, keep reading.\n\n\nIf you don't want to install Sandstorm right now, skip to the \nHands on tour\n section.\n\n\nCreate a virtual machine in Amazon EC2\n\n\nAmazon's EC2 service is oriented toward software developers and system administrators, and so its control panel is filled with options. This section explains what you need to know to create a new virtual Linux server hosted by Amazon EC2 to run Sandstorm.\n\n\nTo set that up, follow this \nexcellent tutorial\n. After you've done that, you should be able to:\n\n\n\n\nSee your virtual machine in Amazon's EC2 web console, and\n\n\nLog in to it remotely over SSH.\n\n\n\n\nIf so, proceed to the next section.\n\n\nConfigure the EC2 security groups (firewall) to let you reach Sandstorm\n\n\nBy default, Amazon EC2 protects your virtual machine from being reached over the Internet.\n\n\nIn the above tutorial, we allow the virtual machine to be reached on \nport 80\n. By default, Sandstorm uses \nport 6080\n, so look through the above tutorial and add another \nsecurity groups\n rule allowing port 6080.\n\n\nSSH in, and run the Sandstorm install script\n\n\nFollow the instructions at \nhttps://sandstorm.io/install/\n.\n\n\nI personally recommend using the Google login provider, but naturally you can choose any you like.\n\n\nSandstorm comes with a dynamic DNS service for free, so you once you install Sandstorm, your server will be online at a name like \nhttp://garply.sandcats.io:6080/\n.\n\n\nProceed with the guided tour\n\n\nNow that your server is online, and has a name, you can use it in the rest of this guided tour instead of the demo server.\n\n\nHands-on tour\n\n\nDuring this tutorial, you're going to try out some cool features of Sandstorm. You can try them out using the Sandstorm demo server at \nhttps://demo.sandstorm.io/\n.\n\n\nNote: demo data is temporary.\n Accounts on the Sandstorm demo server expire after one hour! By contrast, when you run Sandstorm yourself, you keep your data for as long as you like.\n\n\nLike Google Apps, but open source and on your own server\n\n\nOne of the common reasons to use Sandstorm is to have online collaboration software that runs on your own server.\n\n\nEtherpad is a real-time text editor that demonstrates how to use Sandstorm that way. Make sure you're logged into Sandstorm (if using the demo, click \nStart the demo\n). Then click:\n\n\n\n\nInstall apps\n - this takes you to the Sandstorm app list. (Soon to be the Sandstorm App Marketplace!)\n\n\nClick the \nInstall\n button next to \nEtherpad\n. (Sandstorm may ask you for confirmation.)\n\n\nClick \nNew Etherpad Document\n button on your Sandstorm.\n\n\n\n\nYou're now in an Etherpad document. Installing Etherpad allows you to create as many Etherpad documents as you want.\n\n\nIf you want to create spreadsheets on your server, consider installing \nEthercalc\n.\n\n\nIf you want to edit scientific documents, consider installing \nShareLaTeX\n.\n\n\nIf you want to create presentations, consider installing \nHacker Slides\n.\n\n\nEach document is an _instance_of that app, with Sandstorm isolating each one from each other.\n\n\nSharing\n\n\nIn Sandstorm, each app instance is private by default. In order to collaborate, you create a \nsharing link\n.\n\n\nIn your Etherpad document, look for the blue \nShare\n link at the top (or the side) of the document. Click it, choose a permission level, and click \ncreate\n.\n\n\nWhen you give this link to someone, they will be able to participate in the document with you.\n\n\nTo read more about sharing in Sandstorm, read \nDelegation is the cornerstone of civilization\n.\n\n\nStatic publishing\n\n\nSandstorm supports a number of publishing apps, including WordPress and Ghost. (The \nSandstorm blog\n is hosted on our own Sandstorm instance using a custom app called Hacker CMS.)\n\n\nTry them out!\n\n\n\n\nClick the \nSandstorm\n logo in the top-left, and\n\n\nClick \nInstall apps\n and\n\n\nFind \nWordPress\n or \nGhost\n on the page, and click *\nInstall\n.\n\n\nClick \nNew WordPress site\n (or similar for Ghost).\n\n\n\n\nThis takes you to WordPress running on your server. You are automatically logged-in and can start writing. You can click \nRegenerate public site\n and this snapshots your blog as static HTML and exports it at a random hostname.\n\n\nYou can also configure a custom domain to map to the same static content. Only people with whom you \nshare\n the WordPress instance can interact with WordPress's PHP code. The result is that WordPress becomes a security-hardened collaborative static site generator.\n\n\nAsk questions\n\n\nThis brings us to the end of our tour. Ask questions! Also give me feedback on how to improve this tour.", 
            "title": "Guided tour"
        }, 
        {
            "location": "/guided-tour/#guided-tour-of-sandstorm-including-install", 
            "text": "Format: Self-driven hands-on tutorial  If you have 15 minutes and want to learn more about Sandstorm, enjoy this hands-on tour. After you work through it, you will:   Understand how installing apps and creating documents/instances works in Sandstorm.  Understand how app instance sharing works in Sandstorm.  Understand the current limits of Sandstorm, and where the project is headed in the future.  (If desired) have a free-of-cost virtual machine, hosted by Amazon, to run Sandstorm on for a year, or at DigitalOcean with a coupon code.", 
            "title": "Guided tour of Sandstorm, including install"
        }, 
        {
            "location": "/guided-tour/#optional-install-sandstorm", 
            "text": "You can proceed through this tutorial using the  Sandstorm demo server  at https://demo.sandstorm.io. By default, we will have you do that.  If you wish, you could take the time now to install Sandstorm on a Linux server of your own. Amazon offers a free-of-cost one year trial where you can use their hosting services for free. To do that, keep reading.  If you don't want to install Sandstorm right now, skip to the  Hands on tour  section.  Create a virtual machine in Amazon EC2  Amazon's EC2 service is oriented toward software developers and system administrators, and so its control panel is filled with options. This section explains what you need to know to create a new virtual Linux server hosted by Amazon EC2 to run Sandstorm.  To set that up, follow this  excellent tutorial . After you've done that, you should be able to:   See your virtual machine in Amazon's EC2 web console, and  Log in to it remotely over SSH.   If so, proceed to the next section.  Configure the EC2 security groups (firewall) to let you reach Sandstorm  By default, Amazon EC2 protects your virtual machine from being reached over the Internet.  In the above tutorial, we allow the virtual machine to be reached on  port 80 . By default, Sandstorm uses  port 6080 , so look through the above tutorial and add another  security groups  rule allowing port 6080.  SSH in, and run the Sandstorm install script  Follow the instructions at  https://sandstorm.io/install/ .  I personally recommend using the Google login provider, but naturally you can choose any you like.  Sandstorm comes with a dynamic DNS service for free, so you once you install Sandstorm, your server will be online at a name like  http://garply.sandcats.io:6080/ .  Proceed with the guided tour  Now that your server is online, and has a name, you can use it in the rest of this guided tour instead of the demo server.", 
            "title": "Optional: Install Sandstorm"
        }, 
        {
            "location": "/guided-tour/#hands-on-tour", 
            "text": "During this tutorial, you're going to try out some cool features of Sandstorm. You can try them out using the Sandstorm demo server at  https://demo.sandstorm.io/ .  Note: demo data is temporary.  Accounts on the Sandstorm demo server expire after one hour! By contrast, when you run Sandstorm yourself, you keep your data for as long as you like.  Like Google Apps, but open source and on your own server  One of the common reasons to use Sandstorm is to have online collaboration software that runs on your own server.  Etherpad is a real-time text editor that demonstrates how to use Sandstorm that way. Make sure you're logged into Sandstorm (if using the demo, click  Start the demo ). Then click:   Install apps  - this takes you to the Sandstorm app list. (Soon to be the Sandstorm App Marketplace!)  Click the  Install  button next to  Etherpad . (Sandstorm may ask you for confirmation.)  Click  New Etherpad Document  button on your Sandstorm.   You're now in an Etherpad document. Installing Etherpad allows you to create as many Etherpad documents as you want.  If you want to create spreadsheets on your server, consider installing  Ethercalc .  If you want to edit scientific documents, consider installing  ShareLaTeX .  If you want to create presentations, consider installing  Hacker Slides .  Each document is an _instance_of that app, with Sandstorm isolating each one from each other.  Sharing  In Sandstorm, each app instance is private by default. In order to collaborate, you create a  sharing link .  In your Etherpad document, look for the blue  Share  link at the top (or the side) of the document. Click it, choose a permission level, and click  create .  When you give this link to someone, they will be able to participate in the document with you.  To read more about sharing in Sandstorm, read  Delegation is the cornerstone of civilization .  Static publishing  Sandstorm supports a number of publishing apps, including WordPress and Ghost. (The  Sandstorm blog  is hosted on our own Sandstorm instance using a custom app called Hacker CMS.)  Try them out!   Click the  Sandstorm  logo in the top-left, and  Click  Install apps  and  Find  WordPress  or  Ghost  on the page, and click * Install .  Click  New WordPress site  (or similar for Ghost).   This takes you to WordPress running on your server. You are automatically logged-in and can start writing. You can click  Regenerate public site  and this snapshots your blog as static HTML and exports it at a random hostname.  You can also configure a custom domain to map to the same static content. Only people with whom you  share  the WordPress instance can interact with WordPress's PHP code. The result is that WordPress becomes a security-hardened collaborative static site generator.  Ask questions  This brings us to the end of our tour. Ask questions! Also give me feedback on how to improve this tour.", 
            "title": "Hands-on tour"
        }, 
        {
            "location": "/using/top-bar/", 
            "text": "Using the Sandstorm top bar\n\n\nOverview of the bar\n\n\nWhen an app is running in Sandstorm, Sandstorm provides navigation elements at the top of the screen.\n\n\nYou can see an example here:\n\n\n\n\nhttps://sandstorm.io/vote\n -- this redirects to a URL on \nalpha.sandstorm.io\n.\n\n\n\n\nSummary of the elements\n\n\n\n\n\n\nSandstorm logo: Click this to return to the homepage of the Sandstorm shell, where you can view your apps and documents.\n\n\n\n\n\n\nName of grain (in this case, \"App Committee Voting\"): Click this to rename the current grain. At the moment, the app does not know what you named this grain.\n\n\n\n\n\n\nSize (for example, \"12.9 MB\"): This is the total amount of storage consumed by this particular grain. Some apps are more lightweight than others, and this allows you to get a sense of which grains are consuming a lot of resources.\n\n\n\n\n\n\nGet Webkey link: Click this to create an API token that you can provide to mobile apps, command line automation, or other non-browser interaction methods for this grain. Any logged in user can do this.\n\n\n\n\n\n\nFor a grain where you are the owner, you will also see:\n\n\n\n\n\n\nDelete: Click this, and after you confirm, Sandstorm will remove the data that supports this grain. Be careful! There is no undo.\n\n\n\n\n\n\nShow Debug Log: Click this to see stdout and stderr from the app. (FIXME: Really both stdout \nand\n stderr? Not syslog also? Should check.)\n\n\n\n\n\n\nDownload Backup: Click this to receive a ZIP file containing the data that supports this grain -- specifically, the full contents of \n/var\n. Note that there is no \"wrapper directory\" (discussed \nhere\n). Note also that if you attempt to restore this data, but you have upgraded the app, things might not work properly.\n\n\n\n\n\n\nRestart App: Click here to stop and start the app process. You should never need to click this. Probably it should move into a \"Developer\" menu.", 
            "title": "Top bar"
        }, 
        {
            "location": "/using/top-bar/#using-the-sandstorm-top-bar", 
            "text": "", 
            "title": "Using the Sandstorm top bar"
        }, 
        {
            "location": "/using/top-bar/#overview-of-the-bar", 
            "text": "When an app is running in Sandstorm, Sandstorm provides navigation elements at the top of the screen.  You can see an example here:   https://sandstorm.io/vote  -- this redirects to a URL on  alpha.sandstorm.io .", 
            "title": "Overview of the bar"
        }, 
        {
            "location": "/using/top-bar/#summary-of-the-elements", 
            "text": "Sandstorm logo: Click this to return to the homepage of the Sandstorm shell, where you can view your apps and documents.    Name of grain (in this case, \"App Committee Voting\"): Click this to rename the current grain. At the moment, the app does not know what you named this grain.    Size (for example, \"12.9 MB\"): This is the total amount of storage consumed by this particular grain. Some apps are more lightweight than others, and this allows you to get a sense of which grains are consuming a lot of resources.    Get Webkey link: Click this to create an API token that you can provide to mobile apps, command line automation, or other non-browser interaction methods for this grain. Any logged in user can do this.    For a grain where you are the owner, you will also see:    Delete: Click this, and after you confirm, Sandstorm will remove the data that supports this grain. Be careful! There is no undo.    Show Debug Log: Click this to see stdout and stderr from the app. (FIXME: Really both stdout  and  stderr? Not syslog also? Should check.)    Download Backup: Click this to receive a ZIP file containing the data that supports this grain -- specifically, the full contents of  /var . Note that there is no \"wrapper directory\" (discussed  here ). Note also that if you attempt to restore this data, but you have upgraded the app, things might not work properly.    Restart App: Click here to stop and start the app process. You should never need to click this. Probably it should move into a \"Developer\" menu.", 
            "title": "Summary of the elements"
        }, 
        {
            "location": "/using/how-it-works/", 
            "text": "How It Works\n\n\n\n\nSandstorm's server-side sandboxing is based on the same underlying Linux kernel features as LXC and Docker.  We use the system calls directly for finer-grained control.\n\n\n(Planned) The kernel attack surface is reduced using seccomp-bpf to block and/or virtualize system calls.\n\n\nprocfs, sysfs, etc. are not mounted in the sandbox, and only a minimal set of devices are available.\n\n\n(Planned) On the client side, apps run in a sandboxed iframe employing the \nContent-Security-Policy\n header to prevent them from sending any kind of network communication to any server other than their own.\n\n\nAll communication between the sandboxed server and the outside world takes place through a single \nCap'n Proto\n RPC socket which the app's root process receives as file descriptor #3.  We've provided a program, \nsandstorm-http-bridge\n, which can receive HTTP-over-RPC requests on this socket and proxy them to a regular HTTP server running in the sandbox.\n\n\nEvery object (e.g., each document) that you create with an application runs in a separate isolated sandbox.  We sandbox per-object rather than per-app so that it is easy and safe to share one object without also sharing everything created using the same app.\n\n\nAn application package (\n.spk\n file) is essentially an archive containing an entire chroot environment in which the application runs.\n\n\nThe application runs with the contents of its package mounted read-only, so that multiple instances of the same app can share disk space for the package.\n\n\nThe application may store persistent state in the \n/var\n directory.\n\n\nApp servers are aggressively killed off as soon as the user closes the browser tab, then restarted when the user returns later.\n\n\nPackages are cryptographically signed.  Packages signed with the same key represent versions of the same app, and are thus allowed to replace older versions -- although the user must still confirm these upgrades.\n\n\n\n\nHTTP Communication Overview\n\n\nWhile web clients speak HTTP to Sandstorm, all communications between Sandstorm\nand the grain occur over the Cap'n Proto WebSession format.  With existing\napplications, the Sandstorm HTTP bridge is used to translate between Cap'n\nProto and HTTP.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommunication_overview_http_app\n\n\n\n\ncluster_sandstorm\n\n\n\n\nSandstorm\n\n\n\n\ncluster_grain\n\n\n\n\nGrain\n\n\n\n\n\n\nclient\n\n\n\n\nWeb client\n\n\n(eg. browser)\n\n\n\n\n\n\nproxy\n\n\n\n\nProxy\n\n\n (proxy.js)\n\n\n\n\n\n\nclient\nproxy\n\n\n\n\n\n\n\n\nwebsession\n\n\n\n\nWebSession Serialization\n\n\n(HTTP over Cap\nn Proto,\n\n\nweb\nsession.capnp)\n\n\n\n\n\n\nproxy\nwebsession\n\n\n\n\n\n\n\n\nbridge\n\n\n\n\nSandstorm\n\n\nHTTP Bridge\n\n\n(sandstorm\nhttp\n\n\nbridge.c++)\n\n\n\n\n\n\nwebsession\nbridge\n\n\n\n\n\n\n\n\napp\n\n\n\n\nHTTP App\n\n\n\n\n\n\nbridge\napp\n\n\n\n\n\n\n\n\n\n\n\nWhen an application can speak Cap'n Proto directly to Sandstorm, the HTTP\nbridge is not needed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncommunication_overview_native_app\n\n\n\n\ncluster_sandstorm\n\n\n\n\nSandstorm\n\n\n\n\ncluster_grain\n\n\n\n\nGrain\n\n\n\n\n\n\nclient\n\n\n\n\nWeb client\n\n\n(eg. browser)\n\n\n\n\n\n\nproxy\n\n\n\n\nProxy\n\n\n (proxy.js)\n\n\n\n\n\n\nclient\nproxy\n\n\n\n\n\n\n\n\nwebsession\n\n\n\n\nWebSession Serialization\n\n\n(HTTP over Cap\nn Proto,\n\n\nweb\nsession.capnp)\n\n\n\n\n\n\nproxy\nwebsession\n\n\n\n\n\n\n\n\napp\n\n\n\n\nNative Sandstorm App\n\n\n(speaks Cap\nn Proto )\n\n\n\n\n\n\nwebsession\napp", 
            "title": "How it works"
        }, 
        {
            "location": "/using/how-it-works/#how-it-works", 
            "text": "Sandstorm's server-side sandboxing is based on the same underlying Linux kernel features as LXC and Docker.  We use the system calls directly for finer-grained control.  (Planned) The kernel attack surface is reduced using seccomp-bpf to block and/or virtualize system calls.  procfs, sysfs, etc. are not mounted in the sandbox, and only a minimal set of devices are available.  (Planned) On the client side, apps run in a sandboxed iframe employing the  Content-Security-Policy  header to prevent them from sending any kind of network communication to any server other than their own.  All communication between the sandboxed server and the outside world takes place through a single  Cap'n Proto  RPC socket which the app's root process receives as file descriptor #3.  We've provided a program,  sandstorm-http-bridge , which can receive HTTP-over-RPC requests on this socket and proxy them to a regular HTTP server running in the sandbox.  Every object (e.g., each document) that you create with an application runs in a separate isolated sandbox.  We sandbox per-object rather than per-app so that it is easy and safe to share one object without also sharing everything created using the same app.  An application package ( .spk  file) is essentially an archive containing an entire chroot environment in which the application runs.  The application runs with the contents of its package mounted read-only, so that multiple instances of the same app can share disk space for the package.  The application may store persistent state in the  /var  directory.  App servers are aggressively killed off as soon as the user closes the browser tab, then restarted when the user returns later.  Packages are cryptographically signed.  Packages signed with the same key represent versions of the same app, and are thus allowed to replace older versions -- although the user must still confirm these upgrades.", 
            "title": "How It Works"
        }, 
        {
            "location": "/using/how-it-works/#http-communication-overview", 
            "text": "While web clients speak HTTP to Sandstorm, all communications between Sandstorm\nand the grain occur over the Cap'n Proto WebSession format.  With existing\napplications, the Sandstorm HTTP bridge is used to translate between Cap'n\nProto and HTTP.        communication_overview_http_app   cluster_sandstorm   Sandstorm   cluster_grain   Grain    client   Web client  (eg. browser)    proxy   Proxy   (proxy.js)    client proxy     websession   WebSession Serialization  (HTTP over Cap n Proto,  web session.capnp)    proxy websession     bridge   Sandstorm  HTTP Bridge  (sandstorm http  bridge.c++)    websession bridge     app   HTTP App    bridge app      When an application can speak Cap'n Proto directly to Sandstorm, the HTTP\nbridge is not needed.        communication_overview_native_app   cluster_sandstorm   Sandstorm   cluster_grain   Grain    client   Web client  (eg. browser)    proxy   Proxy   (proxy.js)    client proxy     websession   WebSession Serialization  (HTTP over Cap n Proto,  web session.capnp)    proxy websession     app   Native Sandstorm App  (speaks Cap n Proto )    websession app", 
            "title": "HTTP Communication Overview"
        }, 
        {
            "location": "/using/security-practices/", 
            "text": "Sandstorm is a security product.\n\n\nWe like to say that Sandstorm's priorities are Usability, Security,\nand Freedom. In public, we tend to talk more about usability and\nfreedom, because those are the priorities users are most excited\nabout. However, within the team, we are just as passionate -- if not\nmore so -- about security.\n\n\nUltimately, our goal is that, to the maximum extent possible, users\nneed not worry about security, because using the system intuitively\nwill result in the desired security properties \"by default\". Moreover,\nwe aim to allow network administrators to be able to say: \"As long as\nit's on Sandstorm, you can run whatever apps you want, because we\ntrust Sandstorm to keep things secure.\"\n\n\nThreat models\n\n\nSandstorm defends against a wide variety of threats; too many to list\nhere. However, as a platform for apps, most of our energy goes into\nthe following:\n\n\nMitigation of app bugs\n\n\nSandstorm's most important security goal is to ensure that security\nbugs in applications are contained and mitigated to the maximum extent\npossible. For example:\n\n\n\n\nA buggy app should not allow an attacker to compromise the rest of the system or network.\n\n\nA buggy app should not be able to grant attackers access even to itself.\n\n\nA buggy app should not be able to expose private data to the internet.\n\n\n\n\nObviously, Sandstorm cannot defend against every possible app bug,\nespecially when apps need access to sensitive resources in order to\nfunction. However, security is about risk management, and there is\nmuch that Sandstorm can and does do to greatly reduce the user's or\nthe network admin's overall risk.\n\n\nDefense against malicious apps\n\n\nSandstorm does not just aim to defend against buggy apps, but also\nactively malicious apps. It is our goal that a user should be able to\ninstall and run arbitrary applications from arbitrary authors without\nserious consequence. This is important because Sandstorm is aimed at\nallowing non-technical users to administer their own\nserver. Inevitably, such users will install malware.\n\n\nAgain, obviously, Sandstorm cannot prevent an app from misusing\npermissions that a user has explicitly granted to it. But, making an\napp explicitly request such permissions makes it much easier for users\nto understand what is happening and defend themselves.\n\n\nDefense against surveillance and profiling\n\n\nIn the world of Software-as-a-Service, it is common practice for web\napps to collect information about individual users, commonly for the\npurpose of building advertising profiles. We at Sandstorm feel that\nany such collection is only ethical with the user's full knowledge and\nconsent. Unfortunately, in practice, profiling usually happens behind\nthe user's back.\n\n\nSandstorm aims to prevent apps from engaging in covert surveillance\nwhile allowing statistics gathering when the user consents to it.\n\n\nStrategies\n\n\nSandstorm's primary overarching security strategies are as follows.\n\n\nPlatform-level authentication\n\n\nSandstorm implements authentication at the platform level, so that you\nlog into the platform once rather than to each application\nseparately. When you open an app, the platform informs the app of your\nalready-authenticated identity. This means that applications\nthemselves never handle sensitive authentication credentials like\npasswords, which greatly reduces the damage possible if an\napplication's database is compromised.\n\n\nMore generally, Sandstorm aims to ensure that applications never store\nsensitive secrets at all. For example, we plan to implement an\noutgoing OAuth proxy such that applications do not directly engage in\nOAuth requests but rather request the platform do so on their\nbehalf. Thus, the platform is able to store OAuth tokens securely.\n\n\nFine-grained isolation\n\n\nSandstorm implements \nfine-grained\n containers. This means that\nSandstorm does not just isolate apps from each other, but isolates\nindividual resources within an app. For example, with Etherpad (a\ndocument editor), Sandstorm creates a new Etherpad instance in its own\nisolated container for every Etherpad document you create.\n\n\nFine-grained isolation allows Sandstorm to implement access control at\nthe container level. When you share an Etherpad document, you are\ntelling \nSandstorm\n who should have access, not Etherpad. Thus, no bug\nin Etherpad can allow someone to get access to a document to which\nthey should not have.\n\n\nIt's important to note that Sandstorm can only truly enforce a binary\nhas access / does not have access. Permission levels like read\nvs. write are app-dependent and thus can only be implemented by the\napp. To that end, when a user connects, Sandstorm computes (via the\n\nsharing\nmodel\n)\nwhich permissions the user has, and then asks the app to enforce those\npermissions on the user's session. That is, when the app receives\nrequests, those requests are annotated with information like \"this\nuser has read permission but not write\". The app can then enforce said\npermissions without ever needing to track any information about\nspecific users.\n\n\nTrue Confinement\n\n\nA Sandstorm app, by default, is totally isolated from the network. It\ncannot connect to anyone; it can only receive proxied HTTP requests\nfrom the user. Thus, by default, an app cannot \"phone home\" to its\ndevelopers' servers, and cannot build an advertising profile on you,\nunless you give it permission to do so.\n\n\nIt's worth noting that it may be possible for a malicious app to leak\nsmall amounts of information through \"covert channels\". For example,\nif the developer is able to run another app on the same server where\nthe user's instance of the app is running (perhaps because both are\nrunning in a shared hosting environment), then the two app instances\nmay be able to communicate by varying their CPU usage and observing\nthe timing changes caused by those variations. Sandstorm ultimately\ncannot prevent these kinds of attacks. However, since covert channels\nare very obviously malicious, any developer caught using one would\nrisk serious PR and possibly legal consequences, which should\nhopefully deter any large company from doing such a thing. Moreover,\ncovert channels are usually very limited in bandwidth. Sandstorm\nensures that it is not possible to bootstrap a normal communications\nchannel by leaking plain bits -- in technical terms, \ncapabilities\n in\nSandstorm are never just bits, and therefore you cannot leak\n\ncapabilities\n via covert channels.\n\n\nAlpha Notice:\n As of this writing (May 2015), Sandstorm is in\nalpha. Key features allowing a user to easily grant an application\naccess to external resources are still in development. In order to\nmake Sandstorm more useful to alpha testers and early adopters, we\nhave temporarily opened some intentional holes in our confinement\nmodel. For example, we have allowed outgoing HTTP to arbitrary servers\nin order to permit the TinyTiny RSS app to fetch RSS feeds, and we\nhave allowed incoming and outgoing SMTP (with certain restrictions) to\nallow email clients to work. These holes will be closed as soon as the\nPowerbox UI and drivers make them obsolete, but in the meantime\nSandstorm does not yet implement true confinement.\n\n\nCapability-based Usable Security\n\n\nSandstorm employs capability-based security in order to make security\n\nusable\n.\n\n\nSecurity without usability is, after all, trivial: just disconnect\nyour server from the network. Now it's secure, but useless. The real\nchallenge in security is making sure it does not get in way of getting\nwork done.\n\n\nSince Sandstorm isolates and confines apps by default, we need a way\nto allow the user to connect apps to each other easily and\nsecurely. Capability-based security helps enable this by representing\npermissions as \"capabilities\", objects which the user may pass around\nbetween apps. A capability both identifies a resource (like an address)\nand grants its bearer permission to \nuse\n that resource.\n\n\nThe advantage of capability-based security is that it effectively\ninfers \nsecurity\n from a separate action that the user had to do\nanyway. Consider a traditional system based on access control lists\n(ACLs). Normally, there are two steps required for a user to connect\napp A to app B.\n\n\n\n\nThe user tells app A how to find app B, for example by specifying app B's hostname.\n\n\nThe user edits app B's access control list to indicate that app A has access.\n\n\n\n\nCapability-based security combines these two into one step:\n\n\n\n\nThe user gives app A a capability to app B.\n\n\n\n\nNotice that this one step is something the user would need to do \neven\nif there were no security\n. App A always needs to be told which app B\nto talk to.\n\n\nThe Powerbox\n\n\nSandstorm uses capability-based security at every level of the\nplatform. All intra-system communications are performed using \nCap'n\nProto\n, a capability-based transport network\nprotocol. Sandstorm capabilities are literally Cap'n Proto\ncapabilities in implementation.\n\n\nAt the user interface level, the user interacts with capabilities\nthrough \"the powerbox\". The basic functioning of the powerbox is as\nfollows:\n\n\n\n\nAs the user installs apps, each app tells the platform about what kinds of APIs (Cap'n Proto interfaces) it implements.\n\n\nAt some point, an app that the user is using makes a request to the platform saying \"I need a capability implementing interface \nFoo\n\".\n\n\nThe \nplatform\n renders a picker UI to the user, where the user can choose from among all their apps that implement API \nFoo\n.\n\n\nThe user chooses the app they want to satisfy the request.\n\n\nThe platform grants the requesting app a capability to the chosen API.\n\n\n\n\nThus, we've implemented a \"service discovery\" mechanism that is\nuser-friendly and automatically handles security.\n\n\nThe Powerbox is an excellent example of the intersection between\nSandstorm's promises of Usability, Security, and Freedom:\n\n\n\n\n\n\nUsability:\n The user does not need to understand concepts like IP\naddresses, hostnames, access credentials, etc. in order to connect two\napps. The choice is presented in a way that non-technical users can\ngrasp.\n\n\n\n\n\n\nSecurity:\n The platform can automatically infer the proper\nsecurity settings from the user's choice: obviously, the user wants\nthe requesting app to have permission to access the target they chose,\nand no others.\n\n\n\n\n\n\nFreedom:\n An app can never request permission to a \nspecific\n\nother app, but can only ask for something implementing the desired\n\nAPI\n. The user can always substitute any compatible app. This helps\nto prevent vendor lock-in, where all apps from a vendor integrate only\nwith each other and fail to give the user any ability to swap out one\napp for a third party app.\n\n\n\n\n\n\nNote: As of this writing (May 2015), the powerbox is still in the\nprocess of being implemented. This is why we have not yet implemented\nfull confinement, as mentioned above: without the powerbox, it would\nbe too limiting.\n\n\nTactics\n\n\nAt a lower level, here are some of the techniques Sandstorm uses to provide security.\n\n\nServer Sandboxing\n\n\nEvery grain (fine-grained application instance) runs, on the server side, inside a secure sandbox. The sandbox is based on the same Linux kernel namespacing features commonly used to implement containers. However, unlike most container implementations, Sandstorm implements various measures to reduce the kernel's \"attack surface\". That is, Sandstorm disables many kernel APIs that apps don't need, in order to mitigate any security vulnerabilities found in those APIs. For example:\n\n\n\n\n\n\nWe use seccomp-bpf to disable many exotic system calls, especially\n  ones which have seen a lot of vulnerabilities in the past. For\n  example, we do not allow apps to create new UID namespaces -- the\n  source of a large number of recent kernel vulnerabilities.\n\n\n\n\n\n\nWe do not mount \n/proc\n or \n/sys\n filesystems.\n\n\n\n\n\n\nThe only devices exposed are \n/dev/zero\n, \n/dev/null\n, and\n  \n/dev/urandom\n (with \n/dev/random\n symlinked to \nurandom\n, \nas it\n  should\n  be\n).\n\n\n\n\n\n\nOver time, Sandstorm plans to disable more and more system calls by\nmoving implementations to userspace, but even with the filter we\nalready have, Sandstorm has avoided dozens of kernel vulnerabilities\nover the last few months.\n\n\nSandstorm's server container maps the app's package (libraries,\nassets, etc.) read-only, and maps the per-grain writable storage at\n\n/var\n. Thus, apps are stateful, yet assets can be shared between many\ninstances of the app.\n\n\nAn app's only communication to the outside world is done through a\nsingle Cap'n Proto socket, inherited by the app's root process. For\nexample, HTTP requests are delivered to the app as Cap'n Proto\nRPCs. The app may employ shims (such as \nsandstorm-http-bridge\n) to\nbridge between Cap'n Proto and traditional protocols, e.g. to be able\nto use a traditional HTTP server without modification. By using a\ncapability-based schema-driven protocol, it is easy to review exactly\nwhat an app can do for security purposes. See for example Sandstorm's\n\nweb-session.capnp\n\nwhich defines HTTP over Cap'n Proto: notice that this is far more\nreadable than the HTTP specification.\n\n\nClient Sandboxing\n\n\nOn the client side, Sandstorm isolates apps by requiring every app to\nrun on a separate, randomly-generated hostname. Because of this,\nSandstorm requires a \nwildcard\nhost\n.\n\n\nSandstorm not only hosts each grain at a separate origin, but actually\ncreates a new origin for every \nsession\n. That is, every time a user\nopens a document, it is hosted at a new one-off\ncryptographically-random hostname which expires shortly after the\ndocument is closed.\n\n\nRandomized, unguessable hostnames can help mitigate certain common\nsecurity bugs in apps, such as \nXSRF\n, \nreflected XSS\n, and\n\nclickjacking\n attacks. All of these attacks involve an attacker\ntricking the user's browser into performing actions on another site\nusing the user's credentials. But for any of these attacks to work,\nthe attacker must know the address to attack. If every user gets a\ndifferent hostname, and indeed the hostnames change frequently, then\nit is much harder to launch these kinds of attacks.\n\n\nNote that because DNS requests are made in cleartext, random hostnames\nwill not defend against an attacker who has the ability to snoop\nnetwork traffic coming from the user's machine. Therefore, apps should\nstill implement their own defenses against these attacks as they\nalways have. But, when a bug slips through (as they commonly do),\nrandomized hostnames make an attack much, much more difficult to pull\noff, which is still a big win.\n\n\nSandstorm will soon employ the \nContent-Security-Policy\n header to\nprevent an app from communicating with other origins without\npermission, in order to implement full confinement. As of this writing\n(May 2015), this has not yet been put in place, mostly because\nserver-side confinement is not complete (as described earlier) which\nmakes client-side confinement largely moot for the moment.\n\n\nCase Studies\n\n\nWe've already seen Sandstorm's security model mitigate bugs in apps. Here are some examples.\n\n\nEtherpad\n\n\nEtherpad has, over the last several months, disclosed several vulnerabilities falling into a few categories:\n\n\n\n\n\n\nPath injection attacks allowing anyone to download arbitrary files\n  from the server's filesystem (such as Etherpad's own database,\n  containing credentials).\n\n\n\n\n\n\nInformation leaks allowing someone with access to one document on\n  the server to discover and read other documents.\n\n\n\n\n\n\nVarious other minor information leaks of user and system\n  information.\n\n\n\n\n\n\nNone of these problems have affected Etherpad on Sandstorm, because\nSandstorm runs every Etherpad document in a separate container, and\nbecause Sandstorm implements authentication, sharing, and access\ncontrol.\n\n\nWordpress\n\n\nThe Sandstorm port of Wordpress separates the Wordpress admin\ninterface from the publicly-facing published web site. The admin\ninterface is accessed through Sandstorm, whereas the published site is\nserved as read-only content. The Wordpress may not even be running\nwhen public content is served; Sandstorm simply returns the content\nfrom disk.\n\n\nAs a result, many recent Wordpress security vulnerabilities are\nmitigated by Sandstorm: since regular visitors to the site have no\nability to interact with Wordpress software, they have no ability to\nexploit it. Several recent Wordpress security vulnerabilities are\ntherefore irrelevant to Sandstorm users.\n\n\n(Admittedly, this protection currently comes at the cost of disabling\nfeatures like public comments. We plan to address this in the\nfuture. For many use cases, though, this restriction is perfectly\nacceptable.)", 
            "title": "Security practices"
        }, 
        {
            "location": "/using/security-practices/#threat-models", 
            "text": "Sandstorm defends against a wide variety of threats; too many to list\nhere. However, as a platform for apps, most of our energy goes into\nthe following:  Mitigation of app bugs  Sandstorm's most important security goal is to ensure that security\nbugs in applications are contained and mitigated to the maximum extent\npossible. For example:   A buggy app should not allow an attacker to compromise the rest of the system or network.  A buggy app should not be able to grant attackers access even to itself.  A buggy app should not be able to expose private data to the internet.   Obviously, Sandstorm cannot defend against every possible app bug,\nespecially when apps need access to sensitive resources in order to\nfunction. However, security is about risk management, and there is\nmuch that Sandstorm can and does do to greatly reduce the user's or\nthe network admin's overall risk.  Defense against malicious apps  Sandstorm does not just aim to defend against buggy apps, but also\nactively malicious apps. It is our goal that a user should be able to\ninstall and run arbitrary applications from arbitrary authors without\nserious consequence. This is important because Sandstorm is aimed at\nallowing non-technical users to administer their own\nserver. Inevitably, such users will install malware.  Again, obviously, Sandstorm cannot prevent an app from misusing\npermissions that a user has explicitly granted to it. But, making an\napp explicitly request such permissions makes it much easier for users\nto understand what is happening and defend themselves.  Defense against surveillance and profiling  In the world of Software-as-a-Service, it is common practice for web\napps to collect information about individual users, commonly for the\npurpose of building advertising profiles. We at Sandstorm feel that\nany such collection is only ethical with the user's full knowledge and\nconsent. Unfortunately, in practice, profiling usually happens behind\nthe user's back.  Sandstorm aims to prevent apps from engaging in covert surveillance\nwhile allowing statistics gathering when the user consents to it.", 
            "title": "Threat models"
        }, 
        {
            "location": "/using/security-practices/#strategies", 
            "text": "Sandstorm's primary overarching security strategies are as follows.  Platform-level authentication  Sandstorm implements authentication at the platform level, so that you\nlog into the platform once rather than to each application\nseparately. When you open an app, the platform informs the app of your\nalready-authenticated identity. This means that applications\nthemselves never handle sensitive authentication credentials like\npasswords, which greatly reduces the damage possible if an\napplication's database is compromised.  More generally, Sandstorm aims to ensure that applications never store\nsensitive secrets at all. For example, we plan to implement an\noutgoing OAuth proxy such that applications do not directly engage in\nOAuth requests but rather request the platform do so on their\nbehalf. Thus, the platform is able to store OAuth tokens securely.  Fine-grained isolation  Sandstorm implements  fine-grained  containers. This means that\nSandstorm does not just isolate apps from each other, but isolates\nindividual resources within an app. For example, with Etherpad (a\ndocument editor), Sandstorm creates a new Etherpad instance in its own\nisolated container for every Etherpad document you create.  Fine-grained isolation allows Sandstorm to implement access control at\nthe container level. When you share an Etherpad document, you are\ntelling  Sandstorm  who should have access, not Etherpad. Thus, no bug\nin Etherpad can allow someone to get access to a document to which\nthey should not have.  It's important to note that Sandstorm can only truly enforce a binary\nhas access / does not have access. Permission levels like read\nvs. write are app-dependent and thus can only be implemented by the\napp. To that end, when a user connects, Sandstorm computes (via the sharing\nmodel )\nwhich permissions the user has, and then asks the app to enforce those\npermissions on the user's session. That is, when the app receives\nrequests, those requests are annotated with information like \"this\nuser has read permission but not write\". The app can then enforce said\npermissions without ever needing to track any information about\nspecific users.  True Confinement  A Sandstorm app, by default, is totally isolated from the network. It\ncannot connect to anyone; it can only receive proxied HTTP requests\nfrom the user. Thus, by default, an app cannot \"phone home\" to its\ndevelopers' servers, and cannot build an advertising profile on you,\nunless you give it permission to do so.  It's worth noting that it may be possible for a malicious app to leak\nsmall amounts of information through \"covert channels\". For example,\nif the developer is able to run another app on the same server where\nthe user's instance of the app is running (perhaps because both are\nrunning in a shared hosting environment), then the two app instances\nmay be able to communicate by varying their CPU usage and observing\nthe timing changes caused by those variations. Sandstorm ultimately\ncannot prevent these kinds of attacks. However, since covert channels\nare very obviously malicious, any developer caught using one would\nrisk serious PR and possibly legal consequences, which should\nhopefully deter any large company from doing such a thing. Moreover,\ncovert channels are usually very limited in bandwidth. Sandstorm\nensures that it is not possible to bootstrap a normal communications\nchannel by leaking plain bits -- in technical terms,  capabilities  in\nSandstorm are never just bits, and therefore you cannot leak capabilities  via covert channels.  Alpha Notice:  As of this writing (May 2015), Sandstorm is in\nalpha. Key features allowing a user to easily grant an application\naccess to external resources are still in development. In order to\nmake Sandstorm more useful to alpha testers and early adopters, we\nhave temporarily opened some intentional holes in our confinement\nmodel. For example, we have allowed outgoing HTTP to arbitrary servers\nin order to permit the TinyTiny RSS app to fetch RSS feeds, and we\nhave allowed incoming and outgoing SMTP (with certain restrictions) to\nallow email clients to work. These holes will be closed as soon as the\nPowerbox UI and drivers make them obsolete, but in the meantime\nSandstorm does not yet implement true confinement.  Capability-based Usable Security  Sandstorm employs capability-based security in order to make security usable .  Security without usability is, after all, trivial: just disconnect\nyour server from the network. Now it's secure, but useless. The real\nchallenge in security is making sure it does not get in way of getting\nwork done.  Since Sandstorm isolates and confines apps by default, we need a way\nto allow the user to connect apps to each other easily and\nsecurely. Capability-based security helps enable this by representing\npermissions as \"capabilities\", objects which the user may pass around\nbetween apps. A capability both identifies a resource (like an address)\nand grants its bearer permission to  use  that resource.  The advantage of capability-based security is that it effectively\ninfers  security  from a separate action that the user had to do\nanyway. Consider a traditional system based on access control lists\n(ACLs). Normally, there are two steps required for a user to connect\napp A to app B.   The user tells app A how to find app B, for example by specifying app B's hostname.  The user edits app B's access control list to indicate that app A has access.   Capability-based security combines these two into one step:   The user gives app A a capability to app B.   Notice that this one step is something the user would need to do  even\nif there were no security . App A always needs to be told which app B\nto talk to.  The Powerbox  Sandstorm uses capability-based security at every level of the\nplatform. All intra-system communications are performed using  Cap'n\nProto , a capability-based transport network\nprotocol. Sandstorm capabilities are literally Cap'n Proto\ncapabilities in implementation.  At the user interface level, the user interacts with capabilities\nthrough \"the powerbox\". The basic functioning of the powerbox is as\nfollows:   As the user installs apps, each app tells the platform about what kinds of APIs (Cap'n Proto interfaces) it implements.  At some point, an app that the user is using makes a request to the platform saying \"I need a capability implementing interface  Foo \".  The  platform  renders a picker UI to the user, where the user can choose from among all their apps that implement API  Foo .  The user chooses the app they want to satisfy the request.  The platform grants the requesting app a capability to the chosen API.   Thus, we've implemented a \"service discovery\" mechanism that is\nuser-friendly and automatically handles security.  The Powerbox is an excellent example of the intersection between\nSandstorm's promises of Usability, Security, and Freedom:    Usability:  The user does not need to understand concepts like IP\naddresses, hostnames, access credentials, etc. in order to connect two\napps. The choice is presented in a way that non-technical users can\ngrasp.    Security:  The platform can automatically infer the proper\nsecurity settings from the user's choice: obviously, the user wants\nthe requesting app to have permission to access the target they chose,\nand no others.    Freedom:  An app can never request permission to a  specific \nother app, but can only ask for something implementing the desired API . The user can always substitute any compatible app. This helps\nto prevent vendor lock-in, where all apps from a vendor integrate only\nwith each other and fail to give the user any ability to swap out one\napp for a third party app.    Note: As of this writing (May 2015), the powerbox is still in the\nprocess of being implemented. This is why we have not yet implemented\nfull confinement, as mentioned above: without the powerbox, it would\nbe too limiting.", 
            "title": "Strategies"
        }, 
        {
            "location": "/using/security-practices/#tactics", 
            "text": "At a lower level, here are some of the techniques Sandstorm uses to provide security.  Server Sandboxing  Every grain (fine-grained application instance) runs, on the server side, inside a secure sandbox. The sandbox is based on the same Linux kernel namespacing features commonly used to implement containers. However, unlike most container implementations, Sandstorm implements various measures to reduce the kernel's \"attack surface\". That is, Sandstorm disables many kernel APIs that apps don't need, in order to mitigate any security vulnerabilities found in those APIs. For example:    We use seccomp-bpf to disable many exotic system calls, especially\n  ones which have seen a lot of vulnerabilities in the past. For\n  example, we do not allow apps to create new UID namespaces -- the\n  source of a large number of recent kernel vulnerabilities.    We do not mount  /proc  or  /sys  filesystems.    The only devices exposed are  /dev/zero ,  /dev/null , and\n   /dev/urandom  (with  /dev/random  symlinked to  urandom ,  as it\n  should\n  be ).    Over time, Sandstorm plans to disable more and more system calls by\nmoving implementations to userspace, but even with the filter we\nalready have, Sandstorm has avoided dozens of kernel vulnerabilities\nover the last few months.  Sandstorm's server container maps the app's package (libraries,\nassets, etc.) read-only, and maps the per-grain writable storage at /var . Thus, apps are stateful, yet assets can be shared between many\ninstances of the app.  An app's only communication to the outside world is done through a\nsingle Cap'n Proto socket, inherited by the app's root process. For\nexample, HTTP requests are delivered to the app as Cap'n Proto\nRPCs. The app may employ shims (such as  sandstorm-http-bridge ) to\nbridge between Cap'n Proto and traditional protocols, e.g. to be able\nto use a traditional HTTP server without modification. By using a\ncapability-based schema-driven protocol, it is easy to review exactly\nwhat an app can do for security purposes. See for example Sandstorm's web-session.capnp \nwhich defines HTTP over Cap'n Proto: notice that this is far more\nreadable than the HTTP specification.  Client Sandboxing  On the client side, Sandstorm isolates apps by requiring every app to\nrun on a separate, randomly-generated hostname. Because of this,\nSandstorm requires a  wildcard\nhost .  Sandstorm not only hosts each grain at a separate origin, but actually\ncreates a new origin for every  session . That is, every time a user\nopens a document, it is hosted at a new one-off\ncryptographically-random hostname which expires shortly after the\ndocument is closed.  Randomized, unguessable hostnames can help mitigate certain common\nsecurity bugs in apps, such as  XSRF ,  reflected XSS , and clickjacking  attacks. All of these attacks involve an attacker\ntricking the user's browser into performing actions on another site\nusing the user's credentials. But for any of these attacks to work,\nthe attacker must know the address to attack. If every user gets a\ndifferent hostname, and indeed the hostnames change frequently, then\nit is much harder to launch these kinds of attacks.  Note that because DNS requests are made in cleartext, random hostnames\nwill not defend against an attacker who has the ability to snoop\nnetwork traffic coming from the user's machine. Therefore, apps should\nstill implement their own defenses against these attacks as they\nalways have. But, when a bug slips through (as they commonly do),\nrandomized hostnames make an attack much, much more difficult to pull\noff, which is still a big win.  Sandstorm will soon employ the  Content-Security-Policy  header to\nprevent an app from communicating with other origins without\npermission, in order to implement full confinement. As of this writing\n(May 2015), this has not yet been put in place, mostly because\nserver-side confinement is not complete (as described earlier) which\nmakes client-side confinement largely moot for the moment.", 
            "title": "Tactics"
        }, 
        {
            "location": "/using/security-practices/#case-studies", 
            "text": "We've already seen Sandstorm's security model mitigate bugs in apps. Here are some examples.  Etherpad  Etherpad has, over the last several months, disclosed several vulnerabilities falling into a few categories:    Path injection attacks allowing anyone to download arbitrary files\n  from the server's filesystem (such as Etherpad's own database,\n  containing credentials).    Information leaks allowing someone with access to one document on\n  the server to discover and read other documents.    Various other minor information leaks of user and system\n  information.    None of these problems have affected Etherpad on Sandstorm, because\nSandstorm runs every Etherpad document in a separate container, and\nbecause Sandstorm implements authentication, sharing, and access\ncontrol.  Wordpress  The Sandstorm port of Wordpress separates the Wordpress admin\ninterface from the publicly-facing published web site. The admin\ninterface is accessed through Sandstorm, whereas the published site is\nserved as read-only content. The Wordpress may not even be running\nwhen public content is served; Sandstorm simply returns the content\nfrom disk.  As a result, many recent Wordpress security vulnerabilities are\nmitigated by Sandstorm: since regular visitors to the site have no\nability to interact with Wordpress software, they have no ability to\nexploit it. Several recent Wordpress security vulnerabilities are\ntherefore irrelevant to Sandstorm users.  (Admittedly, this protection currently comes at the cost of disabling\nfeatures like public comments. We plan to address this in the\nfuture. For many use cases, though, this restriction is perfectly\nacceptable.)", 
            "title": "Case Studies"
        }, 
        {
            "location": "/developing/", 
            "text": "Developing on Sandstorm\n\n\nSandstorm can run any web app that can run on Linux so long as the\ncode and all the dependencies have been bundled into an SPK file.\nAnyone can make a Sandstorm package (SPK), such as the author of a\nprogram or someone wants to run the app on their own Sandstorm\nserver.\n\n\nIf you haven't yet, now is a good time to try the Sandstorm demo!\nWork through the \nguided tour\n.\n\n\nCreating an app package\n\n\n\n\nTutorial\n: \nFive minute packaging tutorial\n\n\nConceptual overview\n: \nApp Developer Handbook\n\n\nLanguage support\n: \nPlatform stacks for Meteor, Python, PHP\n | \nOther\n\n\nCode \n service dependencies\n: \nCode dependencies\n | \nMySQL\n | \nOther databases \n services\n\n\nTroubleshooting\n: \nPackage troubleshooting\n\n\nvagrant-spk in depth\n: \nInstallation\n | \nOriginal design\n | \nCustomizing \n understanding vagrant-spk\n\n\n\n\n\n\n\n\n\nSandstorm for systems engineers\n\n\nYou might enjoy learning how Sandstorm is put together.\n\n\n\n\nTechnical summary\n: \nHow Sandstorm works\n\n\nMinimalist packaging\n: \nRaw SPK packaging guide\n\n\nRaw packaging \n integration guides\n: \nPython\n | \nRuby on Rails\n | \nPure client apps\n\n\nSecurity\n: \nSecurity Practices Overview\n\n\n\n\n\n\nNetwork access\n\n\nBy default, Sandstorm runs each app instance with no network\naccess. Read these documents to configure an app to get access to\nservices on the Internet or to each other.\n\n\n\n\nSupported protocol\n: \nSMTP (email)\n\n\nOther protocols\n: Work in progress.\n\n\nInter-app communication\n: Work in progress.\n\n\n\n\n\n\nApp sharing, publishing, \n permission levels\n\n\nEach app instance (aka \"grain\") is private by default to the user who\ncreated it. Read these documents to learn how access control works.\n\n\n\n\nOverview\n: \nDelegation is the Cornerstone of Civilization\n\n\nLogin \n permissions\n: \nUser authentication \n permissions\n\n\nMaking it world-accessible\n: \nPublishing to the user's domain\n | \nExporting HTTP APIs\n\n\n\n\n\n\nIntegrating various languages \n libraries into raw Sandstorm\n\n\nIf you are curious how to integrate various languages \n libraries with\nSandstorm's raw APIs and raw SPK packaging, read these documents.\n\n\nNote\n that most app developers will have an easier time using \nvagrant-spk\n. This is intended\n\n\n\n\nFurther reference documentation\n\n\nWe call Sandstorm a \nplatform\n because it provides concepts,\ncapabilities, and APIs that apps can use. The documentation about\nfurther concepts may be found on our \nGitHub\nwiki\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/developing/#developing-on-sandstorm", 
            "text": "Sandstorm can run any web app that can run on Linux so long as the\ncode and all the dependencies have been bundled into an SPK file.\nAnyone can make a Sandstorm package (SPK), such as the author of a\nprogram or someone wants to run the app on their own Sandstorm\nserver.  If you haven't yet, now is a good time to try the Sandstorm demo!\nWork through the  guided tour .", 
            "title": "Developing on Sandstorm"
        }, 
        {
            "location": "/developing/#creating-an-app-package", 
            "text": "Tutorial :  Five minute packaging tutorial  Conceptual overview :  App Developer Handbook  Language support :  Platform stacks for Meteor, Python, PHP  |  Other  Code   service dependencies :  Code dependencies  |  MySQL  |  Other databases   services  Troubleshooting :  Package troubleshooting  vagrant-spk in depth :  Installation  |  Original design  |  Customizing   understanding vagrant-spk", 
            "title": "Creating an app package"
        }, 
        {
            "location": "/developing/#sandstorm-for-systems-engineers", 
            "text": "You might enjoy learning how Sandstorm is put together.   Technical summary :  How Sandstorm works  Minimalist packaging :  Raw SPK packaging guide  Raw packaging   integration guides :  Python  |  Ruby on Rails  |  Pure client apps  Security :  Security Practices Overview", 
            "title": "Sandstorm for systems engineers"
        }, 
        {
            "location": "/developing/#network-access", 
            "text": "By default, Sandstorm runs each app instance with no network\naccess. Read these documents to configure an app to get access to\nservices on the Internet or to each other.   Supported protocol :  SMTP (email)  Other protocols : Work in progress.  Inter-app communication : Work in progress.", 
            "title": "Network access"
        }, 
        {
            "location": "/developing/#app-sharing-publishing-permission-levels", 
            "text": "Each app instance (aka \"grain\") is private by default to the user who\ncreated it. Read these documents to learn how access control works.   Overview :  Delegation is the Cornerstone of Civilization  Login   permissions :  User authentication   permissions  Making it world-accessible :  Publishing to the user's domain  |  Exporting HTTP APIs", 
            "title": "App sharing, publishing, &amp; permission levels"
        }, 
        {
            "location": "/developing/#integrating-various-languages-libraries-into-raw-sandstorm", 
            "text": "If you are curious how to integrate various languages   libraries with\nSandstorm's raw APIs and raw SPK packaging, read these documents.  Note  that most app developers will have an easier time using  vagrant-spk . This is intended", 
            "title": "Integrating various languages &amp; libraries into raw Sandstorm"
        }, 
        {
            "location": "/developing/#further-reference-documentation", 
            "text": "We call Sandstorm a  platform  because it provides concepts,\ncapabilities, and APIs that apps can use. The documentation about\nfurther concepts may be found on our  GitHub\nwiki .", 
            "title": "Further reference documentation"
        }, 
        {
            "location": "/vagrant-spk/", 
            "text": "vagrant-spk\n\n\nThe goal of \nvagrant-spk\n is to be an easy-to-install tool that runs on\nWindows, Mac, and Linux that lets people create Sandstorm packages\nwithout mucking with their main operating system.\n\n\nRight now it works properly on Mac and GNU/Linux systems. Windows\nsupport is forthcoming.\n\n\nUse the navigation at the top of the screen to navigate the\n\nvagrant-spk\n documentation.", 
            "title": "Overview of vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/#vagrant-spk", 
            "text": "The goal of  vagrant-spk  is to be an easy-to-install tool that runs on\nWindows, Mac, and Linux that lets people create Sandstorm packages\nwithout mucking with their main operating system.  Right now it works properly on Mac and GNU/Linux systems. Windows\nsupport is forthcoming.  Use the navigation at the top of the screen to navigate the vagrant-spk  documentation.", 
            "title": "vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/installation/", 
            "text": "Installation\n\n\nBefore we install \nvagrant-spk\n, some advice for how to succeed at the\ninstallation process.\n\n\n\n\nLearn about Sandstorm, if you haven't already. \nTry using Sandstorm at our demo server\n to get a feel for how it operates.\n\n\nOpen a \"terminal\" on your Mac or Linux system or \"command prompt\" on Windows.\n\n\nDon't use sudo unless we tell you to!\n\n\n\n\nSystem requirements\n: \nvagrant-spk\n requires a 64-bit computer with\nat least 1GB of RAM. Your computer probably is fine. We've tested this\ntutorial on Mac OS and GNU/Linux, and partly-tested on Windows.\n\n\nEnsure git is installed\n\n\nIn this tutorial, we use git to download some code, so you need it on your computer.\n\n\nIn the terminal, type the following and press enter.\n\n\ngit --version\n\n\n\n\nYou should see a message like:\n\n\ngit version x.y.z\n\n\n\n\nIf so, git is properly installed and you can skip this section.\n\n\nIf you saw instead a message like:\n\n\ngit: Command not found.\n\n\n\n\nThen you need to install git via the following instructions.\n\n\n\n\nOn Mac OS, visit the \nofficial git for Mac download page\n and follow their instructions.\n\n\nOn Ubuntu or Debian, run: \nsudo apt-get install git\n. (On other Linux systems, use your package manager to install git.)\n\n\nOn Windows, git is optional. Consider installing it via the \nmsysgit installer\n.\n\n\n\n\nEnsure Vagrant is installed\n\n\nIn this tutorial, we use Vagrant (along with other tools) to create a Linux\nvirtual machine where your app will run, alongside Sandstorm.\n\n\nTo check if it is installed, in the terminal, type the following and press enter.\n\n\nvagrant version\n\n\n\n\nYou should see a message like:\n\n\nInstalled Version: 1.7.2\n\n\n\n\nIf so, Vagrant is installed properly, and you can skip the rest of this section.\n\n\nIf instead you see a message like:\n\n\nvagrant: Command not found.\n\n\n\n\nThen you need to install Vagrant by doing the following.\n\n\n\n\nOn Mac OS or Linux or Windows, visit the \nofficial Vagrant\n  website\n and follow their instructions to\n  install it.\n\n\n\n\nEnsure VirtualBox is installed\n\n\nIn this tutorial, we use VirtualBox to emulate a computer on which we run\nLinux, controlled via Vagrant.\n\n\nTo check if it is installed, in the terminal, type the following and press\nenter:\n\n\nVirtualBox --help\n\n\n\n\nYou should see a lot of output, for example:\n\n\nOracle VM VirtualBox Manager x.y.z\n(C) 2005-2015 Oracle Corporation\nAll rights reserved.\n\n\n\n\nIf so, skip the rest of this section, as VirtualBox is already properly installed.\n\n\nIf you saw instead:\n\n\nVirtualBox: Command not found.\n\n\n\n\nThen you need to install VirtualBox by doing following:\n\n\n\n\nVisit the \nVirtualBox downloads page\n\n\nIn the \ntop\n, underneath \nVirtualBox platform packages\n, find the package for your operating system. Click the link, download, and install it.\n\n\nOnce you are done with that, go to the top of this section and make sure you can see the VirtualBox help output.\n\n\n\n\nNo need to install Sandstorm directly\n\n\nYou do \nnot\n need Sandstorm installed on your computer before you\nstart packaging an app. Sandstorm's \nvagrant-spk\n helper tool handles\ninstalling it for you.\n\n\nIt creates a Sandstorm install unique to each app you are developing.\n\n\nInstall \nvagrant-spk\n\n\nFinally, you can install \nvagrant-spk\n itself. This tool uses Vagrant\nand VirtualBox so that you can run your app within Sandstorm on a\nLinux virtual machine.\n\n\nWindows users\n\n\nVisit the \nvagrant-spk releases\nlist\n and run\nthe Windows installer (\nvagrant-spk-setup-v0.xyy.exe\n). It may need\nadministrator privileges to successfully install.\n\n\nMac OS or Linux\n\n\nIn your terminal, run the following commands to download and install \nvagrant-spk\n.\n\n\nmkdir -p ~/projects\ncd ~/projects\ngit clone git://github.com/sandstorm-io/vagrant-spk\ncd vagrant-spk\nsudo ln -s $PWD/vagrant-spk /usr/local/bin\n\n\n\n\n(Note: If you prefer different paths, that is OK.)", 
            "title": "Installation"
        }, 
        {
            "location": "/vagrant-spk/installation/#installation", 
            "text": "Before we install  vagrant-spk , some advice for how to succeed at the\ninstallation process.   Learn about Sandstorm, if you haven't already.  Try using Sandstorm at our demo server  to get a feel for how it operates.  Open a \"terminal\" on your Mac or Linux system or \"command prompt\" on Windows.  Don't use sudo unless we tell you to!   System requirements :  vagrant-spk  requires a 64-bit computer with\nat least 1GB of RAM. Your computer probably is fine. We've tested this\ntutorial on Mac OS and GNU/Linux, and partly-tested on Windows.", 
            "title": "Installation"
        }, 
        {
            "location": "/vagrant-spk/installation/#ensure-git-is-installed", 
            "text": "In this tutorial, we use git to download some code, so you need it on your computer.  In the terminal, type the following and press enter.  git --version  You should see a message like:  git version x.y.z  If so, git is properly installed and you can skip this section.  If you saw instead a message like:  git: Command not found.  Then you need to install git via the following instructions.   On Mac OS, visit the  official git for Mac download page  and follow their instructions.  On Ubuntu or Debian, run:  sudo apt-get install git . (On other Linux systems, use your package manager to install git.)  On Windows, git is optional. Consider installing it via the  msysgit installer .", 
            "title": "Ensure git is installed"
        }, 
        {
            "location": "/vagrant-spk/installation/#ensure-vagrant-is-installed", 
            "text": "In this tutorial, we use Vagrant (along with other tools) to create a Linux\nvirtual machine where your app will run, alongside Sandstorm.  To check if it is installed, in the terminal, type the following and press enter.  vagrant version  You should see a message like:  Installed Version: 1.7.2  If so, Vagrant is installed properly, and you can skip the rest of this section.  If instead you see a message like:  vagrant: Command not found.  Then you need to install Vagrant by doing the following.   On Mac OS or Linux or Windows, visit the  official Vagrant\n  website  and follow their instructions to\n  install it.", 
            "title": "Ensure Vagrant is installed"
        }, 
        {
            "location": "/vagrant-spk/installation/#ensure-virtualbox-is-installed", 
            "text": "In this tutorial, we use VirtualBox to emulate a computer on which we run\nLinux, controlled via Vagrant.  To check if it is installed, in the terminal, type the following and press\nenter:  VirtualBox --help  You should see a lot of output, for example:  Oracle VM VirtualBox Manager x.y.z\n(C) 2005-2015 Oracle Corporation\nAll rights reserved.  If so, skip the rest of this section, as VirtualBox is already properly installed.  If you saw instead:  VirtualBox: Command not found.  Then you need to install VirtualBox by doing following:   Visit the  VirtualBox downloads page  In the  top , underneath  VirtualBox platform packages , find the package for your operating system. Click the link, download, and install it.  Once you are done with that, go to the top of this section and make sure you can see the VirtualBox help output.", 
            "title": "Ensure VirtualBox is installed"
        }, 
        {
            "location": "/vagrant-spk/installation/#no-need-to-install-sandstorm-directly", 
            "text": "You do  not  need Sandstorm installed on your computer before you\nstart packaging an app. Sandstorm's  vagrant-spk  helper tool handles\ninstalling it for you.  It creates a Sandstorm install unique to each app you are developing.", 
            "title": "No need to install Sandstorm directly"
        }, 
        {
            "location": "/vagrant-spk/installation/#install-vagrant-spk", 
            "text": "Finally, you can install  vagrant-spk  itself. This tool uses Vagrant\nand VirtualBox so that you can run your app within Sandstorm on a\nLinux virtual machine.  Windows users  Visit the  vagrant-spk releases\nlist  and run\nthe Windows installer ( vagrant-spk-setup-v0.xyy.exe ). It may need\nadministrator privileges to successfully install.  Mac OS or Linux  In your terminal, run the following commands to download and install  vagrant-spk .  mkdir -p ~/projects\ncd ~/projects\ngit clone git://github.com/sandstorm-io/vagrant-spk\ncd vagrant-spk\nsudo ln -s $PWD/vagrant-spk /usr/local/bin  (Note: If you prefer different paths, that is OK.)", 
            "title": "Install vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/", 
            "text": "Packaging tutorial (Generic)\n\n\nStyle: Hands-on introductory tutorial.\n\n\nThis tutorial will show you how to package an app for\n\nSandstorm\n in five minutes. Going through\nthis tutorial, you'll learn:\n\n\n\n\n\n\nHow to take an existing web application and turn into a Sandstorm\n  package (SPK).\n\n\n\n\n\n\nHow our packaging helper (\nvagrant-spk\n) lets you edit the app's files on your\n  main operating system (Mac or Linux; working on Windows support), even though Sandstorm apps always\n  run on Linux.\n\n\n\n\n\n\nThe tutorial uses a PHP app as an example. \nSandstorm supports any\nprogramming language that runs on Linux\n, not just PHP, such as\nMeteor, Python, Rails, Node, PHP, C++, Go, Rust, and more. Read about\n\nvagrant-spk's platform stacks\n to see how to optimize\nyour package for your app's programming language.\n\n\nOnce you've worked through this tutorial, look in the \nNext steps\n section\nat the bottom of this document to learn more about how to improve the speed\nof packaging on your computer, learn about user authentication and\npermissions in Sandstorm, and more.\n\n\nOverview of Sandstorm packages\n\n\nA Sandstorm application package includes all the code needed to run your\napp, including all binaries, libraries, modules, etc. Normally, figuring out\nexactly what to put in a package could be tedious, and if you decide to include\neverything, it would result in a massive package file. Sandstorm makes it easy to keep things\nsmall by employing a trick: it watches your server running on your development machine\nand pulls in all the files the server uses.\n\n\nKeeping the package small means that it's easy for people to install and update\nthe package you're creating.\n\n\nSandstorm packages rely on the Sandstorm platform to handle adding new user\naccounts and other access control elements. Read more in the\n\nApp Developer Handbook\n.\n\n\nBefore proceeding, install vagrant-spk\n\n\nMake sure you've worked through the\n\nvagrant-spk installation guide\n before going through this tutorial!\n\n\nCreating a package\n\n\nOver the course of section, we will use \nvagrant-spk\n to create a\nSandstorm package containing the app and all its dependencies.\n\n\nChoose an app that you will package\n\n\nThis tutorial uses a sample PHP web app. To download it, run the following commands:\n\n\ncd ~/projects\ngit clone git://github.com/paulproteus/php-app-to-package-for-sandstorm\n\n\n\n\nThe app's code will be stored at\n\n~/projects/php-app-to-package-for-sandstorm\n.  We will spend the rest\nof the tutorial in that directory and its sub-directories.\n\n\nNote\n: Feel free to spend a moment looking around this folder you\njust downloaded. You'll find an \nindex.php\n and some CSS and\nJavascript.\n\n\nCreate .sandstorm, to store packaging information for the app\n\n\nOver the course of this tutorial, we will create and modify the\n\n.sandstorm/\n directory in the project. This directory contains the Sandstorm\npackaging information, such as the app name and the scripts required to\ncreate the package.\n\n\nWe'll use the \nvagrant-spk\n tool to create this directory.\n\n\nThe purpose of \nvagrant-spk\n is to create a Linux system where Sandstorm and\nyour app run successfully. It acts differently based on which \nlanguage platform\n\nyou want to use. In our case, we'll use the \nlemp\n platform: Linux, nginx, MySQL,\nand PHP.\n\n\nTo do that, run the following commands:\n\n\ncd ~/projects/php-app-to-package-for-sandstorm\nvagrant-spk setupvm lemp\n\n\n\n\nYou should see a message like the following:\n\n\nInitializing .sandstorm directory in /Users/myself/projects/php-app-to-package-for-sandstorm/.sandstorm\n\n\n\n\nYou should also find that the \n.sandstorm/\n directory now exists in your project.\nHere's how you can take a look:\n\n\nls ~/projects/php-app-to-package-for-sandstorm/.sandstorm\n\n\n\n\nStart a virtual Linux machine containing Sandstorm\n\n\nThe next step is to start the virtual Linux machine, containing\nSandstorm, that you will develop the package with. To do that, run the following\ncommand:\n\n\nvagrant-spk up\n\n\n\n\n(You should be running it from the \n~/projects/php-app-to-package-for-sandstorm\n directory.)\n\n\nYou will see a \nlot\n of messages printed out. Some of them are not necessary;\nwe're working on tidying up the scripts to minimize the noise.\n\n\nEventually, you will see this mesage:\n\n\n==\n default: Processing triggers for php5-fpm (5.6.9+dfsg-0+deb8u1) ...\n\n\n\n\nand get your shell back. At this point, you can continue to the next step.\n\n\nTroubleshooting note\n: If you already have Sandstorm installed on your laptop,\nyou might see the following red text:\n\n\nVagrant cannot forward the specified ports on this VM, since they\nwould collide with some other application that is already listening\non these ports. The forwarded port to 6080 is already in use\non the host machine.\n\n\n\n\nIf you see that, run:\n\n\nsudo service sandstorm stop\n\n\n\n\nand halt any other \nvagrant-spk\n virtual machines you might be using to develop\nother apps.\n\n\nExamine the Sandstorm instance you will develop against\n\n\nYour system is now running a Sandstorm instance. You should visit it\nin your web browser now by visiting\n\n\nhttp://local.sandstorm.io:6080/\n\n\nTake a moment now to sign in by clicking on \nSign in\n in the top-right corner.\nChoose \nSign in with a Dev account\n and choose \nAlice (admin)\n as the user\nto sign in with.\n\n\nNote that there are other \"dev accounts\" available -- you can use this to test\nthe experience of using your app as other users.\n\n\nOver the next few steps, we will prepare the app so that it is visible in that\nSandstorm instance.\n\n\n\n\n\nUse vagrant-spk to create a package definition file for your app\n\n\nEvery Sandstorm package needs to declare its name. It does this in a\n\nsandstorm-pkgdef.capnp\n file. (\ncapnp\n is short for Cap'n Proto; for the\npurpose of this tutorial, Cap'n Proto is a configuration file format that is\neasy for Sandstorm to parse.)\n\n\nLet's use \nvagrant-spk\n to create a package definition file by running:\n\n\nvagrant-spk init\n\n\n\n\n(You should be running it from the \n~/projects/php-app-to-package-for-sandstorm\n directory.)\n\n\nThis will create a new file called \n.sandstorm/sandstorm-pkdef.capnp\n.\n\n\nWe'll make two changes. First, we'll give our app a \ntitle\n of\n\nSandstorm Showcase\n. To do that, open \n.sandstorm/sandstorm-pkgdef.capnp\n in\na text editor and find the line with this text:\n\n\n    appTitle = (defaultText = \nExample App\n),\n\n\n\n\nChange it to the following.\n\n\n    appTitle = (defaultText = \nSandstorm Showcase\n),\n\n\n\n\nSecond, we will customize the text that Sandstorm users see when they want\nto create a new \ninstance\n of the app. To do this, find the line containing:\n\n\n      ( title = (defaultText = \nNew Instance\n),\n\n\n\n\nand change it to read:\n\n\n      ( title = (defaultText = \nNew Showcase\n),\n\n\n\n\nMake the app available in the Sandstorm, in development mode\n\n\nSandstorm app development focuses around \ndev\n mode, which makes the current\ncode of an app available.\n\n\nMake this app available in dev mode by doing:\n\n\nvagrant-spk dev\n\n\n\n\n(You should be running it from the \n~/projects/php-app-to-package-for-sandstorm\n directory.)\n\n\nOn the terminal, you will see a message like:\n\n\nApp is now available from Sandstorm server. Ctrl+C to disconnect.\n\n\n\n\nNow you can visit the Sandstorm at http://local.sandstorm.io:6080/ and log in\nas \nAlice (admin)\n. Your app name should appear in the list of apps.\n\n\nYou can click \nNew Showcase\n and see the PHP code running.\n\n\nNote that each app instance (each \"Showcase\", for this app) runs separate from\neach other. You can see that for this app because the app stores the number\nof times you have reloaded the page. If you create another \nNew Showcase\n,\neach instance will store their data separately.\n\n\nIn Sandstorm, resources like a database are embedded into the package. That\nhelps enforce this isolation between app instances.\n\n\nStop the development server and create a package file\n\n\nThe final step in this tutorial is to create a Sandstorm package (SPK) file,\ncontaining the app and all its dependencies. This SPK file is something that\nyou can give directly to people who want to use the code, or add to the\nSandstorm app list so people can install it easily from their own servers.\n\n\nTo do that, we first stop the \nvagrant-spk dev\n server. To do that, type\n\nCtrl-C\n on your keyboard. You will see some messages like:\n\n\nUnmounted cleanly.\nUpdating file list.\n\n\n\n\nIf you're still logged into your Sandstorm instance, you will notice the app\nvanishing from the list of apps on the left.\n\n\nTo create the SPK file, run:\n\n\nvagrant-spk pack ~/projects/package.spk\n\n\n\n\n(You should be running it from the \n~/projects/php-app-to-package-for-sandstorm\n directory.)\n\n\nThis will take a few moments, and once it is done, there will be a file in\n\n~/projects/package.spk\n that contains the full app.\n\n\nYou can see how large it is by running the following command:\n\n\ndu -h ~/projects/package.spk\n\n\n\n\nOn my system, I see:\n\n\n16M\n\n\n\n\nor sixteen megabytes.\n\n\nNow, you can upload this to your development Sandstorm instance by clicking\n*\nUpload app\n and choosing this file in your web browser's upload dialog.\n\n\nTo learn how to go further and share this SPK file, or what you should know\nfor other web frameworks, check out the \nWhat's next\n section below.\n\n\n\n\n\nStop the virtual machine running your app and Sandstorm\n\n\nWith \nvagrant-spk\n, before you can develop a second app, you must stop\nthe virtual machine created as part of developing the first one.  This\nis because the \nvagrant-spk\n virtual machine always uses port 6080.\n\n\nIn our case, we're done using the virtual machine running this app, so\nit's safe to stop it. Run this command:\n\n\nvagrant-spk halt\n\n\n\n\n(You should be running it from the \n~/projects/php-app-to-package-for-sandstorm\n directory.)\n\n\nNow port 6080 is available for other app packaging projects. If you ever want to work on\nthis app's packaging again, you can bring it up by running:\n\n\nvagrant-spk up\n\n\n\n\nIf you ever are confused about which Vagrant virtual machines are\nrunning, you can try this command:\n\n\nvagrant global-status\n\n\n\n\n(\nNote\n: It's \nvagrant\n here, not \nvagrant-spk\n.)\n\n\nWhat's next\n\n\nNow that you've seen the basics of how a Sandstorm app works, you\nmight be interested in any of the following:\n\n\n\n\nWhat makes a great Sandstorm app? See the App Developer Handbook.\n\n\nHow do I learn more about the technical underpinnings of \nvagrant-spk\n? How do I make \nvagrant-spk\n faster?\nRead about \nunderstanding \n customizing vagrant-spk\n.\n\n\nHow do I package-up a Python, Meteor, or other non-PHP app? Read about \nplatform stacks\n.\n\n\nWill this work on Windows? No, not yet. Sorry, we're working on it.\n\n\nWill this work if I typically run Sandstorm-related programs in a virtual machine? We don't know, but we hope so.", 
            "title": "Packaging tutorial"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#packaging-tutorial-generic", 
            "text": "Style: Hands-on introductory tutorial.  This tutorial will show you how to package an app for Sandstorm  in five minutes. Going through\nthis tutorial, you'll learn:    How to take an existing web application and turn into a Sandstorm\n  package (SPK).    How our packaging helper ( vagrant-spk ) lets you edit the app's files on your\n  main operating system (Mac or Linux; working on Windows support), even though Sandstorm apps always\n  run on Linux.    The tutorial uses a PHP app as an example.  Sandstorm supports any\nprogramming language that runs on Linux , not just PHP, such as\nMeteor, Python, Rails, Node, PHP, C++, Go, Rust, and more. Read about vagrant-spk's platform stacks  to see how to optimize\nyour package for your app's programming language.  Once you've worked through this tutorial, look in the  Next steps  section\nat the bottom of this document to learn more about how to improve the speed\nof packaging on your computer, learn about user authentication and\npermissions in Sandstorm, and more.", 
            "title": "Packaging tutorial (Generic)"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#overview-of-sandstorm-packages", 
            "text": "A Sandstorm application package includes all the code needed to run your\napp, including all binaries, libraries, modules, etc. Normally, figuring out\nexactly what to put in a package could be tedious, and if you decide to include\neverything, it would result in a massive package file. Sandstorm makes it easy to keep things\nsmall by employing a trick: it watches your server running on your development machine\nand pulls in all the files the server uses.  Keeping the package small means that it's easy for people to install and update\nthe package you're creating.  Sandstorm packages rely on the Sandstorm platform to handle adding new user\naccounts and other access control elements. Read more in the App Developer Handbook .", 
            "title": "Overview of Sandstorm packages"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#before-proceeding-install-vagrant-spk", 
            "text": "Make sure you've worked through the vagrant-spk installation guide  before going through this tutorial!", 
            "title": "Before proceeding, install vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#creating-a-package", 
            "text": "Over the course of section, we will use  vagrant-spk  to create a\nSandstorm package containing the app and all its dependencies.  Choose an app that you will package  This tutorial uses a sample PHP web app. To download it, run the following commands:  cd ~/projects\ngit clone git://github.com/paulproteus/php-app-to-package-for-sandstorm  The app's code will be stored at ~/projects/php-app-to-package-for-sandstorm .  We will spend the rest\nof the tutorial in that directory and its sub-directories.  Note : Feel free to spend a moment looking around this folder you\njust downloaded. You'll find an  index.php  and some CSS and\nJavascript.", 
            "title": "Creating a package"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#create-sandstorm-to-store-packaging-information-for-the-app", 
            "text": "Over the course of this tutorial, we will create and modify the .sandstorm/  directory in the project. This directory contains the Sandstorm\npackaging information, such as the app name and the scripts required to\ncreate the package.  We'll use the  vagrant-spk  tool to create this directory.  The purpose of  vagrant-spk  is to create a Linux system where Sandstorm and\nyour app run successfully. It acts differently based on which  language platform \nyou want to use. In our case, we'll use the  lemp  platform: Linux, nginx, MySQL,\nand PHP.  To do that, run the following commands:  cd ~/projects/php-app-to-package-for-sandstorm\nvagrant-spk setupvm lemp  You should see a message like the following:  Initializing .sandstorm directory in /Users/myself/projects/php-app-to-package-for-sandstorm/.sandstorm  You should also find that the  .sandstorm/  directory now exists in your project.\nHere's how you can take a look:  ls ~/projects/php-app-to-package-for-sandstorm/.sandstorm", 
            "title": "Create .sandstorm, to store packaging information for the app"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#start-a-virtual-linux-machine-containing-sandstorm", 
            "text": "The next step is to start the virtual Linux machine, containing\nSandstorm, that you will develop the package with. To do that, run the following\ncommand:  vagrant-spk up  (You should be running it from the  ~/projects/php-app-to-package-for-sandstorm  directory.)  You will see a  lot  of messages printed out. Some of them are not necessary;\nwe're working on tidying up the scripts to minimize the noise.  Eventually, you will see this mesage:  ==  default: Processing triggers for php5-fpm (5.6.9+dfsg-0+deb8u1) ...  and get your shell back. At this point, you can continue to the next step.  Troubleshooting note : If you already have Sandstorm installed on your laptop,\nyou might see the following red text:  Vagrant cannot forward the specified ports on this VM, since they\nwould collide with some other application that is already listening\non these ports. The forwarded port to 6080 is already in use\non the host machine.  If you see that, run:  sudo service sandstorm stop  and halt any other  vagrant-spk  virtual machines you might be using to develop\nother apps.", 
            "title": "Start a virtual Linux machine containing Sandstorm"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#examine-the-sandstorm-instance-you-will-develop-against", 
            "text": "Your system is now running a Sandstorm instance. You should visit it\nin your web browser now by visiting  http://local.sandstorm.io:6080/  Take a moment now to sign in by clicking on  Sign in  in the top-right corner.\nChoose  Sign in with a Dev account  and choose  Alice (admin)  as the user\nto sign in with.  Note that there are other \"dev accounts\" available -- you can use this to test\nthe experience of using your app as other users.  Over the next few steps, we will prepare the app so that it is visible in that\nSandstorm instance.", 
            "title": "Examine the Sandstorm instance you will develop against"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#use-vagrant-spk-to-create-a-package-definition-file-for-your-app", 
            "text": "Every Sandstorm package needs to declare its name. It does this in a sandstorm-pkgdef.capnp  file. ( capnp  is short for Cap'n Proto; for the\npurpose of this tutorial, Cap'n Proto is a configuration file format that is\neasy for Sandstorm to parse.)  Let's use  vagrant-spk  to create a package definition file by running:  vagrant-spk init  (You should be running it from the  ~/projects/php-app-to-package-for-sandstorm  directory.)  This will create a new file called  .sandstorm/sandstorm-pkdef.capnp .  We'll make two changes. First, we'll give our app a  title  of Sandstorm Showcase . To do that, open  .sandstorm/sandstorm-pkgdef.capnp  in\na text editor and find the line with this text:      appTitle = (defaultText =  Example App ),  Change it to the following.      appTitle = (defaultText =  Sandstorm Showcase ),  Second, we will customize the text that Sandstorm users see when they want\nto create a new  instance  of the app. To do this, find the line containing:        ( title = (defaultText =  New Instance ),  and change it to read:        ( title = (defaultText =  New Showcase ),", 
            "title": "Use vagrant-spk to create a package definition file for your app"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#make-the-app-available-in-the-sandstorm-in-development-mode", 
            "text": "Sandstorm app development focuses around  dev  mode, which makes the current\ncode of an app available.  Make this app available in dev mode by doing:  vagrant-spk dev  (You should be running it from the  ~/projects/php-app-to-package-for-sandstorm  directory.)  On the terminal, you will see a message like:  App is now available from Sandstorm server. Ctrl+C to disconnect.  Now you can visit the Sandstorm at http://local.sandstorm.io:6080/ and log in\nas  Alice (admin) . Your app name should appear in the list of apps.  You can click  New Showcase  and see the PHP code running.  Note that each app instance (each \"Showcase\", for this app) runs separate from\neach other. You can see that for this app because the app stores the number\nof times you have reloaded the page. If you create another  New Showcase ,\neach instance will store their data separately.  In Sandstorm, resources like a database are embedded into the package. That\nhelps enforce this isolation between app instances.", 
            "title": "Make the app available in the Sandstorm, in development mode"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#stop-the-development-server-and-create-a-package-file", 
            "text": "The final step in this tutorial is to create a Sandstorm package (SPK) file,\ncontaining the app and all its dependencies. This SPK file is something that\nyou can give directly to people who want to use the code, or add to the\nSandstorm app list so people can install it easily from their own servers.  To do that, we first stop the  vagrant-spk dev  server. To do that, type Ctrl-C  on your keyboard. You will see some messages like:  Unmounted cleanly.\nUpdating file list.  If you're still logged into your Sandstorm instance, you will notice the app\nvanishing from the list of apps on the left.  To create the SPK file, run:  vagrant-spk pack ~/projects/package.spk  (You should be running it from the  ~/projects/php-app-to-package-for-sandstorm  directory.)  This will take a few moments, and once it is done, there will be a file in ~/projects/package.spk  that contains the full app.  You can see how large it is by running the following command:  du -h ~/projects/package.spk  On my system, I see:  16M  or sixteen megabytes.  Now, you can upload this to your development Sandstorm instance by clicking\n* Upload app  and choosing this file in your web browser's upload dialog.  To learn how to go further and share this SPK file, or what you should know\nfor other web frameworks, check out the  What's next  section below.", 
            "title": "Stop the development server and create a package file"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#stop-the-virtual-machine-running-your-app-and-sandstorm", 
            "text": "With  vagrant-spk , before you can develop a second app, you must stop\nthe virtual machine created as part of developing the first one.  This\nis because the  vagrant-spk  virtual machine always uses port 6080.  In our case, we're done using the virtual machine running this app, so\nit's safe to stop it. Run this command:  vagrant-spk halt  (You should be running it from the  ~/projects/php-app-to-package-for-sandstorm  directory.)  Now port 6080 is available for other app packaging projects. If you ever want to work on\nthis app's packaging again, you can bring it up by running:  vagrant-spk up  If you ever are confused about which Vagrant virtual machines are\nrunning, you can try this command:  vagrant global-status  ( Note : It's  vagrant  here, not  vagrant-spk .)", 
            "title": "Stop the virtual machine running your app and Sandstorm"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial/#whats-next", 
            "text": "Now that you've seen the basics of how a Sandstorm app works, you\nmight be interested in any of the following:   What makes a great Sandstorm app? See the App Developer Handbook.  How do I learn more about the technical underpinnings of  vagrant-spk ? How do I make  vagrant-spk  faster?\nRead about  understanding   customizing vagrant-spk .  How do I package-up a Python, Meteor, or other non-PHP app? Read about  platform stacks .  Will this work on Windows? No, not yet. Sorry, we're working on it.  Will this work if I typically run Sandstorm-related programs in a virtual machine? We don't know, but we hope so.", 
            "title": "What's next"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/", 
            "text": "Packaging tutorial (Meteor)\n\n\nIntroduction\n\n\nThis tutorial will show you how to make a\n\nSandstorm.io\n package from a Meteor app.\n\n\nCreating the package will take about five minutes of focused time,\ninterspersed with the downloading of various components, which can\ntake up to half an hour.\n\n\nLook through the \"Next steps\" to learn more about how Sandstorm works\nand how to integrate Sandstorm with the Meteor accounts system.\n\n\nThis tutorial assumes:\n\n\n\n\n\n\nYou know the basics of Meteor and know how to open a terminal.\n\n\n\n\n\n\nYou have a computer running Mac OS or Linux or Windows.\n\n\n\n\n\n\nWindows users, please note\n: This tutorial should work for you, but\nyou might need to use slightly different commands to do things like\ncreate directories. Contact community@sandstorm.io if you need help.\n\n\nOverview of Sandstorm packages\n\n\nThe tutorial uses a Meteor app as an example. \nSandstorm supports any\nprogramming language that runs on Linux\n, not just Meteor, such as\nPython, Rails, Node, PHP, C++, Go, Rust, and more. Read about\n\nvagrant-spk's platform stacks\n to see how to\noptimize your package for your app's programming language.\n\n\nOnce you've worked through this tutorial, look in the \nNext steps\n section\nat the bottom of this document to learn more about how to improve the speed\nof packaging on your computer, learn about user authentication and\npermissions in Sandstorm, and more.\n\n\nA Sandstorm application package (\"SPK file\" for short) includes all\nthe code needed to run your app, including all binaries, libraries,\nmodules, etc. Sandstorm relies on Meteor's \nmeteor build\n system to\ncreate the package.\n\n\nMaking a Sandstorm package enables people to:\n\n\n\n\n\n\nCreate an instance of the app (\"grain\") with one click.\n\n\n\n\n\n\nCreate a private grain of the app, secured by Sandstorm.\n\n\n\n\n\n\nInvite others to the grain through a Google Docs-like sharing\n  interface.\n\n\n\n\n\n\nTrust that the data they enter into the app stays private to the\n  app, due to Sandstorm's sandboxing.\n\n\n\n\n\n\nSandstorm packages rely on the Sandstorm platform to handle user login\nand access control. You can read more in the \nApp Developer\nHandbook\n. You can use an Atmosphere\npackage called\n\nkenton:accounts-sandstorm\n\nto integrate with that.\n\n\nPrepare the app\n\n\nIn this tutorial, we make a package for a web-based clock that is made\nwith Meteor. To create it, run the following commands:\n\n\nmkdir -p ~/projects/sandstorm-packaging-tutorial\ncd ~/projects/sandstorm-packaging-tutorial\nmeteor create --example clock\n\n\n\n\nYou now have a fully functional Meteor app stored in\n\n~/projects/sandstorm-packaging-tutorial/clock\n.\n\n\nNote\n: This is a regular Meteor app, so you can play with it\nby running \nmeteor\n and you can import it into git if you like.\n\n\nSet up for Sandstorm development\n\n\nIn this step, you will install the main Sandstorm app development\ntool, a command-line tool called \nvagrant-spk\n.\n\n\nThat tool automates the process of creating a Linux virtual machine,\ninstalling Sandstorm in the virtual machine, running your app in\nSandstorm, capturing its dependencies, and creating a package file you\ncan distribute so anyone with Sandstorm can see what you saw.\n\n\nGet your computer ready.\n Follow the \nvagrant-spk installation\nguide\n before proceeding.\n\n\nOnce installed, you can use the \nvagrant-spk\n command to create a\nLinux virtual machine. Make sure it's installed by running:\n\n\nvagrant-spk --help\n\n\n\n\nYou should see a message like:\n\n\nusage: /usr/local/bin/vagrant-spk [-h] [--work-directory WORK_DIRECTORY]\n                                  {setupvm,up,init,dev,pack,publish,halt,destroy,global-status,ssh}\n                                  [command_specific_args [command_specific_args ...]]\n...\n\n\n\n\nYou need to install \nvagrant-spk\n just once, and you can use it to\ncreate any number of Sandstorm packages.\n\n\nStart a virtual machine ready to run Sandstorm and Meteor\n\n\nSandstorm packages contain the full set of executable code required to\nrun an app on a Linux machine. \nvagrant-spk\n can prepare an isolated\nenvironment with your app and its Meteor dependencies in order to\nbundle them together into a Sandstorm package. The virtual machine it\ncreates runs Linux, which allows you to create packages that run on\nLinux-based Sandstorm servers no matter what your main operating\nsystem is.\n\n\nTo define a new machine to run your app inside, run this command:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk setupvm meteor\n\n\n\n\nYou should see a message like the following:\n\n\nInitializing .sandstorm directory in /Users/myself/projects/sandstorm-packaging-tutorial/clock/.sandstorm\n\n\n\n\nvagrant-spk\n stores packaging information in a \n.sandstorm/\n\ndirectory within your app. The directory contains executable scripts\nthat define how the app is packaged as well as metadata like the\nauthors' names, the app's name, and icons for the app. We encourage\nyou to store this directory with the source code of your app; that\nway, your colleagues can submit changes to the Sandstorm packaging.\n\n\nNow switch the virtual machine on. This \nwill take a while\n, perhaps\n2-20 minutes the first time it boots, depending on your Internet\nconnection.\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk up\n\n\n\n\nYou will see a \nlot\n of messages printed out. Some of them are not\nnecessary; we're working on tidying up the scripts to minimize the\nnoise.\n\n\nEventually, you will get your shell back. At this point, you can\ncontinue to the next step.\n\n\nTroubleshooting note\n: If the \nvagrant-spk up\n command fails, it\ncould be because you already have Sandstorm installed on your\nlaptop. You can recognize this error via the following red text:\n\n\nVagrant cannot forward the specified ports on this VM, since they\nwould collide with some other application that is already listening\non these ports. The forwarded port to 6080 is already in use\non the host machine.\n\n\n\n\nIf you see that, run:\n\n\nsudo service sandstorm stop\n\n\n\n\nand halt any other \nvagrant-spk\n virtual machines you might be using\nto develop other apps.\n\n\nConnect your app to your local Sandstorm server\n\n\nApps run differently in Sandstorm, compared to \nmeteor deploy\n, so\nit's essential to preview what your app would look like when running\nin Sandstorm. \nvagrant-spk\n helps you do this by providing a Sandstorm\nserver within a Linux virtual machine.\n\n\nBefore we can see the app in Sandstorm, it needs to have a package\ndefinition file specifying the app's title and other metadata. Create\nit with this command:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk init\n\n\n\n\n\n\n\nThis will create a \n.sandstorm/sandstorm-pkdef.capnp\n file, containing\nsome defaults.\n\n\nNow make the app available to the Sandstorm server by running:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk dev\n\n\n\n\nThis step \ncan take some time\n to download the Meteor dependencies\nof the app.  Once it is done, you will see a message like:\n\n\nApp is now available from Sandstorm server. Ctrl+C to disconnect.\n\n\n\n\nWhen we visit the Sandstorm server, we'll see the app available. Open up\nthis URL in your web browser:\n\nhttp://local.sandstorm.io:6080/\n\n\nA note about \nlocal.sandstorm.io\n: This is the same as \nlocalhost\n,\nbut in Sandstorm's security model, each session to the app uses a\ntemporary subdomain of the main Sandstorm URL. This is an\nimplemenation detail that your app mostly does not need to know about,\nbut it does mean that the domain name running Sandstorm needs\n\nwildcard DNS\n. We created\n\nlocal.sandstorm.io\n as an alias for \nlocalhost\n and gave it wildcard\nDNS. You can rest assured that your interactions with\n\nlocal.sandstorm.io\n stay entirely on your computer.\n\n\n\n\n\nTake a moment now to sign in. Choose \nwith a Dev account\n and choose\n\nAlice (admin)\n. You will have to enter an email address; you can use\n\nalice@example.com\n.\n\n\nYou should see an app in the apps list called \nExample App\n.\n\n\nLaunch your app with one click\n\n\nSandstorm is a platform where users without technical knowledge can\nlaunch instances of web apps, called \"grains.\" To launch an instance\nof the clock, click on the icon above \nExample App\n.\n\n\nYou'll now see a clock! It has the name \nUntitled Instance\n.\n\n\nSandstorm makes it easy to run multiple instances of an app; each one\nis called a \ngrain\n. Anyone with your app available on their Sandstorm\ninstance can create a new grain by clicking its icon.\n\n\nYou can test this out by going back to the \nNew\n menu and creating\none or two more grains of the app right now. The \nOpen\n menu enables\nyou to switch between different grains.\n\n\nSandstorm apps often need fewer lines of code than regular web\napps. They need to contain the web interface for creating exactly one\ndocument, or editing just one image, or publishing one single\nblog. Document management is delegated to Sandstorm.\n\n\nEach grain runs totally isolated from other grains. For Meteor apps,\neach grain has its own MongoDB server and database. Embedding the\ndatabase server into the package helps enforce isolation between app\ninstances: a crash or security issue in one grain doesn't affect\nanother grain. This also simplifies app packaging; it's OK to use use\nthe same database name for every grain.\n\n\nA word about Meteor, Sandstorm, and hot code push\n: Each call to\n\nvagrant-spk dev\n runs \nmeteor build\n, which disables hot code push in\nMeteor. To update the code you see in Sandstorm, you will need to stop\nand start the \nvagrant-spk dev\n process. This is due to a technical\nlimitation in Sandstorm that we are working on addressing.\n\n\nConfigure your app's name \n other metadata\n\n\nExample App\n is not a very descriptive name for this app, and \nNew\ninstance\n is not a very descriptive name for a grain of this app. We\ncan do better.\n\n\nThis information is stored in\n\n.sandstorm/sandstorm-pkgdef.capnp\n. \ncapnp\n is the file extension for\n\nCap'n Proto\n. For the purpose of this\ntutorial, Cap'n Proto is a configuration file format that is easy for\nSandstorm to parse.\n\n\nTo change the title, open \n.sandstorm/sandstorm-pkgdef.capnp\n in a\ntext editor. Find the line with this text:\n\n\n    appTitle = (defaultText = \nExample App\n),\n\n\n\n\nChange it to the following.\n\n\n    appTitle = (defaultText = \nAnalog Clock\n),\n\n\n\n\nWe can change the text that Sandstorm users see when they want to\ncreate a new \ninstance\n of the app. To do this, find the line\ncontaining:\n\n\n      ( title = (defaultText = \nNew Instance\n),\n\n\n\n\nand change it to read:\n\n\n      ( title = (defaultText = \nNew Clock\n),\n\n\n\n\nTo refresh the information that shows up in\n\nhttp://local.sandstorm.io:6080/\n,\nfind the terminal where you are running \nvagrant-spk dev\n. It should\nhave this line at the end.\n\n\nApp is now available from Sandstorm server. Ctrl+C to disconnect.\n\n\n\n\nHold the \nCtrl\n key and tap \nc\n on your keyboard to get your\nterminal back. Then re-start the process by running these\ncommands.\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk dev\n\n\n\n\nThis \nmay take a minute\n while Meteor verifies it has downloaded all\nyour dependencies.\n\n\nNow visit the the \nNew\n menu. You should see that the app has a new\nname -- \nAnalog Clock\n -- and it allows you to make a \nNew clock\n.\n\n\nCreate an SPK package file\n\n\nThe artifact that Sandstorm app authors deliver to users is a\nSandstorm package (SPK) file, containing the app and all its\ndependencies. The typical way to distribute this is via the \nSandstorm\napp market\n.\n\n\nWe'll build an SPK now. To do that, we must first stop the dev\nserver. To do that, open the terminal window containing the\n\nvagrant-spk dev\n process and type \nCtrl-C\n on your keyboard. You will\nsee some messages like:\n\n\nUnmounted cleanly.\nUpdating file list.\n\n\n\n\nSandstorm stays running, and the app is now disconnected. If you're\nstill logged into your Sandstorm instance, you will notice the app\nvanishing from the list of apps and your grains will become\nbroken. After we upload a Sandstorm package of the app, the grains\nwill heal themselves.\n\n\nTo create the SPK file, run:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk pack ~/projects/package.spk\n\n\n\n\nThis will take a few moments, and once it is done, there will be a\nfile in \n~/projects/package.spk\n that contains the full app.\n\n\nYou can see how large it is by running the following command:\n\n\ndu -h ~/projects/package.spk\n\n\n\n\nIn my case, I see:\n\n\n21M     ~/projects/package.spk\n\n\n\n\nThis file size includes everything the app needs to run: its database\nserver, its libraries, and the Meteor app itself.\n\n\nWe can upload this app to our development Sandstorm server by visiting\nthe \nNew\n tab and clicking \nUpload app - choose SPK file\n, and\nthen choosing this file in your web browser's upload dialog.\n\n\nTo learn how to go further and share this SPK file, or what you should know\nfor other web frameworks, check out the \nWhat's next\n section below.\n\n\n\n\n\nClean up\n\n\nWith \nvagrant-spk\n, before you can develop a second app, you must stop\nthe virtual machine created as part of developing the first one.  This\nis because the \nvagrant-spk\n virtual machine always uses port 6080.\n\n\nIn our case, we're done using the virtual machine running this app, so\nit's safe to stop it. Run this command:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk halt\n\n\n\n\nThis shuts down the whole virtual machine used for developing your\napp's Sandstorm package, including the Sandstorm install specific to\nthat app's packaging work. Now port 6080 is available for other app\npackaging projects.\n\n\nIf you ever want to work on this app's packaging again, you can bring\nit online by running:\n\n\ncd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk up\n\n\n\n\nIf you ever are confused about which Vagrant virtual machines are\nrunning, run this command:\n\n\nvagrant global-status\n\n\n\n\n(\nNote\n: It's \nvagrant\n here, not \nvagrant-spk\n.)\n\n\nNext steps\n\n\nNow that you've seen the basics of how a Sandstorm app works, you\nmight be interested in any of the following:\n\n\n\n\n\n\n\nWhat makes a great Sandstorm app? See the \nApp Developer Handbook\n.\n\n\nHow do I learn more about the technical underpinnings of \nvagrant-spk\n? How do I make \nvagrant-spk\n faster?\nRead about \nunderstanding \n customizing vagrant-spk\n.\n\n\nHow do I package-up a Python, PHP, or other non-Meteor app? Read about \nplatform stacks\n.\n\n\nWill this work on Windows? Yes, probably, but I use \n~\n and \nmkdir -p\n above, and you can't typically use those on Windows.\n\n\nWill this work on a cloud Linux instance? Probably not, since \nvagrant-spk\n creates a virtual machine and running a VM inside a VM often fails.", 
            "title": "Packaging tutorial (Meteor)"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#packaging-tutorial-meteor", 
            "text": "", 
            "title": "Packaging tutorial (Meteor)"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#introduction", 
            "text": "This tutorial will show you how to make a Sandstorm.io  package from a Meteor app.  Creating the package will take about five minutes of focused time,\ninterspersed with the downloading of various components, which can\ntake up to half an hour.  Look through the \"Next steps\" to learn more about how Sandstorm works\nand how to integrate Sandstorm with the Meteor accounts system.  This tutorial assumes:    You know the basics of Meteor and know how to open a terminal.    You have a computer running Mac OS or Linux or Windows.    Windows users, please note : This tutorial should work for you, but\nyou might need to use slightly different commands to do things like\ncreate directories. Contact community@sandstorm.io if you need help.", 
            "title": "Introduction"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#overview-of-sandstorm-packages", 
            "text": "The tutorial uses a Meteor app as an example.  Sandstorm supports any\nprogramming language that runs on Linux , not just Meteor, such as\nPython, Rails, Node, PHP, C++, Go, Rust, and more. Read about vagrant-spk's platform stacks  to see how to\noptimize your package for your app's programming language.  Once you've worked through this tutorial, look in the  Next steps  section\nat the bottom of this document to learn more about how to improve the speed\nof packaging on your computer, learn about user authentication and\npermissions in Sandstorm, and more.  A Sandstorm application package (\"SPK file\" for short) includes all\nthe code needed to run your app, including all binaries, libraries,\nmodules, etc. Sandstorm relies on Meteor's  meteor build  system to\ncreate the package.  Making a Sandstorm package enables people to:    Create an instance of the app (\"grain\") with one click.    Create a private grain of the app, secured by Sandstorm.    Invite others to the grain through a Google Docs-like sharing\n  interface.    Trust that the data they enter into the app stays private to the\n  app, due to Sandstorm's sandboxing.    Sandstorm packages rely on the Sandstorm platform to handle user login\nand access control. You can read more in the  App Developer\nHandbook . You can use an Atmosphere\npackage called kenton:accounts-sandstorm \nto integrate with that.", 
            "title": "Overview of Sandstorm packages"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#prepare-the-app", 
            "text": "In this tutorial, we make a package for a web-based clock that is made\nwith Meteor. To create it, run the following commands:  mkdir -p ~/projects/sandstorm-packaging-tutorial\ncd ~/projects/sandstorm-packaging-tutorial\nmeteor create --example clock  You now have a fully functional Meteor app stored in ~/projects/sandstorm-packaging-tutorial/clock .  Note : This is a regular Meteor app, so you can play with it\nby running  meteor  and you can import it into git if you like.", 
            "title": "Prepare the app"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#set-up-for-sandstorm-development", 
            "text": "In this step, you will install the main Sandstorm app development\ntool, a command-line tool called  vagrant-spk .  That tool automates the process of creating a Linux virtual machine,\ninstalling Sandstorm in the virtual machine, running your app in\nSandstorm, capturing its dependencies, and creating a package file you\ncan distribute so anyone with Sandstorm can see what you saw.  Get your computer ready.  Follow the  vagrant-spk installation\nguide  before proceeding.  Once installed, you can use the  vagrant-spk  command to create a\nLinux virtual machine. Make sure it's installed by running:  vagrant-spk --help  You should see a message like:  usage: /usr/local/bin/vagrant-spk [-h] [--work-directory WORK_DIRECTORY]\n                                  {setupvm,up,init,dev,pack,publish,halt,destroy,global-status,ssh}\n                                  [command_specific_args [command_specific_args ...]]\n...  You need to install  vagrant-spk  just once, and you can use it to\ncreate any number of Sandstorm packages.", 
            "title": "Set up for Sandstorm development"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#start-a-virtual-machine-ready-to-run-sandstorm-and-meteor", 
            "text": "Sandstorm packages contain the full set of executable code required to\nrun an app on a Linux machine.  vagrant-spk  can prepare an isolated\nenvironment with your app and its Meteor dependencies in order to\nbundle them together into a Sandstorm package. The virtual machine it\ncreates runs Linux, which allows you to create packages that run on\nLinux-based Sandstorm servers no matter what your main operating\nsystem is.  To define a new machine to run your app inside, run this command:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk setupvm meteor  You should see a message like the following:  Initializing .sandstorm directory in /Users/myself/projects/sandstorm-packaging-tutorial/clock/.sandstorm  vagrant-spk  stores packaging information in a  .sandstorm/ \ndirectory within your app. The directory contains executable scripts\nthat define how the app is packaged as well as metadata like the\nauthors' names, the app's name, and icons for the app. We encourage\nyou to store this directory with the source code of your app; that\nway, your colleagues can submit changes to the Sandstorm packaging.  Now switch the virtual machine on. This  will take a while , perhaps\n2-20 minutes the first time it boots, depending on your Internet\nconnection.  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk up  You will see a  lot  of messages printed out. Some of them are not\nnecessary; we're working on tidying up the scripts to minimize the\nnoise.  Eventually, you will get your shell back. At this point, you can\ncontinue to the next step.  Troubleshooting note : If the  vagrant-spk up  command fails, it\ncould be because you already have Sandstorm installed on your\nlaptop. You can recognize this error via the following red text:  Vagrant cannot forward the specified ports on this VM, since they\nwould collide with some other application that is already listening\non these ports. The forwarded port to 6080 is already in use\non the host machine.  If you see that, run:  sudo service sandstorm stop  and halt any other  vagrant-spk  virtual machines you might be using\nto develop other apps.", 
            "title": "Start a virtual machine ready to run Sandstorm and Meteor"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#connect-your-app-to-your-local-sandstorm-server", 
            "text": "Apps run differently in Sandstorm, compared to  meteor deploy , so\nit's essential to preview what your app would look like when running\nin Sandstorm.  vagrant-spk  helps you do this by providing a Sandstorm\nserver within a Linux virtual machine.  Before we can see the app in Sandstorm, it needs to have a package\ndefinition file specifying the app's title and other metadata. Create\nit with this command:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk init   This will create a  .sandstorm/sandstorm-pkdef.capnp  file, containing\nsome defaults.  Now make the app available to the Sandstorm server by running:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk dev  This step  can take some time  to download the Meteor dependencies\nof the app.  Once it is done, you will see a message like:  App is now available from Sandstorm server. Ctrl+C to disconnect.  When we visit the Sandstorm server, we'll see the app available. Open up\nthis URL in your web browser: http://local.sandstorm.io:6080/  A note about  local.sandstorm.io : This is the same as  localhost ,\nbut in Sandstorm's security model, each session to the app uses a\ntemporary subdomain of the main Sandstorm URL. This is an\nimplemenation detail that your app mostly does not need to know about,\nbut it does mean that the domain name running Sandstorm needs wildcard DNS . We created local.sandstorm.io  as an alias for  localhost  and gave it wildcard\nDNS. You can rest assured that your interactions with local.sandstorm.io  stay entirely on your computer.   Take a moment now to sign in. Choose  with a Dev account  and choose Alice (admin) . You will have to enter an email address; you can use alice@example.com .  You should see an app in the apps list called  Example App .", 
            "title": "Connect your app to your local Sandstorm server"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#launch-your-app-with-one-click", 
            "text": "Sandstorm is a platform where users without technical knowledge can\nlaunch instances of web apps, called \"grains.\" To launch an instance\nof the clock, click on the icon above  Example App .  You'll now see a clock! It has the name  Untitled Instance .  Sandstorm makes it easy to run multiple instances of an app; each one\nis called a  grain . Anyone with your app available on their Sandstorm\ninstance can create a new grain by clicking its icon.  You can test this out by going back to the  New  menu and creating\none or two more grains of the app right now. The  Open  menu enables\nyou to switch between different grains.  Sandstorm apps often need fewer lines of code than regular web\napps. They need to contain the web interface for creating exactly one\ndocument, or editing just one image, or publishing one single\nblog. Document management is delegated to Sandstorm.  Each grain runs totally isolated from other grains. For Meteor apps,\neach grain has its own MongoDB server and database. Embedding the\ndatabase server into the package helps enforce isolation between app\ninstances: a crash or security issue in one grain doesn't affect\nanother grain. This also simplifies app packaging; it's OK to use use\nthe same database name for every grain.  A word about Meteor, Sandstorm, and hot code push : Each call to vagrant-spk dev  runs  meteor build , which disables hot code push in\nMeteor. To update the code you see in Sandstorm, you will need to stop\nand start the  vagrant-spk dev  process. This is due to a technical\nlimitation in Sandstorm that we are working on addressing.", 
            "title": "Launch your app with one click"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#configure-your-apps-name-other-metadata", 
            "text": "Example App  is not a very descriptive name for this app, and  New\ninstance  is not a very descriptive name for a grain of this app. We\ncan do better.  This information is stored in .sandstorm/sandstorm-pkgdef.capnp .  capnp  is the file extension for Cap'n Proto . For the purpose of this\ntutorial, Cap'n Proto is a configuration file format that is easy for\nSandstorm to parse.  To change the title, open  .sandstorm/sandstorm-pkgdef.capnp  in a\ntext editor. Find the line with this text:      appTitle = (defaultText =  Example App ),  Change it to the following.      appTitle = (defaultText =  Analog Clock ),  We can change the text that Sandstorm users see when they want to\ncreate a new  instance  of the app. To do this, find the line\ncontaining:        ( title = (defaultText =  New Instance ),  and change it to read:        ( title = (defaultText =  New Clock ),  To refresh the information that shows up in http://local.sandstorm.io:6080/ ,\nfind the terminal where you are running  vagrant-spk dev . It should\nhave this line at the end.  App is now available from Sandstorm server. Ctrl+C to disconnect.  Hold the  Ctrl  key and tap  c  on your keyboard to get your\nterminal back. Then re-start the process by running these\ncommands.  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk dev  This  may take a minute  while Meteor verifies it has downloaded all\nyour dependencies.  Now visit the the  New  menu. You should see that the app has a new\nname --  Analog Clock  -- and it allows you to make a  New clock .", 
            "title": "Configure your app's name &amp; other metadata"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#create-an-spk-package-file", 
            "text": "The artifact that Sandstorm app authors deliver to users is a\nSandstorm package (SPK) file, containing the app and all its\ndependencies. The typical way to distribute this is via the  Sandstorm\napp market .  We'll build an SPK now. To do that, we must first stop the dev\nserver. To do that, open the terminal window containing the vagrant-spk dev  process and type  Ctrl-C  on your keyboard. You will\nsee some messages like:  Unmounted cleanly.\nUpdating file list.  Sandstorm stays running, and the app is now disconnected. If you're\nstill logged into your Sandstorm instance, you will notice the app\nvanishing from the list of apps and your grains will become\nbroken. After we upload a Sandstorm package of the app, the grains\nwill heal themselves.  To create the SPK file, run:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk pack ~/projects/package.spk  This will take a few moments, and once it is done, there will be a\nfile in  ~/projects/package.spk  that contains the full app.  You can see how large it is by running the following command:  du -h ~/projects/package.spk  In my case, I see:  21M     ~/projects/package.spk  This file size includes everything the app needs to run: its database\nserver, its libraries, and the Meteor app itself.  We can upload this app to our development Sandstorm server by visiting\nthe  New  tab and clicking  Upload app - choose SPK file , and\nthen choosing this file in your web browser's upload dialog.  To learn how to go further and share this SPK file, or what you should know\nfor other web frameworks, check out the  What's next  section below.", 
            "title": "Create an SPK package file"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#clean-up", 
            "text": "With  vagrant-spk , before you can develop a second app, you must stop\nthe virtual machine created as part of developing the first one.  This\nis because the  vagrant-spk  virtual machine always uses port 6080.  In our case, we're done using the virtual machine running this app, so\nit's safe to stop it. Run this command:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk halt  This shuts down the whole virtual machine used for developing your\napp's Sandstorm package, including the Sandstorm install specific to\nthat app's packaging work. Now port 6080 is available for other app\npackaging projects.  If you ever want to work on this app's packaging again, you can bring\nit online by running:  cd ~/projects/sandstorm-packaging-tutorial/clock\nvagrant-spk up  If you ever are confused about which Vagrant virtual machines are\nrunning, run this command:  vagrant global-status  ( Note : It's  vagrant  here, not  vagrant-spk .)", 
            "title": "Clean up"
        }, 
        {
            "location": "/vagrant-spk/packaging-tutorial-meteor/#next-steps", 
            "text": "Now that you've seen the basics of how a Sandstorm app works, you\nmight be interested in any of the following:    What makes a great Sandstorm app? See the  App Developer Handbook .  How do I learn more about the technical underpinnings of  vagrant-spk ? How do I make  vagrant-spk  faster?\nRead about  understanding   customizing vagrant-spk .  How do I package-up a Python, PHP, or other non-Meteor app? Read about  platform stacks .  Will this work on Windows? Yes, probably, but I use  ~  and  mkdir -p  above, and you can't typically use those on Windows.  Will this work on a cloud Linux instance? Probably not, since  vagrant-spk  creates a virtual machine and running a VM inside a VM often fails.", 
            "title": "Next steps"
        }, 
        {
            "location": "/developing/publishing-apps/", 
            "text": "App publishing guide\n\n\nAfter you've completed developing and testing your app's package for Sandstorm, you can publish it in the \nSandstorm App Market\n.\n\n\nGet feedback on your app\n\n\nBefore publishing an app to the Sandstorm app market, we recommend you\nemail the \nSandstorm development email\nlist\n with a\nlink to your package, to get feedback. Consider creating a\n\nFileDrop\n\ngrain containing your SPK file.\n\n\nThe \napp testing guide\n provides\nsome guidelines for what to look for while testing.\n\n\nDouble-check your app ID\n\n\nSandstorm identifies every app by a \npublic\nkey\n authorized to sign updates for that\napp. The public key corresponds to a \nprivate key\n stored on your\ncomputer in \n~/.sandstorm/sandstorm-keyring\n.\n\n\nYou can find the app ID for your app in your\n\nsandstorm-pkgdef.capnp\n. It will have a line like:\n\n\n  id = \nvfnwptfn02ty21w715snyyczw0nqxkv3jvawcah10c6z7hj1hnu0\n,\n  # Your app ID is actually its public key. The private key was placed in\n  # your keyring. All updates must be signed with the same key.\n\n\n\n\nIt's \nessential\n that you control this key! If you think someone\nelse might have the key material for your app, now is a good time to\nchange it.\n\n\nTo find out if you have the key material, you can run:\n\n\n$ vagrant-spk ssh\n$ spk listkeys -k ~/.sandstorm/sandstorm-keyring\n\n\n\n\nYou should see the app ID in the output.\n\n\nIf you want to change the app ID before publishing the app, you\ncan run:\n\n\n$ vagrant-spk ssh\n$ spk keygen -k ~/.sandstorm/sandstorm-keyring\n\n\n\n\nIt will output a line like:\n\n\n9qvtkns7m215pfc12jeyuunfj0wr5m6rwktw61vatdz22uva0qmh\n\n\n\n\nwhich you can copy \n paste into the \nid = ...\n line of\n\nsandstorm-pkgdef.capnp\n.\n\n\nTechnical notes:\n \nvagrant-spk\n enables the above workflow because\n\n~/.sandstorm\n is shared into the Vagrant VM, so all keys are\navailable from all packaging VMs. Note that \nvagrant-spk\n is optional;\nif you are using the raw \nspk\n packaging tool, note that you may have\nstored keys in \n~/.sandstorm-keyring\n instead of\n\n~/.sandstorm/sandstorm-keyring\n.  This key is an\n\nEd25519\n key.\n\n\nVerify your identity\n\n\nThe next step is to prove that \nyou\n own the app ID, so that the\n\nSandstorm app market\n can confidently\nlist your contact details on your app's listing page.\n\n\nThe process is that you will:\n\n\n\n\n\n\nCreate a standardized text file of the form: \nI am the author of the Sandstorm.io app with the following ID: \napp-id\n.\n\n\n\n\n\n\nUse GPG to digitally sign the text.\n\n\n\n\n\n\nUse Keybase.io to confirm a link between your GPG identity and your\n  Twitter, GitHub, personal website, or other social identities.\n\n\n\n\n\n\nSandstorm uses the \napp ID key\n to permit updates to the next\nversion of the app, and the app ID key is required.\n\n\nThe GPG and Keybase integration affects how your name is presented\nwhen Sandstorm users try to find out who published the app. It is\noptional but highly recommended.\n\n\nSign up with \nKeybase.io\n\n\nCurrently, Keybase is invite-only. If you need an invite, you can\ncontact \ncommunity@sandstorm.io\n. You\nshould connect some of your public identites with your Keybase\naccount, like Twitter and GitHub.\n\n\nSandstorm app authors are verified using a PGP key linked to\nKeybase. You should get the\n\nprerequisites\n\nand follow \ntheir\ndirections\n to get\ntheir software set up.\n\n\nLink your Sandstorm package with your Keybase key\n\n\nIn order to verify that you are the author of the app in question, you need to sign the following ASCII statement: \nI am the author of the Sandstorm.io app with the following ID: \napp-id\n, where \napp-id\n is the one from your \nsandstorm-pkgdef.capnp\n file.\n\n\nTo generate a pgp-signature file using gpg, run a command like this:\n\n\necho -n \"I am the author of the Sandstorm.io app with the following ID: \napp-id\n\" |\n     gpg --sign \n pgp-signature\n\n\nIf you do it correctly, \ncat pgp-signature | gpg\n should print out the statement that you signed.\n\n\nExport your public key\n\n\nTo verify your signature, you also need to export your public key and include it in your app package. You can run the following command, where \nkey-id\n is a PGP key ID or a username associated with the key:\n\n\ngpg --export \nkey-id\n --export-options export-minimal \n pgp-keyring\n\n\nAdd required metadata\n\n\nYour app's manifest, or package definition file, (\nsandstorm-pkgdef.capnp\n) contains all of the metadata to list it in the app store, including descriptions, screenshots, categories, and more. You can look at \nEtherpad's manifest\n for an example of how the data is formatted, and the most current version of the file which defines acceptable fields and values for package definition files can be found \nhere\n. You can see Etherpad's app store listing \nhere\n.\n\n\nMetadata guide\n\n\nicons\n\n\nYou can embed both SVGs or PNGs, and Sandstorm will use the best version provided for the use in question. Using PNGs requires a slightly different structure, which you can find an example of \nhere\n.\n\n\n\n\nThe \nappGrid\n icon represents your app on the \"New\" screen on Sandstorm. It should be 128 x 128 pixels, and no larger than 64 KB.\n\n\nThe \ngrain\n icon represents individual grains on both the navbar and the grain list. It should be 24 x 24 pixels, and no larger than 4 KB. If you omit this, the appGrid icon will be used.\n\n\nThe \nmarket\n icon is used in the app market. It should be 150 x 150 pixels, and no larger than 256 KB. If you omit this, the appGrid icon will be used.\n\n\nThe \nmarketBig\n icon is used on an app's specific page on the app market. It should be 300 x 300 pixels, and no larger than 256 KB. If you omit this, the market icon will be used (raster images may look bad).\n\n\n\n\nwebsite\n\n\nThis should be the app's main website URL.\n\n\ncodeUrl\n\n\nThis should be the URL of the app's source code repository, like GitHub. It is recommended if there is a repository specific to the Sandstorm package, you utilize that one, rather than the upstream one. This field is mandatory if you utilize a license that requires redistributing code, like the GPL, but is optional otherwise.\n\n\nlicense\n\n\nThis is how you will specify the license under which you are distributing the app. The default is \nnone\n, which conveys no rights of redistribution to the user.\n\n\nCurrently, the following open source licenses are recognized: \nmit\n, \napache2\n, \ngpl3\n, \nagpl3\n, \nbsd3Clause\n, \nbsd2Clause\n, \ngpl2\n, \nlgpl2\n, \nlgpl3\n, \nisc\n, \nartistic2\n, \npython2\n, \nphp3\n, \nmpl2\n, \ncddl\n, \nepl\n, and \ncpal\n. If you need to add an additional license, you can open an issue or submit a pull request.\n\n\nYou can select \nopenSource\n and specify an OSI-approved license, or select \nproprietary\n and embed the full text of the license. If you choose a proprietary license, which may contain more restrictive permissions, Sandstorm will display the license to the user and have them accept it before they are able to use the app. If your app does not contain more restrictive permissions, you may consider releasing under \nnone\n to avoid this. Finally, \npublicDomain\n is also available, but it is preferable to use a permissive open source license instead.\n\n\nYou may also need to include \nnotices\n if your app is required to display any third-party copyright notices, for example due to use of third-party open source libraries.\n\n\ncategories\n\n\nYou may select the market categories to which your app belongs. You may select multiple, but you may be asked to make changes if the market moderators feel they are inappropriate.\n\n\nCurrently, the following categories are accepted:\n\n\n\n\nproductivity\n is for apps you use to get organized, not the apps you use to produce content. (Examples: Note-taking apps, kanban boards, project management.)\n\n\ncommunications\n is for apps you use to directly communicate with others. (Examples: Chat apps, email apps.)\n\n\nsocial\n is for apps used for social networking, where content is shared and networks of people are managed.\n\n\nwebPublishing\n is for apps used for publishing websites and blogs.\n\n\noffice\n is for apps which are tools commonly used for office. (Examples: Word processors, spreadsheets, presentation apps.)\n\n\ndeveloperTools\n is for apps which are tools for software development. (Examples: Source control, test automation, compilers, IDEs.)\n\n\nscience\n is for apps used for scientific and academic pursuits. (Examples: Data gathering, data processing, paper publishing.)\n\n\ngraphics\n is for apps used to create graphics and artwork.\n\n\nmedia\n is for apps used to consume media such as music, movies, and photos.\n\n\ngames\n is for apps that let you play games by yourself or with others.\n\n\nother\n is for apps which fit into no other category. But you may wish to suggest we add a category if none currently applies.\n\n\n\n\nauthor\n\n\nThe author can be an individual, organization, or even a pseudo-identity representing the app. In order for users to be able to verify the author of a package, the app author must also be identified by PGP key. The Sandstorm team recommends using keybase.io.\n\n\n\n\nThe \nupstreamAuthor\n is the name of the primary author of the original app. This indicates the author identified by the key ported the app, which was developed by someone else. If the original author is the one publishing the app, do not include this.\n\n\nThe \ncontactEmail\n is the address to contact for any issues with this app. This both includes administrative issues with the app market listing as well as end user support requests. It is very important that this email be monitored.\n\n\nThe \npgpSignature\n field is where you embed a signed ASCII statement verifying that you are the author of this app package.\n\n\n\n\npgpKeyring\n\n\nThis is where you embed a keyring in GPG keyring format containing the public key needed to verify your signature.\n\n\ndescription\n\n\nYou should embed a description of your app in GitHub-flavored Markdown. It may not contain HTML or image tags, as you can attach screenshots separately.\n\n\nshortDescription\n\n\nInclude two or three words here that briefly characterize your app. This is shown in the app card to people as they browse the market, and can communicate what type of app it is, like a \"document editor\" or a \"media player\".\n\n\nscreenshots\n\n\nYou can attach a number of screenshots here. You should specify the height and width of the picture here in pixels. You may embed PNGs or JPGs here. Your total metadata should be less than 1 MB in size, so be sure to use JPGs on photo-like screenshots.\n\n\nchangeLog\n\n\nHere you may embed a log of changes in GitHub-flavored Markdown. It is recommended to format this with a H1 heading for each release followed by a bullet list of changes. As an example, you can look at Etherpad's changelog \nhere\n.\n\n\nCheck your work\n\n\nConsider working through the \napp testing\nguide\n and/or\nemailing your app to the \nsandstorm-dev email\ngroup\n.\n\n\nYou can run \nspk verify mypackage.spk\n on your app package to see the details of your metadata. Ensure everything looks like it is supposed to before you publish your app.\n\n\nSend to the Sandstorm App Market\n\n\nIn order to submit your app to the market, you need to run one of the following commands, depending on your build tool: \nspk publish mypackage.spk\n or \nvagrant-spk publish mypackage.spk\n.\n\n\nIt will then go into the queue for us to review. We'll check that everything looks right. If it does, we'll publish the app, otherwise we'll email you to let you know what needs fixing.", 
            "title": "App publishing guide"
        }, 
        {
            "location": "/developing/publishing-apps/#app-publishing-guide", 
            "text": "After you've completed developing and testing your app's package for Sandstorm, you can publish it in the  Sandstorm App Market .", 
            "title": "App publishing guide"
        }, 
        {
            "location": "/developing/publishing-apps/#get-feedback-on-your-app", 
            "text": "Before publishing an app to the Sandstorm app market, we recommend you\nemail the  Sandstorm development email\nlist  with a\nlink to your package, to get feedback. Consider creating a FileDrop \ngrain containing your SPK file.  The  app testing guide  provides\nsome guidelines for what to look for while testing.", 
            "title": "Get feedback on your app"
        }, 
        {
            "location": "/developing/publishing-apps/#double-check-your-app-id", 
            "text": "Sandstorm identifies every app by a  public\nkey  authorized to sign updates for that\napp. The public key corresponds to a  private key  stored on your\ncomputer in  ~/.sandstorm/sandstorm-keyring .  You can find the app ID for your app in your sandstorm-pkgdef.capnp . It will have a line like:    id =  vfnwptfn02ty21w715snyyczw0nqxkv3jvawcah10c6z7hj1hnu0 ,\n  # Your app ID is actually its public key. The private key was placed in\n  # your keyring. All updates must be signed with the same key.  It's  essential  that you control this key! If you think someone\nelse might have the key material for your app, now is a good time to\nchange it.  To find out if you have the key material, you can run:  $ vagrant-spk ssh\n$ spk listkeys -k ~/.sandstorm/sandstorm-keyring  You should see the app ID in the output.  If you want to change the app ID before publishing the app, you\ncan run:  $ vagrant-spk ssh\n$ spk keygen -k ~/.sandstorm/sandstorm-keyring  It will output a line like:  9qvtkns7m215pfc12jeyuunfj0wr5m6rwktw61vatdz22uva0qmh  which you can copy   paste into the  id = ...  line of sandstorm-pkgdef.capnp .  Technical notes:   vagrant-spk  enables the above workflow because ~/.sandstorm  is shared into the Vagrant VM, so all keys are\navailable from all packaging VMs. Note that  vagrant-spk  is optional;\nif you are using the raw  spk  packaging tool, note that you may have\nstored keys in  ~/.sandstorm-keyring  instead of ~/.sandstorm/sandstorm-keyring .  This key is an Ed25519  key.", 
            "title": "Double-check your app ID"
        }, 
        {
            "location": "/developing/publishing-apps/#verify-your-identity", 
            "text": "The next step is to prove that  you  own the app ID, so that the Sandstorm app market  can confidently\nlist your contact details on your app's listing page.  The process is that you will:    Create a standardized text file of the form:  I am the author of the Sandstorm.io app with the following ID:  app-id .    Use GPG to digitally sign the text.    Use Keybase.io to confirm a link between your GPG identity and your\n  Twitter, GitHub, personal website, or other social identities.    Sandstorm uses the  app ID key  to permit updates to the next\nversion of the app, and the app ID key is required.  The GPG and Keybase integration affects how your name is presented\nwhen Sandstorm users try to find out who published the app. It is\noptional but highly recommended.  Sign up with  Keybase.io  Currently, Keybase is invite-only. If you need an invite, you can\ncontact  community@sandstorm.io . You\nshould connect some of your public identites with your Keybase\naccount, like Twitter and GitHub.  Sandstorm app authors are verified using a PGP key linked to\nKeybase. You should get the prerequisites \nand follow  their\ndirections  to get\ntheir software set up.  Link your Sandstorm package with your Keybase key  In order to verify that you are the author of the app in question, you need to sign the following ASCII statement:  I am the author of the Sandstorm.io app with the following ID:  app-id , where  app-id  is the one from your  sandstorm-pkgdef.capnp  file.  To generate a pgp-signature file using gpg, run a command like this:  echo -n \"I am the author of the Sandstorm.io app with the following ID:  app-id \" |\n     gpg --sign   pgp-signature  If you do it correctly,  cat pgp-signature | gpg  should print out the statement that you signed.  Export your public key  To verify your signature, you also need to export your public key and include it in your app package. You can run the following command, where  key-id  is a PGP key ID or a username associated with the key:  gpg --export  key-id  --export-options export-minimal   pgp-keyring", 
            "title": "Verify your identity"
        }, 
        {
            "location": "/developing/publishing-apps/#add-required-metadata", 
            "text": "Your app's manifest, or package definition file, ( sandstorm-pkgdef.capnp ) contains all of the metadata to list it in the app store, including descriptions, screenshots, categories, and more. You can look at  Etherpad's manifest  for an example of how the data is formatted, and the most current version of the file which defines acceptable fields and values for package definition files can be found  here . You can see Etherpad's app store listing  here .  Metadata guide  icons  You can embed both SVGs or PNGs, and Sandstorm will use the best version provided for the use in question. Using PNGs requires a slightly different structure, which you can find an example of  here .   The  appGrid  icon represents your app on the \"New\" screen on Sandstorm. It should be 128 x 128 pixels, and no larger than 64 KB.  The  grain  icon represents individual grains on both the navbar and the grain list. It should be 24 x 24 pixels, and no larger than 4 KB. If you omit this, the appGrid icon will be used.  The  market  icon is used in the app market. It should be 150 x 150 pixels, and no larger than 256 KB. If you omit this, the appGrid icon will be used.  The  marketBig  icon is used on an app's specific page on the app market. It should be 300 x 300 pixels, and no larger than 256 KB. If you omit this, the market icon will be used (raster images may look bad).   website  This should be the app's main website URL.  codeUrl  This should be the URL of the app's source code repository, like GitHub. It is recommended if there is a repository specific to the Sandstorm package, you utilize that one, rather than the upstream one. This field is mandatory if you utilize a license that requires redistributing code, like the GPL, but is optional otherwise.  license  This is how you will specify the license under which you are distributing the app. The default is  none , which conveys no rights of redistribution to the user.  Currently, the following open source licenses are recognized:  mit ,  apache2 ,  gpl3 ,  agpl3 ,  bsd3Clause ,  bsd2Clause ,  gpl2 ,  lgpl2 ,  lgpl3 ,  isc ,  artistic2 ,  python2 ,  php3 ,  mpl2 ,  cddl ,  epl , and  cpal . If you need to add an additional license, you can open an issue or submit a pull request.  You can select  openSource  and specify an OSI-approved license, or select  proprietary  and embed the full text of the license. If you choose a proprietary license, which may contain more restrictive permissions, Sandstorm will display the license to the user and have them accept it before they are able to use the app. If your app does not contain more restrictive permissions, you may consider releasing under  none  to avoid this. Finally,  publicDomain  is also available, but it is preferable to use a permissive open source license instead.  You may also need to include  notices  if your app is required to display any third-party copyright notices, for example due to use of third-party open source libraries.  categories  You may select the market categories to which your app belongs. You may select multiple, but you may be asked to make changes if the market moderators feel they are inappropriate.  Currently, the following categories are accepted:   productivity  is for apps you use to get organized, not the apps you use to produce content. (Examples: Note-taking apps, kanban boards, project management.)  communications  is for apps you use to directly communicate with others. (Examples: Chat apps, email apps.)  social  is for apps used for social networking, where content is shared and networks of people are managed.  webPublishing  is for apps used for publishing websites and blogs.  office  is for apps which are tools commonly used for office. (Examples: Word processors, spreadsheets, presentation apps.)  developerTools  is for apps which are tools for software development. (Examples: Source control, test automation, compilers, IDEs.)  science  is for apps used for scientific and academic pursuits. (Examples: Data gathering, data processing, paper publishing.)  graphics  is for apps used to create graphics and artwork.  media  is for apps used to consume media such as music, movies, and photos.  games  is for apps that let you play games by yourself or with others.  other  is for apps which fit into no other category. But you may wish to suggest we add a category if none currently applies.   author  The author can be an individual, organization, or even a pseudo-identity representing the app. In order for users to be able to verify the author of a package, the app author must also be identified by PGP key. The Sandstorm team recommends using keybase.io.   The  upstreamAuthor  is the name of the primary author of the original app. This indicates the author identified by the key ported the app, which was developed by someone else. If the original author is the one publishing the app, do not include this.  The  contactEmail  is the address to contact for any issues with this app. This both includes administrative issues with the app market listing as well as end user support requests. It is very important that this email be monitored.  The  pgpSignature  field is where you embed a signed ASCII statement verifying that you are the author of this app package.   pgpKeyring  This is where you embed a keyring in GPG keyring format containing the public key needed to verify your signature.  description  You should embed a description of your app in GitHub-flavored Markdown. It may not contain HTML or image tags, as you can attach screenshots separately.  shortDescription  Include two or three words here that briefly characterize your app. This is shown in the app card to people as they browse the market, and can communicate what type of app it is, like a \"document editor\" or a \"media player\".  screenshots  You can attach a number of screenshots here. You should specify the height and width of the picture here in pixels. You may embed PNGs or JPGs here. Your total metadata should be less than 1 MB in size, so be sure to use JPGs on photo-like screenshots.  changeLog  Here you may embed a log of changes in GitHub-flavored Markdown. It is recommended to format this with a H1 heading for each release followed by a bullet list of changes. As an example, you can look at Etherpad's changelog  here .", 
            "title": "Add required metadata"
        }, 
        {
            "location": "/developing/publishing-apps/#check-your-work", 
            "text": "Consider working through the  app testing\nguide  and/or\nemailing your app to the  sandstorm-dev email\ngroup .  You can run  spk verify mypackage.spk  on your app package to see the details of your metadata. Ensure everything looks like it is supposed to before you publish your app.", 
            "title": "Check your work"
        }, 
        {
            "location": "/developing/publishing-apps/#send-to-the-sandstorm-app-market", 
            "text": "In order to submit your app to the market, you need to run one of the following commands, depending on your build tool:  spk publish mypackage.spk  or  vagrant-spk publish mypackage.spk .  It will then go into the queue for us to review. We'll check that everything looks right. If it does, we'll publish the app, otherwise we'll email you to let you know what needs fixing.", 
            "title": "Send to the Sandstorm App Market"
        }, 
        {
            "location": "/developing/handbook/", 
            "text": "App Developer Handbook\n\n\nThis document provides a conceptual overview of Sandstorm along with a\nstyle guide for Sandstorm package maintainers.\n\n\nA great Sandstorm app:\n\n\n\n\nProvides a personal network service\n\n\nWorks immediately\n\n\nIs granular\n\n\nDoes \nnot\n implement user accounts or access control\n\n\nIs isolated\n\n\nIs maintained in Sandstorm by the community that develops it\n\n\n\n\nThis document explains the basic concepts of the Sandstorm platform by\nexample and introduces the goals of the platform. The purpose is to\nenable you, a person interested in making a web application run on\nSandstorm, understand the platform and provide the best experience\npossible. Before reading this document, we encourage you try\nSandstorm, perhaps by visiting https://demo.sandstorm.io/.\n\n\nThe platform is in alpha, so this document is likely to change. We\nwill keep old versions of this document online, and we hope that you\nwill watch this document over time to update your app as the platform\nupdates. There will eventually be API deprecations and\nbackwards-incompatible breakage, though we aim to keep that to a\nminimum.\n\n\nThis document serves as a conceptual overview but is not the\nauthoritative source of technical documentation. Within each section,\nwe typically link to more detailed documentation. Those detailed\ndocuments provide further context on how stable each API is.\n\n\nChange history\n\n\n\n\n2015-02-08: Some clarifications, particularly around access control.\n\n\n2015-02-06: Initial version.\n\n\n\n\nA great Sandstorm app\n\n\nThis section explains each brief bullet-point above in more depth.\n\n\nProvides a personal network service\n\n\nEvery Sandstorm app provides a service to the person who creates an\ninstance of it. It is initially available to the person who started\nthe instance. It is only available to people with whom the owner can\nshared the instance. By focusing on enabling personal computing on the\nweb, Sandstorm aims to enable people to get creative with small apps\ncreated for a single purpose, with security provided by the platform.\n\n\nTo provide some examples of the kinds of services an app might\nprovide:\n\n\n\n\n\n\nSome apps create the experience of an online editor for personal\n  documents, like spreadsheets or text documents. An example of this\n  is EtherCalc, a real-time collaborative spreadsheet.\n\n\n\n\n\n\nOther apps give the user the ability to produce and edit online\n  publications, such as blogs, photo galleries, or an informational\n  website. An example of this is GNU MediaGoblin, a media gallery\n  application.\n\n\n\n\n\n\nAn app might help you share data with other programs. For example,\n  the GitWeb creates a git repository you can clone from your laptop.\n\n\n\n\n\n\nA user might use a Sandstorm app for personal communication. An\n  example is email; right now, there are two email apps in the\n  Sandstorm app list, Roundcube and Mailpile.\n\n\n\n\n\n\nThese categories are just examples; there are surely other kinds of\napps that people will dream up.\n\n\nThe Sandstorm paradigm of app instances being primarily used by the\nperson who created the instance may require rethinking your app. For\nexample, the administration and editing interface of a blog is a great\nSandstorm app, and the person who creates the instance can share it\nwith others, allowing multiple people to edit the blog. Meanwhile,\nhowever, the \npublic\n view of the blog is a completely separate facet\nof the application accessed through different means. The public site\nmay simply be mapped to a domain separate from the Sandstorm shell,\nwhereas the edit interface is accessed exclusively within the\nSandstorm shell. (See more below on how apps can publish content to\nthe public web.)\n\n\nWorks immediately\n\n\nWhen the user creates a new instance of an app, the first screen the\nuser sees should empower the user to start using the software.\n\n\nTo enable this, the platform handles authentication so the app can\nautomatically log the user in; see below about that.\n\n\nA great example of an app working immediately is EtherCalc. When you\nenter a new instance of EtherCalc, you find yourself staring at the\nfamiliar grid of a spreadsheet. The interface acts as a prompt to can\nstart entering formulas and data. (\nTry it on the\ndemo\n.)\n\n\nAlthough we want users of every app to start using the app\nimmediately, some apps are not as familiar as a spreadsheet. For\nthose, the app should provide a clear visual hint as to how to start\nusing it. For example, with the gitweb port, we adjusted the home\nscreen so it tells you exactly how to start pushing to the repository\nit created. (\nTry it on the\ndemo\n.)\n\n\nA note about service dependencies: many web applications rely on a\nseparate database, for example. The Sandstorm approach is that each\napp package is responsible for making sure the app works, which could\nmean embedding these dependencies. This way, users of an app do not\nhave to think about the complexity of \"provisioning a database\" or\nsimilar issues, and a compromise of one instance of an app does not\nlead to other apps' data stores being compromised.\n\n\nIs granular\n\n\nUsers can always create multiple instances of an app; we call these\ninstances \"grains\".\n\n\nEach grain should refer to a discrete collection of data. For example,\none grain should contain one blog, or one spreadsheet, or one photo\nalbum. The grain has a unique URL which contains a grain ID (a random\nidentifier for the instance) intended to be unguessable.\n\n\nChoosing the right granularity is an editorial decision made by the\nperson porting the app.\n\n\nFor a document or spreadsheet editor, the answer is easy: a grain\nshould contain one document. It could be that for a media gallery\napplication, the best granularity is a photo album or a collection of\nphoto albums, rather than one photo itself. For a web-based image\neditor, the best granularity might be a single image. As a general\nrule of thumb, a grain should usually represent a \"unit of sharing\" --\nthe smallest item that a user may want to share independently of other\nitems. Choosing the finest granularity allows the app author to defer\nmore access control to Sandstorm's code and its user interface. At the\nextreme end, an app can choose to implement no access control at all,\nand the data can remain safely behind the grain URL and Sandstorm's\nother protections. For example, this is how the EtherCalc port works.\n\n\nDoes \nnot\n implement user accounts or access control\n\n\nWhen a user visits an instance of an app, the Sandstorm platform adds\na \nX-Sandstorm-User-Id\n header to the HTTP request. This header\ncontains a large hex string identifying the user, so that the app can\ntell when the same user visits again later.\n\n\nA second header, \nX-Sandstorm-Username\n, contains the user's \"display\nname\", suitable for identifying this user to other users (but this\nname can change over time). (Eventually, Sandstorm may also offer\nother user profile information, like a photo.)\n\n\nA third header, \nX-Sandstorm-Permissions\n, specifies the permissions\nthis user has on the particular app instance, such as \"read\" or\n\"write\". These permissions are set through the Sandstorm sharing UI,\noutside of the app itself, although the app defines what permissions\nare available in its package definition. (As of this writing, the\nsharing UI is still in development, but you can use permissions to\ndistinguish between the grain's owner vs. other users. Currently, the\nowner will always have all defined permissions, whereas other users\nwill have none, so you may simply define a permission called \nowner\n\nor \nadmin\n to distinguish.)\n\n\nWith these headers in hand, a Sandstorm app can and should avoid\nimplementing any internal user model. An app should not ask users to\nlog in and should not implement any notion of ACLs (access control\nlists) or other ways of assigning permissions internally.\n\n\nFor apps which were originally developed outside of Sandstorm where\nthey needed an internal notion of users, the app might already have a\n\"users\" table and lots of code built around this. That's OK! In this\ncase, under Sandstorm, the app should automatically do whatever\npreparatory work is required to log the user in, such as creating a\nnew row in that table. The app should examine\n\nX-Sandstorm-Permissions\n to detect the \"admin\" user, who should\nreceive full control over the data the app creates. You can see an\nexample of that in the Sandstorm plugin for GNU MediaGoblin. (See the\n\nsource\ncode\n.)\n\n\nA Sandstorm user can create a \nsharing link\n which grants access to\nthe grain to anyone with the link. For those with a security\nbackground, grain URLs are \ncapability\nURLs\n.\n\n\nA different user can visit the grain if the owner of the grain sends\nthem a sharing link. If the user is logged in to Sandstorm, the app\nwill see an \nX-Sandstorm-User-Id\n that it has not seen before. It\nshould typically create an account in its user model, whatever that\nmeans for the app, and automatically log the user into that account.\n\n\nWhen the sharing link was created, Sandstorm asked the user what\npermissions to grant to someone who visits a grain with the link.\nYour app needs to make its own decisions about what permission levels\nexist.  You can read the \nfull description\nhere\n.\n\n\nA totally logged-out user can also visit a sharing link. They should\nbe granted the same permission level as a logged-in user with the\nsame sharing link. In Sandstorm, logging in just means telling the server who\nyou are. Sharing links should work no matter who you are.\n\n\nFor those with a security background, the app enforces permissions but\ndoes not handle authorization (i.e. deciding which permissions to\ngrant) nor authentication. As an implementation detail, these headers\nare provided by the \nsandstorm-http-bridge\n tool. Apps can use a Cap'n\nProto interface instead of HTTP and run more efficiently; we will\ndocument that here later.\n\n\nIs isolated\n\n\nA large number of web applications can work properly without\ninteracting with other instances of the app and without access to the\nnetwork.  Some examples are document editors or media organizing\ntools. However, many apps do need network access to function.\n\n\nFor outbound network access for now, apps can request various specific\nnetwork protocols like HTTP and SMTP using a short-term hack called\n\nHackSessionContext\n. To learn about that, look at its \ncapnp\nfile\n. We're\nactively working on replacing this, but it will take a few\nmonths. We'll do our best to help you transition a package away from\n\nHackSessionContext\n when the time comes.\n\n\nFor inbound communication, see the discussion below on public API\nendpoints.\n\n\nIn the future, we plan to mediate this network access through\n\"drivers\" for each protocol. Rather than providing a raw interface for\nunderlying protocols like SMTP, we will provide a more abstract\nrepresentation that allows apps to get their work done very\nsimply. The drivers will respect object-capability discipline, which\nwe hope will make network code easier to write and also make it more\nsecure. The generic \nTCP/IP networking interface\ndefinition\n\nwill be part of how we implement more drivers.\n\n\nIn the future, when an app wishes to connect to another app or to an\nexternal resource through a driver, the app will make a \"powerbox\"\nrequest. The app essentially tells the platform: \"I need an endpoint\nwhich implements the XYZ API.\" Sandstorm itself will then display a\ndialog to the user which helps them choose which endpoint to use. The\nuser may choose another one of their apps on the same server, or may\nchoose to connect to external resources through a driver. Either way,\nthe requesting app will receive a Cap'n Proto object reference\nrepresenting the endpoint, with which they can then communicate. The\nplatform automatically arranges for the right permissions to be\ngranted on the endpoint the user chooses, so apps do not need to make\na separate \"permission\" request.\n\n\nIs maintained in Sandstorm by the community that develops it\n\n\nOver the course of 2014, volunteers and Sandstorm staff ported a\nnumber of existing open source web applications to Sandstorm to test\nout the platform, show that it can run a variety of software, and\nidentify changes we need to make to support a wide range of apps.\n\n\nIn the long run, we believe that the person/people maintaining the\nsoftware itself should maintain the Sandstorm port, too. (We sometimes\nrefer to the software's authors as the \"upstream\" author of the\nSandstorm port.) If you want to port something to Sandstorm, but\naren't part of the the main project's community yet, it's OK to go\nahead! Do it, and then tell both the upstream community and the\nSandstorm community about your work. You should join up with the\nbroader community so that the whole community around the project is\ninterested in the Sandstorm port being successful. We're very happy to\nhelp connect you with the upstream authors.\n\n\nPlatform features that enable publishing\n\n\nAs you have seen, the core of the Sandstorm platform is about how\npeople interact with applications they have installed. Many web\napplications exist to help people publish content for others, and this\nsection covers platform features that enable that.\n\n\nOur goals are:\n\n\n\n\n\n\nApps should be able to publish content for the world to see.\n\n\n\n\n\n\nApps should be able to take input from external services on the\n  Internet. Two example uses cases are (1) federated publishing\n  systems like the Pump protocol used by GNU MediaGoblin and (2) apps\n  that respond to external events, like a tool to update software\n  documentation based on a GitHub web hook.\n\n\n\n\n\n\nExternal people visiting this content should not be able to disturb\n  the app's functionality for the owner. Three classic ways that\n  external visitors disturb app functionality are cross-site request\n  forgery attacks, cross-site scripting attacks, and denial of\n  service. Sandstorm should enable app authors to rely on the platform\n  to protect them from these problems.\n\n\n\n\n\n\nExternal people visiting this content should preferably not be able\n  to disturb the content for other visitors. Two classic ways people\n  attempt to do this are denial of service and stored cross-site\n  scripting. Sandstorm should enable app authors to rely on the\n  platform to protect them from these problems, although there are\n  some limitations on how well the platform can protect against these\n  problems.\n\n\n\n\n\n\nApps can publish static HTML to the world\n\n\nMany web apps exist to help people publish websites that the world can\nsee. For example, Sandstorm has a number of blogging packages\navailable.\n\n\nThe key things to know here is that the app should write an HTML tree\nto /var/www, and then call \"publish static\" from the\n\"HackSessionContext\". You can \nread more\n.\n\n\nApps can expose an external API for authorized users\n\n\nSandstorm apps can export HTTP APIs for consumption by other servers\nor client apps, authorized using API keys. These API keys are bound to\na specific user, so when you receive a request via this API, the\nplatform has populated the \nX-Sandstorm-User-Id\n and related headers.\n\n\nYou can \nread more\n.\n\n\nApps can expose an external API for the world\n\n\nApps should be able to use external APIs so that non-Sandstorm users\ncan do dynamic things. For example, the static HTML view of a blog\nmight need an AJAX comments API. We are thinking through the best way\nto support this.\n\n\nPlatform security philosophy\n\n\nAs a Sandstorm app developer, it is worth understanding the general\nsecurity philosophy of the platform. They are:\n\n\n\n\n\n\nA goal of Sandstorm is to allow people to run arbitrarily-vulnerable\n  web applications safely.\n\n\n\n\n\n\nA Sandstorm user should be able to use software privately, without\n  third parties being able to discover what software the person uses\n  or leverage this knowledge to mount an attack.\n\n\n\n\n\n\nAn app knows who you are, just like a UNIX program knows the current\n  user ID.\n\n\n\n\n\n\nPermission to access a user's data is always explicit, never\n  implicit. A compromised app should only be able to read or destroy\n  the data it created or that the user explicitly authorized it to\n  access.\n\n\n\n\n\n\nSandstorm favors object capabilities as the unit of\n  authorization. You can \nread more about object\n  capabilities\n. We believe that\n  discrete object capabilities can improve both security and\n  usability.\n\n\n\n\n\n\nAccess to the network is always explicit, never implicit. A\n  compromised app should not be able to leak the user's data to a\n  third party. This will include browser-based protections as well as\n  backend protections. Only the administrator of a server will be able\n  to grant general network access; general network access exists so to\n  enable installing \"drivers\" to expose particular protocols (like\n  outbound email) for use by apps. The driver concept is still in\n  development. We hope that it simplifies app development and\n  deployment by automating configuration and allowing some security\n  decisions to be automatically made by the platform.\n\n\n\n\n\n\nSandstorm limits apps' access to the Linux platform to protect users\n  from malicious or vulnerable apps. For example, we don't support all\n  Linux system calls. Legitimate apps don't need all of them, and they\n  create a huge attack surface. Through syscall filtering, Sandstorm\n  apps have avoided being vulnerable to many \nreal Linux security\n  issues\n.\n\n\n\n\n\n\nWhen apps display information in a browser context, they have to use\n  our sandbox. This prevents the app from leaking its private data and\n  prevents other sites from attacking the app.\n\n\n\n\n\n\nPlatform protocol philosophy\n\n\nSandstorm is based on Cap'n Proto, a system for efficiently\ntransferring data and capabilities between programs. We focus on\ndesigning secure, convenient interfaces between applications first,\nand second on building compatibility bridges so that the existing base\nof web applications can work.\n\n\n\n\n\n\nWe are most excited about \"native\" Sandstorm applications. These use\n  pure Cap'n Proto to speak to Sandstorm, rather than relying on\n  text-based protocols like SMTP or HTTP. The advantage of native\n  Sandstorm applications is that they can run efficiently, quickly\n  take advantage of new platform features, and have native support for\n  sharing data with other apps via capabilities.\n\n\n\n\n\n\nWe will support apps that know nothing of the Sandstorm-specific\n  Cap'n Proto APIs. We call these \"legacy\" applications. One example\n  of a Sandstorm-developed tool for legacy app support is the\n  \nsandstorm-http-bridge\n, which enables apps that speak HTTP to\n  communicate with the Sandstorm supervisor. Each \"legacy\" app ported\n  to Sandstorm needs to bundle any legacy support tools inside its app\n  package.\n\n\n\n\n\n\nConclusions: how to learn more and get involved\n\n\nThanks for reading this far!\n\n\nSandstorm is currently in alpha, and we are continuously developing\nit, so some of these details may change. I hope this has been a useful\noverview of the platform and helps you understand the platform's\ngoals. I'm always eager for feedback; email me at\nasheesh@sandstorm.io. This handbook is very abbreviated; consider\nfollowing the links in each section for more detail.\n\n\nTo dig into the design of Sandstorm, read through the \nCap'n Proto\nprotocols that govern how it\ncommunicates\n.\n\n\nAs a developer or app packager, we hope Sandstorm lets you build and\nshare great web-based software. There is lots of great software out\nthere already, and if you port it to Sandstorm, you'll make it easier\nand safer for others to use. See the \n5 minute packaging\ntutorial\n for details.\n\n\nSome existing apps are not a 100% perfect fit for Sandstorm, but a\nport could make a huge difference in helping people use it\nconveniently and safely. For example, it is OK to disable some\nfeatures if the app still would be valuable to Sandstorm users. It's\nalso OK to create a \"monolithic\" port if you believe it would be\nuseful.\n\n\nPlease check out our \nGetting Involved\npage\n, or\nsend us an email at community@sandstorm.io!", 
            "title": "App Developer Handbook"
        }, 
        {
            "location": "/developing/handbook/#app-developer-handbook", 
            "text": "This document provides a conceptual overview of Sandstorm along with a\nstyle guide for Sandstorm package maintainers.  A great Sandstorm app:   Provides a personal network service  Works immediately  Is granular  Does  not  implement user accounts or access control  Is isolated  Is maintained in Sandstorm by the community that develops it   This document explains the basic concepts of the Sandstorm platform by\nexample and introduces the goals of the platform. The purpose is to\nenable you, a person interested in making a web application run on\nSandstorm, understand the platform and provide the best experience\npossible. Before reading this document, we encourage you try\nSandstorm, perhaps by visiting https://demo.sandstorm.io/.  The platform is in alpha, so this document is likely to change. We\nwill keep old versions of this document online, and we hope that you\nwill watch this document over time to update your app as the platform\nupdates. There will eventually be API deprecations and\nbackwards-incompatible breakage, though we aim to keep that to a\nminimum.  This document serves as a conceptual overview but is not the\nauthoritative source of technical documentation. Within each section,\nwe typically link to more detailed documentation. Those detailed\ndocuments provide further context on how stable each API is.", 
            "title": "App Developer Handbook"
        }, 
        {
            "location": "/developing/handbook/#change-history", 
            "text": "2015-02-08: Some clarifications, particularly around access control.  2015-02-06: Initial version.", 
            "title": "Change history"
        }, 
        {
            "location": "/developing/handbook/#a-great-sandstorm-app", 
            "text": "This section explains each brief bullet-point above in more depth.", 
            "title": "A great Sandstorm app"
        }, 
        {
            "location": "/developing/handbook/#provides-a-personal-network-service", 
            "text": "Every Sandstorm app provides a service to the person who creates an\ninstance of it. It is initially available to the person who started\nthe instance. It is only available to people with whom the owner can\nshared the instance. By focusing on enabling personal computing on the\nweb, Sandstorm aims to enable people to get creative with small apps\ncreated for a single purpose, with security provided by the platform.  To provide some examples of the kinds of services an app might\nprovide:    Some apps create the experience of an online editor for personal\n  documents, like spreadsheets or text documents. An example of this\n  is EtherCalc, a real-time collaborative spreadsheet.    Other apps give the user the ability to produce and edit online\n  publications, such as blogs, photo galleries, or an informational\n  website. An example of this is GNU MediaGoblin, a media gallery\n  application.    An app might help you share data with other programs. For example,\n  the GitWeb creates a git repository you can clone from your laptop.    A user might use a Sandstorm app for personal communication. An\n  example is email; right now, there are two email apps in the\n  Sandstorm app list, Roundcube and Mailpile.    These categories are just examples; there are surely other kinds of\napps that people will dream up.  The Sandstorm paradigm of app instances being primarily used by the\nperson who created the instance may require rethinking your app. For\nexample, the administration and editing interface of a blog is a great\nSandstorm app, and the person who creates the instance can share it\nwith others, allowing multiple people to edit the blog. Meanwhile,\nhowever, the  public  view of the blog is a completely separate facet\nof the application accessed through different means. The public site\nmay simply be mapped to a domain separate from the Sandstorm shell,\nwhereas the edit interface is accessed exclusively within the\nSandstorm shell. (See more below on how apps can publish content to\nthe public web.)", 
            "title": "Provides a personal network service"
        }, 
        {
            "location": "/developing/handbook/#works-immediately", 
            "text": "When the user creates a new instance of an app, the first screen the\nuser sees should empower the user to start using the software.  To enable this, the platform handles authentication so the app can\nautomatically log the user in; see below about that.  A great example of an app working immediately is EtherCalc. When you\nenter a new instance of EtherCalc, you find yourself staring at the\nfamiliar grid of a spreadsheet. The interface acts as a prompt to can\nstart entering formulas and data. ( Try it on the\ndemo .)  Although we want users of every app to start using the app\nimmediately, some apps are not as familiar as a spreadsheet. For\nthose, the app should provide a clear visual hint as to how to start\nusing it. For example, with the gitweb port, we adjusted the home\nscreen so it tells you exactly how to start pushing to the repository\nit created. ( Try it on the\ndemo .)  A note about service dependencies: many web applications rely on a\nseparate database, for example. The Sandstorm approach is that each\napp package is responsible for making sure the app works, which could\nmean embedding these dependencies. This way, users of an app do not\nhave to think about the complexity of \"provisioning a database\" or\nsimilar issues, and a compromise of one instance of an app does not\nlead to other apps' data stores being compromised.", 
            "title": "Works immediately"
        }, 
        {
            "location": "/developing/handbook/#is-granular", 
            "text": "Users can always create multiple instances of an app; we call these\ninstances \"grains\".  Each grain should refer to a discrete collection of data. For example,\none grain should contain one blog, or one spreadsheet, or one photo\nalbum. The grain has a unique URL which contains a grain ID (a random\nidentifier for the instance) intended to be unguessable.  Choosing the right granularity is an editorial decision made by the\nperson porting the app.  For a document or spreadsheet editor, the answer is easy: a grain\nshould contain one document. It could be that for a media gallery\napplication, the best granularity is a photo album or a collection of\nphoto albums, rather than one photo itself. For a web-based image\neditor, the best granularity might be a single image. As a general\nrule of thumb, a grain should usually represent a \"unit of sharing\" --\nthe smallest item that a user may want to share independently of other\nitems. Choosing the finest granularity allows the app author to defer\nmore access control to Sandstorm's code and its user interface. At the\nextreme end, an app can choose to implement no access control at all,\nand the data can remain safely behind the grain URL and Sandstorm's\nother protections. For example, this is how the EtherCalc port works.", 
            "title": "Is granular"
        }, 
        {
            "location": "/developing/handbook/#does-not-implement-user-accounts-or-access-control", 
            "text": "When a user visits an instance of an app, the Sandstorm platform adds\na  X-Sandstorm-User-Id  header to the HTTP request. This header\ncontains a large hex string identifying the user, so that the app can\ntell when the same user visits again later.  A second header,  X-Sandstorm-Username , contains the user's \"display\nname\", suitable for identifying this user to other users (but this\nname can change over time). (Eventually, Sandstorm may also offer\nother user profile information, like a photo.)  A third header,  X-Sandstorm-Permissions , specifies the permissions\nthis user has on the particular app instance, such as \"read\" or\n\"write\". These permissions are set through the Sandstorm sharing UI,\noutside of the app itself, although the app defines what permissions\nare available in its package definition. (As of this writing, the\nsharing UI is still in development, but you can use permissions to\ndistinguish between the grain's owner vs. other users. Currently, the\nowner will always have all defined permissions, whereas other users\nwill have none, so you may simply define a permission called  owner \nor  admin  to distinguish.)  With these headers in hand, a Sandstorm app can and should avoid\nimplementing any internal user model. An app should not ask users to\nlog in and should not implement any notion of ACLs (access control\nlists) or other ways of assigning permissions internally.  For apps which were originally developed outside of Sandstorm where\nthey needed an internal notion of users, the app might already have a\n\"users\" table and lots of code built around this. That's OK! In this\ncase, under Sandstorm, the app should automatically do whatever\npreparatory work is required to log the user in, such as creating a\nnew row in that table. The app should examine X-Sandstorm-Permissions  to detect the \"admin\" user, who should\nreceive full control over the data the app creates. You can see an\nexample of that in the Sandstorm plugin for GNU MediaGoblin. (See the source\ncode .)  A Sandstorm user can create a  sharing link  which grants access to\nthe grain to anyone with the link. For those with a security\nbackground, grain URLs are  capability\nURLs .  A different user can visit the grain if the owner of the grain sends\nthem a sharing link. If the user is logged in to Sandstorm, the app\nwill see an  X-Sandstorm-User-Id  that it has not seen before. It\nshould typically create an account in its user model, whatever that\nmeans for the app, and automatically log the user into that account.  When the sharing link was created, Sandstorm asked the user what\npermissions to grant to someone who visits a grain with the link.\nYour app needs to make its own decisions about what permission levels\nexist.  You can read the  full description\nhere .  A totally logged-out user can also visit a sharing link. They should\nbe granted the same permission level as a logged-in user with the\nsame sharing link. In Sandstorm, logging in just means telling the server who\nyou are. Sharing links should work no matter who you are.  For those with a security background, the app enforces permissions but\ndoes not handle authorization (i.e. deciding which permissions to\ngrant) nor authentication. As an implementation detail, these headers\nare provided by the  sandstorm-http-bridge  tool. Apps can use a Cap'n\nProto interface instead of HTTP and run more efficiently; we will\ndocument that here later.", 
            "title": "Does not implement user accounts or access control"
        }, 
        {
            "location": "/developing/handbook/#is-isolated", 
            "text": "A large number of web applications can work properly without\ninteracting with other instances of the app and without access to the\nnetwork.  Some examples are document editors or media organizing\ntools. However, many apps do need network access to function.  For outbound network access for now, apps can request various specific\nnetwork protocols like HTTP and SMTP using a short-term hack called HackSessionContext . To learn about that, look at its  capnp\nfile . We're\nactively working on replacing this, but it will take a few\nmonths. We'll do our best to help you transition a package away from HackSessionContext  when the time comes.  For inbound communication, see the discussion below on public API\nendpoints.  In the future, we plan to mediate this network access through\n\"drivers\" for each protocol. Rather than providing a raw interface for\nunderlying protocols like SMTP, we will provide a more abstract\nrepresentation that allows apps to get their work done very\nsimply. The drivers will respect object-capability discipline, which\nwe hope will make network code easier to write and also make it more\nsecure. The generic  TCP/IP networking interface\ndefinition \nwill be part of how we implement more drivers.  In the future, when an app wishes to connect to another app or to an\nexternal resource through a driver, the app will make a \"powerbox\"\nrequest. The app essentially tells the platform: \"I need an endpoint\nwhich implements the XYZ API.\" Sandstorm itself will then display a\ndialog to the user which helps them choose which endpoint to use. The\nuser may choose another one of their apps on the same server, or may\nchoose to connect to external resources through a driver. Either way,\nthe requesting app will receive a Cap'n Proto object reference\nrepresenting the endpoint, with which they can then communicate. The\nplatform automatically arranges for the right permissions to be\ngranted on the endpoint the user chooses, so apps do not need to make\na separate \"permission\" request.", 
            "title": "Is isolated"
        }, 
        {
            "location": "/developing/handbook/#is-maintained-in-sandstorm-by-the-community-that-develops-it", 
            "text": "Over the course of 2014, volunteers and Sandstorm staff ported a\nnumber of existing open source web applications to Sandstorm to test\nout the platform, show that it can run a variety of software, and\nidentify changes we need to make to support a wide range of apps.  In the long run, we believe that the person/people maintaining the\nsoftware itself should maintain the Sandstorm port, too. (We sometimes\nrefer to the software's authors as the \"upstream\" author of the\nSandstorm port.) If you want to port something to Sandstorm, but\naren't part of the the main project's community yet, it's OK to go\nahead! Do it, and then tell both the upstream community and the\nSandstorm community about your work. You should join up with the\nbroader community so that the whole community around the project is\ninterested in the Sandstorm port being successful. We're very happy to\nhelp connect you with the upstream authors.", 
            "title": "Is maintained in Sandstorm by the community that develops it"
        }, 
        {
            "location": "/developing/handbook/#platform-features-that-enable-publishing", 
            "text": "As you have seen, the core of the Sandstorm platform is about how\npeople interact with applications they have installed. Many web\napplications exist to help people publish content for others, and this\nsection covers platform features that enable that.  Our goals are:    Apps should be able to publish content for the world to see.    Apps should be able to take input from external services on the\n  Internet. Two example uses cases are (1) federated publishing\n  systems like the Pump protocol used by GNU MediaGoblin and (2) apps\n  that respond to external events, like a tool to update software\n  documentation based on a GitHub web hook.    External people visiting this content should not be able to disturb\n  the app's functionality for the owner. Three classic ways that\n  external visitors disturb app functionality are cross-site request\n  forgery attacks, cross-site scripting attacks, and denial of\n  service. Sandstorm should enable app authors to rely on the platform\n  to protect them from these problems.    External people visiting this content should preferably not be able\n  to disturb the content for other visitors. Two classic ways people\n  attempt to do this are denial of service and stored cross-site\n  scripting. Sandstorm should enable app authors to rely on the\n  platform to protect them from these problems, although there are\n  some limitations on how well the platform can protect against these\n  problems.", 
            "title": "Platform features that enable publishing"
        }, 
        {
            "location": "/developing/handbook/#apps-can-publish-static-html-to-the-world", 
            "text": "Many web apps exist to help people publish websites that the world can\nsee. For example, Sandstorm has a number of blogging packages\navailable.  The key things to know here is that the app should write an HTML tree\nto /var/www, and then call \"publish static\" from the\n\"HackSessionContext\". You can  read more .", 
            "title": "Apps can publish static HTML to the world"
        }, 
        {
            "location": "/developing/handbook/#apps-can-expose-an-external-api-for-authorized-users", 
            "text": "Sandstorm apps can export HTTP APIs for consumption by other servers\nor client apps, authorized using API keys. These API keys are bound to\na specific user, so when you receive a request via this API, the\nplatform has populated the  X-Sandstorm-User-Id  and related headers.  You can  read more .", 
            "title": "Apps can expose an external API for authorized users"
        }, 
        {
            "location": "/developing/handbook/#apps-can-expose-an-external-api-for-the-world", 
            "text": "Apps should be able to use external APIs so that non-Sandstorm users\ncan do dynamic things. For example, the static HTML view of a blog\nmight need an AJAX comments API. We are thinking through the best way\nto support this.", 
            "title": "Apps can expose an external API for the world"
        }, 
        {
            "location": "/developing/handbook/#platform-security-philosophy", 
            "text": "As a Sandstorm app developer, it is worth understanding the general\nsecurity philosophy of the platform. They are:    A goal of Sandstorm is to allow people to run arbitrarily-vulnerable\n  web applications safely.    A Sandstorm user should be able to use software privately, without\n  third parties being able to discover what software the person uses\n  or leverage this knowledge to mount an attack.    An app knows who you are, just like a UNIX program knows the current\n  user ID.    Permission to access a user's data is always explicit, never\n  implicit. A compromised app should only be able to read or destroy\n  the data it created or that the user explicitly authorized it to\n  access.    Sandstorm favors object capabilities as the unit of\n  authorization. You can  read more about object\n  capabilities . We believe that\n  discrete object capabilities can improve both security and\n  usability.    Access to the network is always explicit, never implicit. A\n  compromised app should not be able to leak the user's data to a\n  third party. This will include browser-based protections as well as\n  backend protections. Only the administrator of a server will be able\n  to grant general network access; general network access exists so to\n  enable installing \"drivers\" to expose particular protocols (like\n  outbound email) for use by apps. The driver concept is still in\n  development. We hope that it simplifies app development and\n  deployment by automating configuration and allowing some security\n  decisions to be automatically made by the platform.    Sandstorm limits apps' access to the Linux platform to protect users\n  from malicious or vulnerable apps. For example, we don't support all\n  Linux system calls. Legitimate apps don't need all of them, and they\n  create a huge attack surface. Through syscall filtering, Sandstorm\n  apps have avoided being vulnerable to many  real Linux security\n  issues .    When apps display information in a browser context, they have to use\n  our sandbox. This prevents the app from leaking its private data and\n  prevents other sites from attacking the app.", 
            "title": "Platform security philosophy"
        }, 
        {
            "location": "/developing/handbook/#platform-protocol-philosophy", 
            "text": "Sandstorm is based on Cap'n Proto, a system for efficiently\ntransferring data and capabilities between programs. We focus on\ndesigning secure, convenient interfaces between applications first,\nand second on building compatibility bridges so that the existing base\nof web applications can work.    We are most excited about \"native\" Sandstorm applications. These use\n  pure Cap'n Proto to speak to Sandstorm, rather than relying on\n  text-based protocols like SMTP or HTTP. The advantage of native\n  Sandstorm applications is that they can run efficiently, quickly\n  take advantage of new platform features, and have native support for\n  sharing data with other apps via capabilities.    We will support apps that know nothing of the Sandstorm-specific\n  Cap'n Proto APIs. We call these \"legacy\" applications. One example\n  of a Sandstorm-developed tool for legacy app support is the\n   sandstorm-http-bridge , which enables apps that speak HTTP to\n  communicate with the Sandstorm supervisor. Each \"legacy\" app ported\n  to Sandstorm needs to bundle any legacy support tools inside its app\n  package.", 
            "title": "Platform protocol philosophy"
        }, 
        {
            "location": "/developing/handbook/#conclusions-how-to-learn-more-and-get-involved", 
            "text": "Thanks for reading this far!  Sandstorm is currently in alpha, and we are continuously developing\nit, so some of these details may change. I hope this has been a useful\noverview of the platform and helps you understand the platform's\ngoals. I'm always eager for feedback; email me at\nasheesh@sandstorm.io. This handbook is very abbreviated; consider\nfollowing the links in each section for more detail.  To dig into the design of Sandstorm, read through the  Cap'n Proto\nprotocols that govern how it\ncommunicates .  As a developer or app packager, we hope Sandstorm lets you build and\nshare great web-based software. There is lots of great software out\nthere already, and if you port it to Sandstorm, you'll make it easier\nand safer for others to use. See the  5 minute packaging\ntutorial  for details.  Some existing apps are not a 100% perfect fit for Sandstorm, but a\nport could make a huge difference in helping people use it\nconveniently and safely. For example, it is OK to disable some\nfeatures if the app still would be valuable to Sandstorm users. It's\nalso OK to create a \"monolithic\" port if you believe it would be\nuseful.  Please check out our  Getting Involved\npage , or\nsend us an email at community@sandstorm.io!", 
            "title": "Conclusions: how to learn more and get involved"
        }, 
        {
            "location": "/developing/auth/", 
            "text": "A Sandstorm app delegates authentication to the Sandstorm\nplatform. This page explains how to identify human visitors to an app\nvia HTTP(S). For information on authenticating mobile apps, native\nclients, and other automated agents, see \nExporting HTTP\nAPIs\n.\n\n\nAbout sandstorm-http-bridge\n\n\nWhen a web app runs within Sandstorm, Sandstorm sanitizes all HTTP\nrequests. By default, it passes requests to your app via a tool called\n\nsandstorm-http-bridge\n. This results in a few interesting properties:\n\n\n\n\n\n\nSandstorm knows \nwhich user\n is making the request, so it can add\n  headers indicating the currently logged-in user's name\n  (\"authentication\").\n\n\n\n\n\n\nSandstorm knows \nwhich permissions the user has\n -- for example, it\n  knows if the user owns this grain -- so it can add headers\n  indicating what permissions the user has (\"authorization\").\n\n\n\n\n\n\nWhen your app receives HTTP requests, \nsandstorm-http-bridge\n has\n  normalized them. If a user's browser is speaking some non-compliant\n  dialect of HTTP, your app doesn't have to handle it.\n\n\n\n\n\n\nHeaders that an app receives\n\n\nPer the\n\ncurrent implementation\n\nof \nsandstorm-http-bridge\n, an app receives the following headers\nrelated to user identity and permissions:\n\n\n\n\n\n\nX-Sandstorm-Username\n: This is set to the user's full name, in\n  \npercent-encoded\n\n  UTF-8. For example, the username \n\"Kurt Friedrich G\u00f6del\"\n will\n  appear as \n\"Kurt%20Friedrich%20G%C3%B6del\"\n.  For anonymous users,\n  this header will simply contain \"Anonymous%20User\".\n\n\n\n\n\n\nX-Sandstorm-User-Id\n: If the user is logged in, this is set to the\n  user's current user ID, which is the first 128 bits of a\n  SHA-256. For example: \n0ba26e59c64ec75dedbc11679f267a40\n.  This\n  header is \nnot sent at all for anonymous users\n.\n\n\n\n\n\n\nX-Sandstorm-Permissions\n: This contains a list of the permissions\n  held by the current user. Permissions are defined in the package's\n  \nsandstorm-pkgdef.capnp\n. The grain's owner holds every permission\n  and can use the \"Share\" button to authorize other users.\n\n\n\n\n\n\nX-Sandstorm-Preferred-Handle\n: The user's preferred \"handle\". A\n  handle is like a Unix username. It contains only lower-case ASCII\n  letters, digits, and underscores, and it never starts with a digit.\n  The user can set their preferred handle in their account settings.\n  This handle is NOT UNIQUE; it is only a hint from the user. Apps\n  that use handles must decide for themselves whether they need\n  unique handles and, if so, implement some mechanism to deal with\n  duplicates (such as prompting the user to choose a different one,\n  or just appending some digits). Apps should strongly consider\n  using display names (\nX-Sandstorm-Username\n) instead of handles.\n  \nWARNING: A user can change their preferred handle at any time.\n  Two users can have the same preferred handle. The preferred handle\n  is just another form of display name. Do not use preferred handles\n  as primary keys or for security; use \nX-Sandstorm-User-Id\n\n  instead.\n\n\n\n\n\n\nX-Sandstorm-User-Picture\n: The URL of the user's profile picture.\n  The exact resolution of the picture is not specified, but assume\n  it is optimized for a 256x256 or smaller viewport (i.e. the actual\n  size is around 512x512 for high-DPI displays). Although profile\n  pictures are normally square, it is recommended to use CSS \nmax-width\n and\n  \nmax-height\n instead of \nwidth\n and \nheight\n in order to avoid\n  distorting a non-square picture. If this header is missing, the\n  user has no profile picture. In this case, it is recommended that\n  apps use \nidenticon.js\n,\n  with the user's ID (from \nX-Sandstorm-User-Id\n) as the input, to\n  produce identicons consistent with those that Sandstorm's own UI\n  would produce. Note that you should NOT hash the ID; just pass the\n  hex ID directly to the \nIdenticon\n constructor as the \nhash\n\n  argument.\n\n\n\n\n\n\nX-Sandstorm-User-Pronouns\n: Indicates by which pronouns the user\n  prefers to be referred. Possible values are \nneutral\n (English:\n  \"they\"), \nmale\n (English: \"he/him\"), \nfemale\n (English: \"she/her\"),\n  and \nrobot\n (English: \"it\"). If the header is not present, assume\n  \nneutral\n. The purpose of this header is to allow cleaner text in\n  user interfaces.\n\n\n\n\n\n\nApps operating without sandstorm-http-bridge\n\n\nIt is possible to write a Sandstorm app that does not use\n\nsandstorm-http-bridge\n! It can access authentication data by using\nthe Cap'n Proto raw Sandstorm API. We provide sample code for that in\nthe\n\nsandstorm-rawapi-example\n\nrepository on GitHub.\n\n\nFurther reading\n\n\nYou might be interested in looking at:\n\n\n\n\n\n\nA \nsandstorm-pkgdef.capnp\n\n  with no permissions defined.\n\n\n\n\n\n\nA \nsandstorm-pkgdef.capnp\n\n  with one permission defined.\n\n\n\n\n\n\nThe \nimplementation of\n  sandstorm-http-bridge\n.", 
            "title": "User authentication & permissions"
        }, 
        {
            "location": "/developing/auth/#about-sandstorm-http-bridge", 
            "text": "When a web app runs within Sandstorm, Sandstorm sanitizes all HTTP\nrequests. By default, it passes requests to your app via a tool called sandstorm-http-bridge . This results in a few interesting properties:    Sandstorm knows  which user  is making the request, so it can add\n  headers indicating the currently logged-in user's name\n  (\"authentication\").    Sandstorm knows  which permissions the user has  -- for example, it\n  knows if the user owns this grain -- so it can add headers\n  indicating what permissions the user has (\"authorization\").    When your app receives HTTP requests,  sandstorm-http-bridge  has\n  normalized them. If a user's browser is speaking some non-compliant\n  dialect of HTTP, your app doesn't have to handle it.    Headers that an app receives  Per the current implementation \nof  sandstorm-http-bridge , an app receives the following headers\nrelated to user identity and permissions:    X-Sandstorm-Username : This is set to the user's full name, in\n   percent-encoded \n  UTF-8. For example, the username  \"Kurt Friedrich G\u00f6del\"  will\n  appear as  \"Kurt%20Friedrich%20G%C3%B6del\" .  For anonymous users,\n  this header will simply contain \"Anonymous%20User\".    X-Sandstorm-User-Id : If the user is logged in, this is set to the\n  user's current user ID, which is the first 128 bits of a\n  SHA-256. For example:  0ba26e59c64ec75dedbc11679f267a40 .  This\n  header is  not sent at all for anonymous users .    X-Sandstorm-Permissions : This contains a list of the permissions\n  held by the current user. Permissions are defined in the package's\n   sandstorm-pkgdef.capnp . The grain's owner holds every permission\n  and can use the \"Share\" button to authorize other users.    X-Sandstorm-Preferred-Handle : The user's preferred \"handle\". A\n  handle is like a Unix username. It contains only lower-case ASCII\n  letters, digits, and underscores, and it never starts with a digit.\n  The user can set their preferred handle in their account settings.\n  This handle is NOT UNIQUE; it is only a hint from the user. Apps\n  that use handles must decide for themselves whether they need\n  unique handles and, if so, implement some mechanism to deal with\n  duplicates (such as prompting the user to choose a different one,\n  or just appending some digits). Apps should strongly consider\n  using display names ( X-Sandstorm-Username ) instead of handles.\n   WARNING: A user can change their preferred handle at any time.\n  Two users can have the same preferred handle. The preferred handle\n  is just another form of display name. Do not use preferred handles\n  as primary keys or for security; use  X-Sandstorm-User-Id \n  instead.    X-Sandstorm-User-Picture : The URL of the user's profile picture.\n  The exact resolution of the picture is not specified, but assume\n  it is optimized for a 256x256 or smaller viewport (i.e. the actual\n  size is around 512x512 for high-DPI displays). Although profile\n  pictures are normally square, it is recommended to use CSS  max-width  and\n   max-height  instead of  width  and  height  in order to avoid\n  distorting a non-square picture. If this header is missing, the\n  user has no profile picture. In this case, it is recommended that\n  apps use  identicon.js ,\n  with the user's ID (from  X-Sandstorm-User-Id ) as the input, to\n  produce identicons consistent with those that Sandstorm's own UI\n  would produce. Note that you should NOT hash the ID; just pass the\n  hex ID directly to the  Identicon  constructor as the  hash \n  argument.    X-Sandstorm-User-Pronouns : Indicates by which pronouns the user\n  prefers to be referred. Possible values are  neutral  (English:\n  \"they\"),  male  (English: \"he/him\"),  female  (English: \"she/her\"),\n  and  robot  (English: \"it\"). If the header is not present, assume\n   neutral . The purpose of this header is to allow cleaner text in\n  user interfaces.", 
            "title": "About sandstorm-http-bridge"
        }, 
        {
            "location": "/developing/auth/#apps-operating-without-sandstorm-http-bridge", 
            "text": "It is possible to write a Sandstorm app that does not use sandstorm-http-bridge ! It can access authentication data by using\nthe Cap'n Proto raw Sandstorm API. We provide sample code for that in\nthe sandstorm-rawapi-example \nrepository on GitHub.", 
            "title": "Apps operating without sandstorm-http-bridge"
        }, 
        {
            "location": "/developing/auth/#further-reading", 
            "text": "You might be interested in looking at:    A  sandstorm-pkgdef.capnp \n  with no permissions defined.    A  sandstorm-pkgdef.capnp \n  with one permission defined.    The  implementation of\n  sandstorm-http-bridge .", 
            "title": "Further reading"
        }, 
        {
            "location": "/developing/path/", 
            "text": "Sandstorm apps live at ephemeral URLs. This page documents the\ndetails.\n\n\nWeb URLs\n\n\nWhen a Sandstorm grain is running, Sandstorm uses a different URL for\neach session. This means even for a single grain, each different user\nvisiting the site will have a different base URL. There isn't a stable\nURL like \nhttps://myapp.me.sandcats.io/\n for an app to use.\n\n\nYour app might need to use these URLs for:\n\n\n\n\n\n\nRedirects\n: the app might need to generate redirects, for example\n  after a user POSTs some data.\n\n\n\n\n\n\nStatic assets\n: the app might have CSS, images, Javascript, or\n  other files that are required for a visitor to successfully load a\n  page.\n\n\n\n\n\n\nLinks within the app\n: If a user is on the home page (\n/\n) of an\n  app, and the app wants to create a \nhref=\n link to some other page,\n  it needs to know what string to place into the \na href\n tag.\n\n\n\n\n\n\nRecommendation: Use the empty string as your base path\n\n\nThe \neasiest\n way to handle Sandstorm's dynamic base path is to\nuse the empty string (\n''\n) as your app's base path. This way,\nthe app needs to make no decisions at runtime.\n\n\nMany web frameworks support this.\n\n\nIf you can't use the empty string, you can detect the base path at\nruntime for every request.\n\n\nAlternative: \nX-Sandstorm-Base-Path\n\n\nsandstorm-http-bridge\n provides the base URL for this particular\nrequest into the app as an HTTP header: \nX-Sandstorm-Base-Path\n.\n\n\nFor example, if the user requests the page\n\nhttp://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080/party\n,\nthe app will receive a header of:\n\n\nX-Sandstorm-Base-Path: http://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080\n\n\n\n\nDetails\n\n\n\n\n\n\nNo trailing slash.\n This way it is ready for you to add your own\n  path e.g. \n/party\n.\n\n\n\n\n\n\nIncludes the URI scheme.\n Therefore, if you need to check if the\n  request is coming in over HTTP vs. HTTPS, you can use this header.\n\n\n\n\n\n\nCan change with every request.\n Recall that this value is unsafe\n  to cache in a global settings object, since the next request to your\n  grain might use a different value.\n\n\n\n\n\n\nNot sent for API requests.\n All app \nAPI requests\n\n  share the same HTTP base domain, and this can't be used for HTML\n  sent to web browsers, so Sandstorm does not send this header on API\n  requests. Additionally, for sandboxing reasons, the API token is\n  kept secret from the app.\n\n\n\n\n\n\nOther headers available in Sandstorm\n\n\nSandstorm sends a \nHost:\n header and an \nX-Forwarded-Proto\n for\nconvenience when porting apps. A request to\n\nhttp://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080/party\n\nwould also cause an app to receive the following HTTP headers.\n\n\n\n\nHost: 7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080\n\n\nX-Forwarded-Proto: http\n\n\n\n\nIt is therefore OK to look for \nX-Forwarded-Proto: https\n to detect\nHTTPS if needed.\n\n\nFor API requests\n: \nsandstorm-http-bridge\n does send a \nHost\n value\nof \nsandbox\n since some apps crash in the absence of a host header. It\ndoes not send a \nX-Forwarded-Proto\n however.\n\n\nApps operating without sandstorm-http-bridge\n\n\nX-Sandstorm-Base-Path\n is created from the \nWebSession\n attribute\ncalled \nbasePath\n. Read the \ncurrent\nimplementation\n\nfor its Cap'n Proto documentation. Consider also reading the source of\n\nsandstorm-http-bridge\n.\n\n\nAppendix: Impact on caching\n\n\nThe fact that Sandstorm apps must send their static assets (such as\nCSS, Javascript, and images) on different URLs per session means that\na web browser can't make good use of its cache.\n\n\nThis can have a negative impact on app load time in Sandstorm and\nmobile data use when compared to other hosting options. The Cap'n\nProto definition of \nWebSession\n attribute indicates some possible\nfuture work in creating a shared space in Sandstorm that apps can push\nthese assets to.", 
            "title": "Paths and URLs"
        }, 
        {
            "location": "/developing/path/#web-urls", 
            "text": "When a Sandstorm grain is running, Sandstorm uses a different URL for\neach session. This means even for a single grain, each different user\nvisiting the site will have a different base URL. There isn't a stable\nURL like  https://myapp.me.sandcats.io/  for an app to use.  Your app might need to use these URLs for:    Redirects : the app might need to generate redirects, for example\n  after a user POSTs some data.    Static assets : the app might have CSS, images, Javascript, or\n  other files that are required for a visitor to successfully load a\n  page.    Links within the app : If a user is on the home page ( / ) of an\n  app, and the app wants to create a  href=  link to some other page,\n  it needs to know what string to place into the  a href  tag.    Recommendation: Use the empty string as your base path  The  easiest  way to handle Sandstorm's dynamic base path is to\nuse the empty string ( '' ) as your app's base path. This way,\nthe app needs to make no decisions at runtime.  Many web frameworks support this.  If you can't use the empty string, you can detect the base path at\nruntime for every request.  Alternative:  X-Sandstorm-Base-Path  sandstorm-http-bridge  provides the base URL for this particular\nrequest into the app as an HTTP header:  X-Sandstorm-Base-Path .  For example, if the user requests the page http://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080/party ,\nthe app will receive a header of:  X-Sandstorm-Base-Path: http://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080  Details    No trailing slash.  This way it is ready for you to add your own\n  path e.g.  /party .    Includes the URI scheme.  Therefore, if you need to check if the\n  request is coming in over HTTP vs. HTTPS, you can use this header.    Can change with every request.  Recall that this value is unsafe\n  to cache in a global settings object, since the next request to your\n  grain might use a different value.    Not sent for API requests.  All app  API requests \n  share the same HTTP base domain, and this can't be used for HTML\n  sent to web browsers, so Sandstorm does not send this header on API\n  requests. Additionally, for sandboxing reasons, the API token is\n  kept secret from the app.    Other headers available in Sandstorm  Sandstorm sends a  Host:  header and an  X-Forwarded-Proto  for\nconvenience when porting apps. A request to http://7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080/party \nwould also cause an app to receive the following HTTP headers.   Host: 7575abdec6caa44bb83df0e00d7d8605.me.sandcats.io:6080  X-Forwarded-Proto: http   It is therefore OK to look for  X-Forwarded-Proto: https  to detect\nHTTPS if needed.  For API requests :  sandstorm-http-bridge  does send a  Host  value\nof  sandbox  since some apps crash in the absence of a host header. It\ndoes not send a  X-Forwarded-Proto  however.", 
            "title": "Web URLs"
        }, 
        {
            "location": "/developing/path/#apps-operating-without-sandstorm-http-bridge", 
            "text": "X-Sandstorm-Base-Path  is created from the  WebSession  attribute\ncalled  basePath . Read the  current\nimplementation \nfor its Cap'n Proto documentation. Consider also reading the source of sandstorm-http-bridge .", 
            "title": "Apps operating without sandstorm-http-bridge"
        }, 
        {
            "location": "/developing/path/#appendix-impact-on-caching", 
            "text": "The fact that Sandstorm apps must send their static assets (such as\nCSS, Javascript, and images) on different URLs per session means that\na web browser can't make good use of its cache.  This can have a negative impact on app load time in Sandstorm and\nmobile data use when compared to other hosting options. The Cap'n\nProto definition of  WebSession  attribute indicates some possible\nfuture work in creating a shared space in Sandstorm that apps can push\nthese assets to.", 
            "title": "Appendix: Impact on caching"
        }, 
        {
            "location": "/vagrant-spk/customizing/", 
            "text": "Customizing and understanding vagrant-spk\n\n\nWhat the files are for\n\n\nvagrant-spk\n will create a \n.sandstorm/\n folder in your repo and set up some\nfiles with some defaults for your app stack.  You will likely need to modify\nsome of these to adapt their behavior to make the most sense for your app.\n\n\nglobal-setup.sh\n\n\nThis installs Sandstorm using the official installer script, enables developer\naccounts, and stops unneeded services on the VM.  It caches the Sandstorm\nbundle to speed up subsequent runs. You should not need to change this script.\n\n\nsetup.sh\n\n\nThis script runs when you set up the VM by \nvagrant-spk up\n the first time and\ndoes stack-specific setup, like installing tools or daemons needed to build and\nrun your app.  \nvagrant-spk\n provides some defaults based on commonly-used platform\nstacks, but you'll likely want to modify this script as suitable for your package.\n\n\nThis is the ideal place to \napt-get install\n system packages your app relies on,\nlike:\n\n\n\n\nlanguage runtimes (PHP, Node, Python, etc.)\n\n\ndatabase engines (MySQL, PostgreSQL, Redis, etc.)\n\n\nfrontend web servers (nginx, Apache)\n\n\n\n\nand so on.  Please note that this script is run only once for the lifetime of\nthe VM, and will not be run again when running \nvagrant-spk dev\n or starting a\ngrain.\n\n\nIf you make changes to this script, you should destroy your VM (\nvagrant-spk destroy\n)\nand rebuild it cleanly from scratch (\nvagrant-spk up\n) to make sure your\nchanges take effect and work as desired.\n\n\nIf you find yourself destroying and creating VMs from scratch frequently,\nconsider running an instance of \napt-cacher-ng\n on your host to speed up\npackage downloads.\n\n\nbuild.sh\n\n\nThis script runs each time you run \nvagrant-spk dev\n before exposing your app\nto the Sandstorm server, so you can run it in \"dev mode\".  Again, \nvagrant-spk\n\nprovides some defaults based on commonly-used patterns in the supported stacks,\nbut you'll likely need to modify this script to run your package's usual build\nflow, since packages use many different workflows and directory structures.\n\n\nThis is the ideal place to invoke anything which is normally part of \nyour app's\nbuild process\n: anything that you need to transform your project's source code\ninto a runnable deployment, but explicitly \nnot\n the project's deployment,\nconfiguration, or user data.\n\n\nUsually you put things here which should be run again as the result of changes\nto your project's source code.  Examples of things you might put here are:\n\n\n\n\nCompiling your project from source, for projects written in compiled languages.\n\n\nCalling \ncomposer\n to install or update PHP dependencies described in your app's \ncomposer.json\n\n\nCalling \npip\n to install your app's Python-specific dependencies from the \nrequirements.txt\n in your app's repository\n\n\nCalling \nnpm install\n to install or update npm dependencies from your app's \npackage.json\n\n\nCalling \nbower install\n to install or update web/css dependencies described in the app's \nbower.json\n\n\nCalling \ngulp\n to compile and minify SASS/LESS into CSS, or collect javascript into bundles\n\n\nMinifying dependencies\n\n\nCollecting various build artifacts or assets into a deployment-ready directory structure\n\n\n\n\nlauncher.sh\n\n\nThis script will be run every time an instance of your app - aka grain - starts\nin Sandstorm.  It is run inside the Sandstorm sandbox.  This script will be run\nboth when a grain first launches, and when a grain resumes after being\npreviously shut down.  This script is responsible for \nlaunching everything that\nyour app needs to run\n.  The thing it should do \nlast\n is:\n\n\n\n\nstart a process in the foreground listening on port 8000 for HTTP requests.\n\n\n\n\nFrequently this is something like \nnginx\n serving static files and reverse\nproxying for some other backend service.  You want to run this last because\naccepting requests on port 8000 is how you signal to the Sandstorm platform\nthat your application is completely up and ready for use.  If you do this\nbefore your backend is ready to go, users could get e.g. 502 errors or see a\nbroken page on first load - a poor first experience.\n\n\nOther things you probably want to do in this script include:\n\n\n\n\nBuilding folder structures in \n/var\n.  \n/var\n is the only non-tmpfs folder mounted R/W, and when a grain is first launched, it will start out empty.  It will persist between runs of the same grain, but be unique per app instance.\n\n\nPreparing a database and running migrations.  You can also manually generate some tables once, place them somewhere under \n/opt/app\n, and copy them to \n/var/lib/mysql\n if your app takes a while to do migrations, at the potential cost of producing a larger \n.spk\n.\n\n\nLaunching other daemons that your app uses (\nmysqld\n, \nredis-server\n, \nphp5-fpm\n, \nuwsgi\n, etc.)\n\n\n\n\nFor apps which need the ability to self-modify code or configuration, or which\nexpect to be able to write data underneath their source tree, you\nshould create a dangling symlink from\n\n/opt/app/where-your-app-keeps-its-self-modifiable-config.conf\n to somewhere\nunder \n/var\n, then copy or generate a default configuration to that symlink target under \n/var\n in\n\nlauncher.sh\n so your app will find it at runtime.\n\n\nThere's an example of this in the paperwork repository -\n\nbuild.sh\n\nremoves the folder \nfrontend/app/storage\n and replaces it with a symlink\npointing to \n/var/storage\n.  Then,\n\nlauncher.sh\n\nmakes sure that \n/var/storage\n exists and is populated with the appropriate\nsubdirectories.\n\n\nThese tend to be unique per-app, so again, \nvagrant-spk\n provides appropriate\ndefaults for common stacks, but you'll likely need to make adjustments for your\napp.\n\n\nsandstorm-files.list\n\n\nThis file is generated by running \nvagrant-spk dev\n and using the app.\nIt contains a list of all files that your app used at runtime.  This\nis used to construct a minimal package. See the \nraw packaging\nguide\n for details.\n\n\nIn the fullness of time, we'd like to support a method of generating\n\nsandstorm-files.list\n that doesn't require the developer to carefully\nuse every app feature to make sure that e.g. default plugins get\nincluded in the package.\n\n\nsandstorm-pkgdef.capnp\n\n\nSee \npackaging tutorial\n for details.\n\n\nVagrantfile\n\n\nSee \npackaging tutorial\n for details.\n\n\nExample setups\n\n\nDefault setup\n\n\nRepo: https://github.com/paulproteus/php-app-to-package-for-sandstorm\n\n\nThis example shows how to setup a php + mysql app.\n\n\nsetup.sh\n installs PHP, nginx, and MySQL from the distribution's repository,\nthen modifies default config files to support the \n/opt/app\n layout and run\nin the Sandstorm sandbox.\n\n\nbuild.sh\n installs/updates composer, and uses composer to install PHP\ndependencies.\n\n\nlauncher.sh\n creates a folder structure in \n/var\n for MySQL, nginx, and\nphp5-fpm, creates MySQL tables, then launches the three daemons, checking that\n\nmysqld\n and \nphp5-fpm\n are ready to accept requests before launching \nnginx\n,\nwhich will listen for requests on port 8000.\n\n\nPaperwork (php, mysql, composer, npm)\n\n\nRepo: https://github.com/JamborJan/paperwork\n\n\nsetup.sh\n\ninstalls PHP, nginx, nodejs, and npm.  Additionally, it installs some\nsystem-global tools (\ngulp\n and \nbower\n) with \nnpm\n.\n\n\nbuild.sh\n\ndoes several things: it installs and updates \ncomposer\n, installs app-specific\n\nnpm\n and \nbower\n dependencies from \npackage.json\n and \nbower.json\n manifests\nin the repo, and runs \ngulp\n to build static assets.\n\n\nlauncher.sh\n\ncreates the storage folders for notes in \n/var/storage\n, which the app will\nfind because \n/opt/app/frontend/app/storage\n (the standard storage location for\nPaperwork) is a symlink to \n/var/storage\n.  Additionally, the script sets up\nthe default database, grants permissions, and runs migrations.", 
            "title": "Understanding & customizing"
        }, 
        {
            "location": "/vagrant-spk/customizing/#customizing-and-understanding-vagrant-spk", 
            "text": "", 
            "title": "Customizing and understanding vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/customizing/#what-the-files-are-for", 
            "text": "vagrant-spk  will create a  .sandstorm/  folder in your repo and set up some\nfiles with some defaults for your app stack.  You will likely need to modify\nsome of these to adapt their behavior to make the most sense for your app.  global-setup.sh  This installs Sandstorm using the official installer script, enables developer\naccounts, and stops unneeded services on the VM.  It caches the Sandstorm\nbundle to speed up subsequent runs. You should not need to change this script.  setup.sh  This script runs when you set up the VM by  vagrant-spk up  the first time and\ndoes stack-specific setup, like installing tools or daemons needed to build and\nrun your app.   vagrant-spk  provides some defaults based on commonly-used platform\nstacks, but you'll likely want to modify this script as suitable for your package.  This is the ideal place to  apt-get install  system packages your app relies on,\nlike:   language runtimes (PHP, Node, Python, etc.)  database engines (MySQL, PostgreSQL, Redis, etc.)  frontend web servers (nginx, Apache)   and so on.  Please note that this script is run only once for the lifetime of\nthe VM, and will not be run again when running  vagrant-spk dev  or starting a\ngrain.  If you make changes to this script, you should destroy your VM ( vagrant-spk destroy )\nand rebuild it cleanly from scratch ( vagrant-spk up ) to make sure your\nchanges take effect and work as desired.  If you find yourself destroying and creating VMs from scratch frequently,\nconsider running an instance of  apt-cacher-ng  on your host to speed up\npackage downloads.  build.sh  This script runs each time you run  vagrant-spk dev  before exposing your app\nto the Sandstorm server, so you can run it in \"dev mode\".  Again,  vagrant-spk \nprovides some defaults based on commonly-used patterns in the supported stacks,\nbut you'll likely need to modify this script to run your package's usual build\nflow, since packages use many different workflows and directory structures.  This is the ideal place to invoke anything which is normally part of  your app's\nbuild process : anything that you need to transform your project's source code\ninto a runnable deployment, but explicitly  not  the project's deployment,\nconfiguration, or user data.  Usually you put things here which should be run again as the result of changes\nto your project's source code.  Examples of things you might put here are:   Compiling your project from source, for projects written in compiled languages.  Calling  composer  to install or update PHP dependencies described in your app's  composer.json  Calling  pip  to install your app's Python-specific dependencies from the  requirements.txt  in your app's repository  Calling  npm install  to install or update npm dependencies from your app's  package.json  Calling  bower install  to install or update web/css dependencies described in the app's  bower.json  Calling  gulp  to compile and minify SASS/LESS into CSS, or collect javascript into bundles  Minifying dependencies  Collecting various build artifacts or assets into a deployment-ready directory structure   launcher.sh  This script will be run every time an instance of your app - aka grain - starts\nin Sandstorm.  It is run inside the Sandstorm sandbox.  This script will be run\nboth when a grain first launches, and when a grain resumes after being\npreviously shut down.  This script is responsible for  launching everything that\nyour app needs to run .  The thing it should do  last  is:   start a process in the foreground listening on port 8000 for HTTP requests.   Frequently this is something like  nginx  serving static files and reverse\nproxying for some other backend service.  You want to run this last because\naccepting requests on port 8000 is how you signal to the Sandstorm platform\nthat your application is completely up and ready for use.  If you do this\nbefore your backend is ready to go, users could get e.g. 502 errors or see a\nbroken page on first load - a poor first experience.  Other things you probably want to do in this script include:   Building folder structures in  /var .   /var  is the only non-tmpfs folder mounted R/W, and when a grain is first launched, it will start out empty.  It will persist between runs of the same grain, but be unique per app instance.  Preparing a database and running migrations.  You can also manually generate some tables once, place them somewhere under  /opt/app , and copy them to  /var/lib/mysql  if your app takes a while to do migrations, at the potential cost of producing a larger  .spk .  Launching other daemons that your app uses ( mysqld ,  redis-server ,  php5-fpm ,  uwsgi , etc.)   For apps which need the ability to self-modify code or configuration, or which\nexpect to be able to write data underneath their source tree, you\nshould create a dangling symlink from /opt/app/where-your-app-keeps-its-self-modifiable-config.conf  to somewhere\nunder  /var , then copy or generate a default configuration to that symlink target under  /var  in launcher.sh  so your app will find it at runtime.  There's an example of this in the paperwork repository - build.sh \nremoves the folder  frontend/app/storage  and replaces it with a symlink\npointing to  /var/storage .  Then, launcher.sh \nmakes sure that  /var/storage  exists and is populated with the appropriate\nsubdirectories.  These tend to be unique per-app, so again,  vagrant-spk  provides appropriate\ndefaults for common stacks, but you'll likely need to make adjustments for your\napp.  sandstorm-files.list  This file is generated by running  vagrant-spk dev  and using the app.\nIt contains a list of all files that your app used at runtime.  This\nis used to construct a minimal package. See the  raw packaging\nguide  for details.  In the fullness of time, we'd like to support a method of generating sandstorm-files.list  that doesn't require the developer to carefully\nuse every app feature to make sure that e.g. default plugins get\nincluded in the package.  sandstorm-pkgdef.capnp  See  packaging tutorial  for details.  Vagrantfile  See  packaging tutorial  for details.", 
            "title": "What the files are for"
        }, 
        {
            "location": "/vagrant-spk/customizing/#example-setups", 
            "text": "Default setup  Repo: https://github.com/paulproteus/php-app-to-package-for-sandstorm  This example shows how to setup a php + mysql app.  setup.sh  installs PHP, nginx, and MySQL from the distribution's repository,\nthen modifies default config files to support the  /opt/app  layout and run\nin the Sandstorm sandbox.  build.sh  installs/updates composer, and uses composer to install PHP\ndependencies.  launcher.sh  creates a folder structure in  /var  for MySQL, nginx, and\nphp5-fpm, creates MySQL tables, then launches the three daemons, checking that mysqld  and  php5-fpm  are ready to accept requests before launching  nginx ,\nwhich will listen for requests on port 8000.  Paperwork (php, mysql, composer, npm)  Repo: https://github.com/JamborJan/paperwork  setup.sh \ninstalls PHP, nginx, nodejs, and npm.  Additionally, it installs some\nsystem-global tools ( gulp  and  bower ) with  npm .  build.sh \ndoes several things: it installs and updates  composer , installs app-specific npm  and  bower  dependencies from  package.json  and  bower.json  manifests\nin the repo, and runs  gulp  to build static assets.  launcher.sh \ncreates the storage folders for notes in  /var/storage , which the app will\nfind because  /opt/app/frontend/app/storage  (the standard storage location for\nPaperwork) is a symlink to  /var/storage .  Additionally, the script sets up\nthe default database, grants permissions, and runs migrations.", 
            "title": "Example setups"
        }, 
        {
            "location": "/vagrant-spk/platform-stacks/", 
            "text": "Platform stacks\n\n\nAbout platform stacks\n\n\nvagrant-spk\n includes support for a number of programming languages\nand/or web frameworks, each of which have different practices on how\nto go from the app's source code to a running web server.\n\n\nThe following stacks exist:\n\n\n\n\nlemp\n: a PHP-oriented software collection including nginx, MySQL, and PHP.\n\n\nmeteor\n: a stack for \nMeteor\n apps, including MongoDB.\n\n\nstatic\n: \nnginx\n configured to serve static files from \n/opt/app\n.\n\n\nuwsgi\n: a Python-oriented stack including nginx and uwsgi.\n\n\ndiy\n: Create your own.\n\n\n\n\nRunning this command:\n\n\nvagrant-spk setupvm platformname\n\n\n\n\nwill set up a Linux virtual machine (with Sandstorm installeed) ready to\nrun code in the platform called \nplatformname\n.\n\n\nThis page contains \nreference documentation\n you might use after\nhaving gone through the main \nvagrant-spk packaging\ntutorial\n.\n\n\nDIY platform stack\n\n\ndiy\n in this platform stack stands for do-it-yourself. It provides\njust the basic scripts, and requires you to fill in the\nvarious \n.sandstorm/\n scripts.\n\n\nThis platform stack is for you if you want to package an app for\nSandstorm with \nvagrant-spk\n where there is no platform stack for\nthe framework/library/platform the app was written against, or if\nyou want a minimal platform stack because you know what you're doing.\n\n\nSee \nCustomizing \n understanding vagrant-spk\n for\ndetails.\n\n\nMeteor platform stack\n\n\nFor a Meteor app, keep the following in mind:\n\n\n\n\nGet a copy of the app code wherever you like. Alternatively, run \nmeteor create --example todos\n\n\ncd\n into that directory.\n\n\nRun \nvagrant-spk setupvm meteor\n\n\nRun \nvagrant-spk up\n. Note this will print \nlots\n of red text; sorry about that, then abruptly end.\n\n\nRun \nvagrant-spk init\n and edit \n.sandstorm/sandstorm-pkgdef.capnp\n\n\nRun \nvagrant-spk dev\n and make sure the app works OK at http://local.sandstorm.io:6080/\n\n\nRun \nvagrant-spk pack ~/projects/meteor-package.spk\n and you have a package file!\n\n\n\n\nTroubleshooting\n\n\nIf the app fails at the \nvagrant-spk dev\n step due to a packaging\nerror, you may need to:\n\n\nmeteor remove-platform ios\nmeteor remove-platform android\n\n\n\n\nand then retry the \nvagrant-spk dev\n step.", 
            "title": "Platform stacks"
        }, 
        {
            "location": "/vagrant-spk/platform-stacks/#platform-stacks", 
            "text": "", 
            "title": "Platform stacks"
        }, 
        {
            "location": "/vagrant-spk/platform-stacks/#about-platform-stacks", 
            "text": "vagrant-spk  includes support for a number of programming languages\nand/or web frameworks, each of which have different practices on how\nto go from the app's source code to a running web server.  The following stacks exist:   lemp : a PHP-oriented software collection including nginx, MySQL, and PHP.  meteor : a stack for  Meteor  apps, including MongoDB.  static :  nginx  configured to serve static files from  /opt/app .  uwsgi : a Python-oriented stack including nginx and uwsgi.  diy : Create your own.   Running this command:  vagrant-spk setupvm platformname  will set up a Linux virtual machine (with Sandstorm installeed) ready to\nrun code in the platform called  platformname .  This page contains  reference documentation  you might use after\nhaving gone through the main  vagrant-spk packaging\ntutorial .", 
            "title": "About platform stacks"
        }, 
        {
            "location": "/vagrant-spk/platform-stacks/#diy-platform-stack", 
            "text": "diy  in this platform stack stands for do-it-yourself. It provides\njust the basic scripts, and requires you to fill in the\nvarious  .sandstorm/  scripts.  This platform stack is for you if you want to package an app for\nSandstorm with  vagrant-spk  where there is no platform stack for\nthe framework/library/platform the app was written against, or if\nyou want a minimal platform stack because you know what you're doing.  See  Customizing   understanding vagrant-spk  for\ndetails.", 
            "title": "DIY platform stack"
        }, 
        {
            "location": "/vagrant-spk/platform-stacks/#meteor-platform-stack", 
            "text": "For a Meteor app, keep the following in mind:   Get a copy of the app code wherever you like. Alternatively, run  meteor create --example todos  cd  into that directory.  Run  vagrant-spk setupvm meteor  Run  vagrant-spk up . Note this will print  lots  of red text; sorry about that, then abruptly end.  Run  vagrant-spk init  and edit  .sandstorm/sandstorm-pkgdef.capnp  Run  vagrant-spk dev  and make sure the app works OK at http://local.sandstorm.io:6080/  Run  vagrant-spk pack ~/projects/meteor-package.spk  and you have a package file!   Troubleshooting  If the app fails at the  vagrant-spk dev  step due to a packaging\nerror, you may need to:  meteor remove-platform ios\nmeteor remove-platform android  and then retry the  vagrant-spk dev  step.", 
            "title": "Meteor platform stack"
        }, 
        {
            "location": "/vagrant-spk/code-dependencies/", 
            "text": "Code dependencies\n\n\nMany web apps need access to libraries via language-specific package\nmanagers like \npip\n, \nnpm\n, and so on.\n\n\nSupported by the platform stack\n\n\nIf you are using a \"platform stack\" that has built-in support for\ndownloading dependencies, like the Meteor stack or the Python stack,\nthen you can expect \nvagrant-spk\n to handle downloading and installing\nthese dependencies for you. Specifically:\n\n\n\n\n\n\nThe \nuwsgi\n stack creates a virtualenv in the \nenv\n directory within\nthe app's code directory (\n/opt/app/env\n inside Vagrant) and, if a\n\nrequirements.txt\n is present, does `pip install -r requirements.txt'\ninto the virtualenv.\n\n\n\n\n\n\nThe \nmeteor\n stack uses the \nmeteor build\n process to create a\nMeteor bundle.\n\n\n\n\n\n\nThe \nlemp\n (PHP) stack looks for \ncomposer.json\n in the app\ndirectory and, if present, downloads and runs \ncomposer.phar\n\nto download the dependencies listed in \ncomposer.json\n.\n\n\n\n\n\n\nBeyond the platform stack\n\n\nIf you need to install extra Debian packages, such as PHP extensions\nor headers like \nlibxml2-dev\n, you can add commands to \nyour package's\nbuild.sh\n.\n\n\nIf you are creating your own platform stack, based on the DIY stack,\nyou will likely also need to customize \nbuild.sh\n.", 
            "title": "Code dependencies"
        }, 
        {
            "location": "/vagrant-spk/code-dependencies/#code-dependencies", 
            "text": "Many web apps need access to libraries via language-specific package\nmanagers like  pip ,  npm , and so on.", 
            "title": "Code dependencies"
        }, 
        {
            "location": "/vagrant-spk/code-dependencies/#supported-by-the-platform-stack", 
            "text": "If you are using a \"platform stack\" that has built-in support for\ndownloading dependencies, like the Meteor stack or the Python stack,\nthen you can expect  vagrant-spk  to handle downloading and installing\nthese dependencies for you. Specifically:    The  uwsgi  stack creates a virtualenv in the  env  directory within\nthe app's code directory ( /opt/app/env  inside Vagrant) and, if a requirements.txt  is present, does `pip install -r requirements.txt'\ninto the virtualenv.    The  meteor  stack uses the  meteor build  process to create a\nMeteor bundle.    The  lemp  (PHP) stack looks for  composer.json  in the app\ndirectory and, if present, downloads and runs  composer.phar \nto download the dependencies listed in  composer.json .", 
            "title": "Supported by the platform stack"
        }, 
        {
            "location": "/vagrant-spk/code-dependencies/#beyond-the-platform-stack", 
            "text": "If you need to install extra Debian packages, such as PHP extensions\nor headers like  libxml2-dev , you can add commands to  your package's\nbuild.sh .  If you are creating your own platform stack, based on the DIY stack,\nyou will likely also need to customize  build.sh .", 
            "title": "Beyond the platform stack"
        }, 
        {
            "location": "/vagrant-spk/services/", 
            "text": "Service dependencies\n\n\nMySQL\n\n\nIn \nvagrant-spk\n, on some platform stacks, MySQL is available by\ndefault. To connect use:\n\n\n\n\nUsername: root\n\n\nPassword: (empty string)\n\n\nHost: localhost\n\n\n\n\nSome apps insist on non-empty MySQL passwords, and some apps insist\nthat the database be created before the app starts. For those apps, consider\nadding the following to \nbuild.sh\n:\n\n\necho \nCREATE DATABASE IF NOT EXISTS app; GRANT ALL on app.* TO 'app'@'localhost' IDENTIFIED BY 'app';\n | mysql -uroot\n\n\n\n\nOnce you do that, you can use database \napp\n with username \napp\n and\npassword \napp\n on the host \nlocalhost\n.\n\n\nThe above applies to the following platform stacks:\n\n\n\n\nlemp (PHP)\n\n\nuwsgi (Python)\n\n\n\n\nRemoving MySQL support:\n If you have an app that does not need the\ndatabase, you can remove MySQL support from your package. To do that,\nlook in the \nlauncher.sh\n script and remove any line that refers to\n\nmysql\n (case-insensitive). Doing this will make grains launch faster.\nIt can also make the package smaller, so long as you re-generate\n\nsandstorm-files.list\n after removing MySQL invocations from\n\nlauncher.sh\n.\n\n\nOther services\n\n\nIf your app needs Redis, PostgreSQL, or any other service, you can\nsupport for it to your package. To do that, keep the following in\nmind.\n\n\n\n\n\n\nOne user ID.\n Sandstorm only provides a single user ID inside\nthe grain, so you need to adjust the init scripts and configuration\nfiles to use one user ID.\n\n\n\n\n\n\nCreate what you need in /var.\n Each Sandstorm grains runs with an\nempty, fresh \n/var\n at grain creation time, so you'll have to ensure\nthat any necessary directories or files are created in \nlauncher.sh\n.\n\n\n\n\n\n\nOne service per grain.\n Where possible, it's best to embed the\nservice into each app instance. If you are a large-scale system\nadministrator, this might sound strange. This approach has the\nadvantage that if one grain is insecure or malicious, no other data\nare compromised.\n\n\n\n\n\n\nFor details on how to configure this properly, consider using\n\nvagrant-spk\n to initialize a \nlemp\n virtual machine, and examine the\nscripts generated by that.", 
            "title": "Service dependencies"
        }, 
        {
            "location": "/vagrant-spk/services/#service-dependencies", 
            "text": "", 
            "title": "Service dependencies"
        }, 
        {
            "location": "/vagrant-spk/services/#mysql", 
            "text": "In  vagrant-spk , on some platform stacks, MySQL is available by\ndefault. To connect use:   Username: root  Password: (empty string)  Host: localhost   Some apps insist on non-empty MySQL passwords, and some apps insist\nthat the database be created before the app starts. For those apps, consider\nadding the following to  build.sh :  echo  CREATE DATABASE IF NOT EXISTS app; GRANT ALL on app.* TO 'app'@'localhost' IDENTIFIED BY 'app';  | mysql -uroot  Once you do that, you can use database  app  with username  app  and\npassword  app  on the host  localhost .  The above applies to the following platform stacks:   lemp (PHP)  uwsgi (Python)   Removing MySQL support:  If you have an app that does not need the\ndatabase, you can remove MySQL support from your package. To do that,\nlook in the  launcher.sh  script and remove any line that refers to mysql  (case-insensitive). Doing this will make grains launch faster.\nIt can also make the package smaller, so long as you re-generate sandstorm-files.list  after removing MySQL invocations from launcher.sh .", 
            "title": "MySQL"
        }, 
        {
            "location": "/vagrant-spk/services/#other-services", 
            "text": "If your app needs Redis, PostgreSQL, or any other service, you can\nsupport for it to your package. To do that, keep the following in\nmind.    One user ID.  Sandstorm only provides a single user ID inside\nthe grain, so you need to adjust the init scripts and configuration\nfiles to use one user ID.    Create what you need in /var.  Each Sandstorm grains runs with an\nempty, fresh  /var  at grain creation time, so you'll have to ensure\nthat any necessary directories or files are created in  launcher.sh .    One service per grain.  Where possible, it's best to embed the\nservice into each app instance. If you are a large-scale system\nadministrator, this might sound strange. This approach has the\nadvantage that if one grain is insecure or malicious, no other data\nare compromised.    For details on how to configure this properly, consider using vagrant-spk  to initialize a  lemp  virtual machine, and examine the\nscripts generated by that.", 
            "title": "Other services"
        }, 
        {
            "location": "/developing/web-publishing/", 
            "text": "A Sandstorm app can publish \nstatic web content\n to \nany domain\n\nof the user's choosing. This is useful for content management systems,\nblogging platforms, and other apps. This guide helps app authors use\nthat feature of the Sandstorm platform.\n\n\nOverview\n\n\nIn Sandstorm, an app can publish \nstatic HTML\n and other files in a\nway where Sandstorm will serve the content, rather than the app. This\nsaves on compute time and limits attack surface.\n\n\nYou can \ntry it\nnow\n\nwith this sample app (\nfull source\navailable\n).\n\n\nStore static files in \n/var/www\n. Each directory within \n/var/www\n\nshould contain a file called \nindex.html\n.\n\n\nThe grain can ask Sandstorm to enable publishing by requesting the\ncreation of a unique \npublicId\n. Once that's done, the files are\n\navailable on a special subdomain\n of the Sandstorm install. The\nsubdomain takes the form \npublicId.sandstorm.example.com\n.\n\n\nUsers can also \nmake the content available at any domain\n. To do\nthat, they need to configure \na CNAME record\n pointing at the\nSandstorm install; this is how their domain's DNS will resolve to the\nSandstorm server. The user also needs \na TXT record\n; this is how\nSandstorm determines what \npublicId\n this domain corresponds to.\n\n\nThis page explains how to generate a \npublicId\n and how to instruct a\nuser of your app to configure their DNS appropriately. This a\n\nprovisional API\n; see the note below about how we aim to make this\nmore usable and more secure.\n\n\nA helper program you can include, to enable publishing \n request a publicId\n\n\nThe simplest way to enable static publishing is to embed a small C++\nprogram with your app. The \nSample Static Publishing\nApp\n\nincludes that C++ code.\n\n\nTo include the C++ code in your app, copy \nthese\nfiles\n\ninto a directory of your app called \nsandstorm-integration\n.\n\n\nIf you are using \nvagrant-spk\n, also add the following to the end of your\n\n.sandstorm/setup.sh\n:\n\n\n### Download \n compile capnproto and the Sandstorm getPublicId helper.\n\n# First, get capnproto from master and install it to\n# /usr/local/bin. This requires a C++ compiler. We opt for clang\n# because that's what Sandstorm is typically compiled with.\nif [ ! -e /usr/local/bin/capnp ] ; then\n    sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -q clang autoconf pkg-config libtool\n    cd /tmp\n    if [ ! -e capnproto ]; then git clone https://github.com/sandstorm-io/capnproto; fi\n    cd capnproto\n    git checkout master\n    cd c++\n    autoreconf -i\n    ./configure\n    make -j2\n    sudo make install\nfi\n\n# Second, compile the small C++ program within\n# /opt/app/sandstorm-integration.\nif [ ! -e /opt/app/sandstorm-integration/getPublicId ] ; then\n    pushd /opt/app/sandstorm-integration\n    make\nfi\n### All done.\n\n\n\n\nNow, run the improved \n.sandstorm/setup.sh\n script by doing:\n\n\ncd .sandstorm\nvagrant provision\ncd ..\n\n\n\n\nThis should result in a\n\n/opt/app/sandstorm-integration/bin/getPublicId\n binary showing up in\nyour directory tree. When you run it and provide the current\n\nX-Sandstorm-Session-Id\n header as a command-line parameter, it will\noutput a \npublicId\n (and other information, see below).\n\n\nIf you prefer to use your own build system, you can use the above as\ninspiration. If you prefer to call Sandstorm's RPC directly, keep\nreading.\n\n\nNote\n: At the time of writing, some vagrant-spk stacks crash if you\nrun \nvagrant provision\n a second time. We're \nworking on fixing\nthat.\n\n\nShow DNS instructions to the user\n\n\nYou should make sure the user knows how to configure their domain's\nCNAME record (to point at the Sandstorm install) and TXT record (to\ntell Sandstorm which grain the domain points at).\n\n\nYou can find sample text in the \nSandstorm sample app with static\npublishing\n. The essentials are:\n\n\n\n\n\n\nThe user can preview their site at the \nautoUrl\n link. The \nbin/getPublicId\n program\n  prints that as line #3 (\nlines[2]\n in 0-indexed programming languages).\n\n\n\n\n\n\nThe user should set their CNAME value to the host component of the\n  \nautoUrl\n, for example \npublicId.sandstorm.example.com\n. You can\n  calculate this host component of the URL by parsing the \nautoUrl\n.\n\n\n\n\n\n\nThe user should set up a TXT record at \nsandstorm-www.example.com\n\n  containing just the \npublicId\n. The \nbin/getPublicId\n program prints\n  that as line 1 (\nlines[0]\n in 0-indexed programming languages).\n\n\n\n\n\n\nUsing the Sandstorm Cap'n Proto APIs directly\n\n\nYou can access the Sandstorm \nHackSessionContext\n capability directly\nif you want more performance or prefer to use the Sandstorm APIs with\nno overhead.\n\n\nStart by obtaining a \nHackSessionContext\n capability.\n\n\nHackSessionContext\n\nis a \nCap'n Proto\n interface. You must obtain\nan instance of this capability. The way to do this depends on whether\nyour app uses \nsandstorm-http-bridge\n (check your\n\nsandstorm-pkgdef.capnp\n to find out).\n\n\nIf you are using the raw Cap'n Proto API without the HTTP Bridge, then\nthe \nSessionContext\n capability you receive as a parameter to the\n\nUiView.newSession()\n method can be cast to \nHackSessionContext\n.  *\nIf you are using \nsandstorm-http-bridge\n, you must open a Cap'n Proto\nconnection to \nunix:/tmp/sandstorm-api\n, which will give you a\n\nSandstormHttpBridge\n\ncapability. Call \ngetSessionContext()\n on that capability, using the\nID that sandstorm-http-bridge places in the \nX-Sandstorm-Session-Id\n\nheader, and cast the result to a \nHackSessionContext\n.\n\n\nNote that \nHackSessionContext\n is a temporary API. As described below,\nwe intend to replace this with a better API later.\n\n\nThen call \ngetPublicId()\n on the context.\n The first time you call\nthis, the grain (app instance) is assigned a \"public ID\", which is a\nrandom string that uniquely identifies the grain, but which differs\nfrom the \"private ID\" which appears in the grain's URL. The public ID\nis not a secret as it grants no authority over the grain, whereas\nanyone who knows the private ID has full control over the grain.\n\n\nThe method call returns the grain's public ID as well as the hostname\nat which the server is hosted.\n\n\nThen, instruct the user on how to set up DNS.\n\n\nThe user will need to set two DNS records:\n\n\nuser-host\n IN CNAME `\nautoUrl\n`\nsandstorm-www.\nuser-host\n IN TXT \npublic-id\n\n\n\n\nwhere:\n\n\n\n\nuser-host\n is the hostname at which the user wishes to publish their site.\n\n\nautoUrl\n is the \npublic-id\n plus the Sandstorm server hostname (as returned by \ngetPublicId()\n).\n\n\nserver-host\n is the hostname of the Sandstorm server (as returned by \ngetPublicId()\n).\n\n\n\n\nRaw API example\n\n\nSee the Hacker CMS app, which can be installed from the \napp\nlist\n or from \nsource\ncode\n.\n\n\nNote: Provisional API\n\n\nThe current Cap'n Proto RPC for web publishing is hacky and not\nintended to be the long-term solution. In the long term, users will be\nable to connect domains to their Sandstorm account and then grant them\nto apps as capabilities through the Powerbox UI. Since the Powerbox\nand persistent capabilities are not yet implemented -- much less the\nability to connect domains -- we are providing a hack so that\ndevelopers can get started on such apps now. The hack allows a user to\ndesignate a Sandstorm app to host their domain via a special TXT\nrecord.\n\n\nAlso, the use of a C++ binary that you must embed might not be the\nmost convenient way to expose the Cap'n Proto API. We're considering\ncreating a pure-frontend Javascript API like \noffer\ntemplates\n or a \npostMessage\n-based API, and/or a\nbackend API that is part of \nsandstorm-http-bridge\n. Let us know if\nyou have a preference for what you would like to use.\n\n\nWhy only static content?\n\n\nIn order to make per-user application instances cost-effective, a\nSandstorm application server normally only runs while a user has the\napplication open. This works very well for things like private\ndocuments which have only one or maybe a few users. A public web site,\nhowever, is intended to be viewed widely and at all hours of the\nday. If we had to spin up the application sever for every visit, we'd\nlose this key advantage.\n\n\nBy restricting web publishing to static content, we can avoid spinning\nup the application server for regular visits. Only editing the content\nrequires the server to be active.\n\n\nAs of this writing, there is no way to publish dynamic web sites to a\ncustom domain via Sandstorm. In the future, this will become possible\nvia the use of APIs. Once an application can export a public API, then\nit will be possible for \"static\" javascript published on a domain to\nmake calls to that API. Such calls will, of course, require spinning\nup the server to handle, but a well-written app may be able to avoid\nmaking API calls except under special circumstances (e.g. when a user\nclicks to post a comment).", 
            "title": "Web publishing"
        }, 
        {
            "location": "/developing/web-publishing/#overview", 
            "text": "In Sandstorm, an app can publish  static HTML  and other files in a\nway where Sandstorm will serve the content, rather than the app. This\nsaves on compute time and limits attack surface.  You can  try it\nnow \nwith this sample app ( full source\navailable ).  Store static files in  /var/www . Each directory within  /var/www \nshould contain a file called  index.html .  The grain can ask Sandstorm to enable publishing by requesting the\ncreation of a unique  publicId . Once that's done, the files are available on a special subdomain  of the Sandstorm install. The\nsubdomain takes the form  publicId.sandstorm.example.com .  Users can also  make the content available at any domain . To do\nthat, they need to configure  a CNAME record  pointing at the\nSandstorm install; this is how their domain's DNS will resolve to the\nSandstorm server. The user also needs  a TXT record ; this is how\nSandstorm determines what  publicId  this domain corresponds to.  This page explains how to generate a  publicId  and how to instruct a\nuser of your app to configure their DNS appropriately. This a provisional API ; see the note below about how we aim to make this\nmore usable and more secure.", 
            "title": "Overview"
        }, 
        {
            "location": "/developing/web-publishing/#a-helper-program-you-can-include-to-enable-publishing-request-a-publicid", 
            "text": "The simplest way to enable static publishing is to embed a small C++\nprogram with your app. The  Sample Static Publishing\nApp \nincludes that C++ code.  To include the C++ code in your app, copy  these\nfiles \ninto a directory of your app called  sandstorm-integration .  If you are using  vagrant-spk , also add the following to the end of your .sandstorm/setup.sh :  ### Download   compile capnproto and the Sandstorm getPublicId helper.\n\n# First, get capnproto from master and install it to\n# /usr/local/bin. This requires a C++ compiler. We opt for clang\n# because that's what Sandstorm is typically compiled with.\nif [ ! -e /usr/local/bin/capnp ] ; then\n    sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -q clang autoconf pkg-config libtool\n    cd /tmp\n    if [ ! -e capnproto ]; then git clone https://github.com/sandstorm-io/capnproto; fi\n    cd capnproto\n    git checkout master\n    cd c++\n    autoreconf -i\n    ./configure\n    make -j2\n    sudo make install\nfi\n\n# Second, compile the small C++ program within\n# /opt/app/sandstorm-integration.\nif [ ! -e /opt/app/sandstorm-integration/getPublicId ] ; then\n    pushd /opt/app/sandstorm-integration\n    make\nfi\n### All done.  Now, run the improved  .sandstorm/setup.sh  script by doing:  cd .sandstorm\nvagrant provision\ncd ..  This should result in a /opt/app/sandstorm-integration/bin/getPublicId  binary showing up in\nyour directory tree. When you run it and provide the current X-Sandstorm-Session-Id  header as a command-line parameter, it will\noutput a  publicId  (and other information, see below).  If you prefer to use your own build system, you can use the above as\ninspiration. If you prefer to call Sandstorm's RPC directly, keep\nreading.  Note : At the time of writing, some vagrant-spk stacks crash if you\nrun  vagrant provision  a second time. We're  working on fixing\nthat.", 
            "title": "A helper program you can include, to enable publishing &amp; request a publicId"
        }, 
        {
            "location": "/developing/web-publishing/#show-dns-instructions-to-the-user", 
            "text": "You should make sure the user knows how to configure their domain's\nCNAME record (to point at the Sandstorm install) and TXT record (to\ntell Sandstorm which grain the domain points at).  You can find sample text in the  Sandstorm sample app with static\npublishing . The essentials are:    The user can preview their site at the  autoUrl  link. The  bin/getPublicId  program\n  prints that as line #3 ( lines[2]  in 0-indexed programming languages).    The user should set their CNAME value to the host component of the\n   autoUrl , for example  publicId.sandstorm.example.com . You can\n  calculate this host component of the URL by parsing the  autoUrl .    The user should set up a TXT record at  sandstorm-www.example.com \n  containing just the  publicId . The  bin/getPublicId  program prints\n  that as line 1 ( lines[0]  in 0-indexed programming languages).", 
            "title": "Show DNS instructions to the user"
        }, 
        {
            "location": "/developing/web-publishing/#using-the-sandstorm-capn-proto-apis-directly", 
            "text": "You can access the Sandstorm  HackSessionContext  capability directly\nif you want more performance or prefer to use the Sandstorm APIs with\nno overhead.  Start by obtaining a  HackSessionContext  capability.  HackSessionContext \nis a  Cap'n Proto  interface. You must obtain\nan instance of this capability. The way to do this depends on whether\nyour app uses  sandstorm-http-bridge  (check your sandstorm-pkgdef.capnp  to find out).  If you are using the raw Cap'n Proto API without the HTTP Bridge, then\nthe  SessionContext  capability you receive as a parameter to the UiView.newSession()  method can be cast to  HackSessionContext .  *\nIf you are using  sandstorm-http-bridge , you must open a Cap'n Proto\nconnection to  unix:/tmp/sandstorm-api , which will give you a SandstormHttpBridge \ncapability. Call  getSessionContext()  on that capability, using the\nID that sandstorm-http-bridge places in the  X-Sandstorm-Session-Id \nheader, and cast the result to a  HackSessionContext .  Note that  HackSessionContext  is a temporary API. As described below,\nwe intend to replace this with a better API later.  Then call  getPublicId()  on the context.  The first time you call\nthis, the grain (app instance) is assigned a \"public ID\", which is a\nrandom string that uniquely identifies the grain, but which differs\nfrom the \"private ID\" which appears in the grain's URL. The public ID\nis not a secret as it grants no authority over the grain, whereas\nanyone who knows the private ID has full control over the grain.  The method call returns the grain's public ID as well as the hostname\nat which the server is hosted.  Then, instruct the user on how to set up DNS.  The user will need to set two DNS records:  user-host  IN CNAME ` autoUrl `\nsandstorm-www. user-host  IN TXT  public-id   where:   user-host  is the hostname at which the user wishes to publish their site.  autoUrl  is the  public-id  plus the Sandstorm server hostname (as returned by  getPublicId() ).  server-host  is the hostname of the Sandstorm server (as returned by  getPublicId() ).", 
            "title": "Using the Sandstorm Cap'n Proto APIs directly"
        }, 
        {
            "location": "/developing/web-publishing/#raw-api-example", 
            "text": "See the Hacker CMS app, which can be installed from the  app\nlist  or from  source\ncode .", 
            "title": "Raw API example"
        }, 
        {
            "location": "/developing/web-publishing/#note-provisional-api", 
            "text": "The current Cap'n Proto RPC for web publishing is hacky and not\nintended to be the long-term solution. In the long term, users will be\nable to connect domains to their Sandstorm account and then grant them\nto apps as capabilities through the Powerbox UI. Since the Powerbox\nand persistent capabilities are not yet implemented -- much less the\nability to connect domains -- we are providing a hack so that\ndevelopers can get started on such apps now. The hack allows a user to\ndesignate a Sandstorm app to host their domain via a special TXT\nrecord.  Also, the use of a C++ binary that you must embed might not be the\nmost convenient way to expose the Cap'n Proto API. We're considering\ncreating a pure-frontend Javascript API like  offer\ntemplates  or a  postMessage -based API, and/or a\nbackend API that is part of  sandstorm-http-bridge . Let us know if\nyou have a preference for what you would like to use.", 
            "title": "Note: Provisional API"
        }, 
        {
            "location": "/developing/web-publishing/#why-only-static-content", 
            "text": "In order to make per-user application instances cost-effective, a\nSandstorm application server normally only runs while a user has the\napplication open. This works very well for things like private\ndocuments which have only one or maybe a few users. A public web site,\nhowever, is intended to be viewed widely and at all hours of the\nday. If we had to spin up the application sever for every visit, we'd\nlose this key advantage.  By restricting web publishing to static content, we can avoid spinning\nup the application server for regular visits. Only editing the content\nrequires the server to be active.  As of this writing, there is no way to publish dynamic web sites to a\ncustom domain via Sandstorm. In the future, this will become possible\nvia the use of APIs. Once an application can export a public API, then\nit will be possible for \"static\" javascript published on a domain to\nmake calls to that API. Such calls will, of course, require spinning\nup the server to handle, but a well-written app may be able to avoid\nmaking API calls except under special circumstances (e.g. when a user\nclicks to post a comment).", 
            "title": "Why only static content?"
        }, 
        {
            "location": "/developing/http-apis/", 
            "text": "A Sandstorm app can export an HTTP-based API to the internet. This\npage explains how to support the following use-cases while relying on\nSandstorm for access control.\n\n\n\n\n\n\nAllowing a mobile client app to connect to a Sandstorm server.\n\n\n\n\n\n\nAllowing static web pages to interact with Sandstorm servers. (For\n  instance, this could be used to implement comments on a blog\n  published via \nSandstorm's web publishing\n --\n  posting a comment would make an API request.)\n\n\n\n\n\n\nFederation between servers.\n\n\n\n\n\n\nMany other things!\n\n\n\n\n\n\nOverview\n\n\nWhen custom code needs to interact with a Sandstorm app, it sends a\nHTTP request to the \nAPI hostname\n of the Sandstorm host where app\nis running, along with an \nAPI token\n embedded in an \nAuthorization\n\nHTTP header.\n\n\nYou can try making a request to a Sandstorm app's API right now via \ncurl\n:\n\n\ncurl -H \nAuthorization: Bearer 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9\n https://alpha-api.sandstorm.io/\n\n\n\n\nSandstorm is responsible for generating the API token. The API token\nis used for both \naccess control\n and \nrouting a request\n to the\nappropriate grain.\n\n\nWhen a request comes in with a valid API token, Sandstorm sanitizes\nthe request, removing the \nCookie\n header and the API token, adding\ntypical Sandstorm authentication headers like \nX-Sandstorm-User-Id\n,\nand passes the request to the app. Sandstorm combines it with the app\npackage's \nbridgeConfig.apiPath\n as part of sending the request to the\ngrain. Sandstorm sanitizes responses and removes any \nSet-Cookie\n\nresponse header.\n\n\nThe API endpoint is set up to allow \ncross-origin requests from any\norigin\n, which means you can access an API from \nXMLHttpRequest\n on\nany domain.\n\n\nAn app can \nrequest the generation of an API token\n, and a Sandstorm\nuser can manually create a valid API token by clicking on the Webkey icon\nin the Sandstorm shell.\n\n\nHow to generate an API token\n\n\nThere are various ways to obtain an API token:\n\n\n\n\n\n\nThe best is via \noffer templates\n, where the app specifies textual\n  information for the user of the app, and Sandstorm places the token\n  into this template before displaying it to the user.\n\n\n\n\n\n\nThe user can click the key icon in the top bar when they have an app\n  open.\n\n\n\n\n\n\nIn the future, we will implement an OAuth flow allowing a third party\nto initiate a request for access to the user's apps.\n\n\nSandstorm's \nHackSessionContext\n exports a Cap'n Proto RPC method\ncalled \nHackSessionContext.generateApiToken()\n. That method is\ndeprecated in favor of offer templates. If you need to use it, read\nthe \nweb publishing guide\n for more about how to\naccess \nHackSessionContext\n.\n\n\nCreating an offer template\n\n\nAn \noffer template\n is a way for Sandstorm to display an API token to\nthe user without the app being able to see the token.\n\n\nYou can see an example by launching \na GitWeb\ndemo\n.\n\n\nWe implement this as an \nIFRAME\n from the Sandstorm server. The grain\ncannot peek into the element. To fill the \nIFRAME\n with helpful information\nfor the user, including an API token, client-side Javascript in the grain\nprovides a template to Sandstorm, and Sandstorm responds with a URL that\nthe app can use as the \nSRC\n of the \nIFRAME\n.\n\n\nTo create an offer template:\n\n\n\n\nCreate an \nIFRAME\n element within your page with a memorable ID. For example:\n\n\n\n\niframe style=\nwidth: 100%; height: 55px; margin: 0; border: 0;\n id=\noffer-iframe\n\n\n/iframe\n\n\n\n\n\n\n\nAdd JavaScript to your page to ask Sandstorm to fill the iframe with\n  content. For example:\n\n\n\n\nscript\n\nfunction fillIframe() {\n  var template = \nYou can use the $API_TOKEN key to reach me at $API_HOST.\n;\n  window.parent.postMessage({renderTemplate: {rpcId: \n0\n, template: template}}, \n*\n);\n}\n\n/script\n\n\n\n\n\n\n\nAdd a window event listener so the Sandstorm shell can provide the\n  URL to you.\n\n\n\n\nscript\n\nvar messageListener = function(event) {\n  if (event.data.rpcId === \n0\n) {\n    if (event.data.error) {\n      console.log(\nERROR: \n + event.data.error);\n    } else {\n      var el = document.getElementById(\noffer-iframe\n);\n      el.setAttribute(\nsrc\n, event.data.uri);\n    }\n  }\n};\n\nwindow.addEventListener(\nmessage\n, messageListener);\n\n/script\n\n\n\n\n\nAs an implementation detail: the \nrpcId\n in the \nevent.data\n response\nis the same as the value provided to the \nrenderTemplate\n request. We\nused \n\"0\"\n here; you can choose any value.\n\n\n\n\nWhen your page loads, make the request.\n\n\n\n\nscript\n\ndocument.addEventListener(\nDOMContentLoaded\n, fillIframe);\n\n/script\n\n\n\n\n\n\n\nYour offer template will now contain text such as:\n\n\n\n\nYou can use the 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9 key to reach me at https://alpha-api.sandstorm.io/.\n\n\n\n\nNote\n: API tokens created this way must be used within 5 minutes,\nor else they \nautomatically\nexpire\n. To\nprevent this from becoming a serious problem, the Sandstorm shell\nautomatically refreshes the IFRAME every 5 minutes.\n\n\nParameters to renderTemplate()\n\n\nrenderTemplate()\n accepts the following parameters:\n\n\n\n\n\n\nrpcId\n: \nString\n of a message ID that will be passed back to your\n  code.\n\n\n\n\n\n\ntemplate\n: \nString\n to display to the user, where \n$API_HOST\n\n  and \n$API_TOKEN\n will be replaced.\n\n\n\n\n\n\npetname\n: \nString (optional)\n of a name that this API token will\n  have, when the user lists the API tokens and sharing links they have\n  generated.\n\n\n\n\n\n\nroleAssignment\n: \nroleAssignmentPattern (optional)\n of\n  permissions to apply to inbound requests. Use this to create API\n  tokens with limited permissions, such as a read-only view.\n\n\n\n\n\n\nforSharing\n: \nBoolean (optional)\n true if this token should\n  represent the anonymous user. You can use this to detach the token\n  from the user who created it. \nNote\n that this also allows users\n  to redeem it as a sharing link of the form\n  \nhttps://sandstorm.example.com/shared/$API_TOKEN\n.\n\n\n\n\n\n\nAbout WebKeys\n\n\nWhen a user clicks on the key icon within app, it creates a\n\nwebkey\n, which is a\ncombination of an endpoint URL and an API token separated by a \n#\n. An\nexample is:\n\n\nhttps://alpha-api.sandstorm.io#49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9\n\n\n\nThis format is intentionally chosen to look like a valid URL that\ncould be opened in a browser. Eventually, when such a URL is loaded\ndirectly in a browser, Sandstorm will show the user information about\nthe API and possibly offer the ability to explore the API and initiate\nrequests for debugging purposes. As of this writing, these features\nare not yet implemented.\n\n\nThe part of the webkey before the \n#\n is the API endpoint for the\nserver (in this case, for alpha.sandstorm.io). After the \n#\n is the\nAPI token. So, to make a request to the webkey specified above, you\nmight use the following \ncurl\n command:\n\n\ncurl -H \"Authorization: Bearer 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9\" https://alpha-api.sandstorm.io\n\n\n\nBearer tokens vs. Basic auth\n\n\nTypically, HTTP APIs on Sandstorm should be accessed using an OAuth\n2.0-style Bearer token in an Authorization header:\n\n\n    Authorization: Bearer \ntoken\n\n\n\n\n\nBecause an \nAuthorization\n header is required, it is impossible for a\nweb browser to open a Sandstorm HTTP API directly in a browser\nwindow. This is intentional: this prevents Sandstorm apps from\nexecuting arbitrary scripts from the API host.\n\n\nSome apps are unable to use Bearer tokens; they can use HTTP Basic\nauth. The Sandstorm code maintains a \nwhitelist of \nUser-Agent\n\nstrings\n\nthat are allowed to use Basic auth. If your Sandstorm app has a client\nthat cannot use an Authoriztion header, consider \nfiling a\nbug\n requesting the\nwhite-listing of its user-agent value.", 
            "title": "Exporting HTTP APIs"
        }, 
        {
            "location": "/developing/http-apis/#overview", 
            "text": "When custom code needs to interact with a Sandstorm app, it sends a\nHTTP request to the  API hostname  of the Sandstorm host where app\nis running, along with an  API token  embedded in an  Authorization \nHTTP header.  You can try making a request to a Sandstorm app's API right now via  curl :  curl -H  Authorization: Bearer 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9  https://alpha-api.sandstorm.io/  Sandstorm is responsible for generating the API token. The API token\nis used for both  access control  and  routing a request  to the\nappropriate grain.  When a request comes in with a valid API token, Sandstorm sanitizes\nthe request, removing the  Cookie  header and the API token, adding\ntypical Sandstorm authentication headers like  X-Sandstorm-User-Id ,\nand passes the request to the app. Sandstorm combines it with the app\npackage's  bridgeConfig.apiPath  as part of sending the request to the\ngrain. Sandstorm sanitizes responses and removes any  Set-Cookie \nresponse header.  The API endpoint is set up to allow  cross-origin requests from any\norigin , which means you can access an API from  XMLHttpRequest  on\nany domain.  An app can  request the generation of an API token , and a Sandstorm\nuser can manually create a valid API token by clicking on the Webkey icon\nin the Sandstorm shell.", 
            "title": "Overview"
        }, 
        {
            "location": "/developing/http-apis/#how-to-generate-an-api-token", 
            "text": "There are various ways to obtain an API token:    The best is via  offer templates , where the app specifies textual\n  information for the user of the app, and Sandstorm places the token\n  into this template before displaying it to the user.    The user can click the key icon in the top bar when they have an app\n  open.    In the future, we will implement an OAuth flow allowing a third party\nto initiate a request for access to the user's apps.  Sandstorm's  HackSessionContext  exports a Cap'n Proto RPC method\ncalled  HackSessionContext.generateApiToken() . That method is\ndeprecated in favor of offer templates. If you need to use it, read\nthe  web publishing guide  for more about how to\naccess  HackSessionContext .", 
            "title": "How to generate an API token"
        }, 
        {
            "location": "/developing/http-apis/#creating-an-offer-template", 
            "text": "An  offer template  is a way for Sandstorm to display an API token to\nthe user without the app being able to see the token.  You can see an example by launching  a GitWeb\ndemo .  We implement this as an  IFRAME  from the Sandstorm server. The grain\ncannot peek into the element. To fill the  IFRAME  with helpful information\nfor the user, including an API token, client-side Javascript in the grain\nprovides a template to Sandstorm, and Sandstorm responds with a URL that\nthe app can use as the  SRC  of the  IFRAME .  To create an offer template:   Create an  IFRAME  element within your page with a memorable ID. For example:   iframe style= width: 100%; height: 55px; margin: 0; border: 0;  id= offer-iframe  /iframe    Add JavaScript to your page to ask Sandstorm to fill the iframe with\n  content. For example:   script \nfunction fillIframe() {\n  var template =  You can use the $API_TOKEN key to reach me at $API_HOST. ;\n  window.parent.postMessage({renderTemplate: {rpcId:  0 , template: template}},  * );\n} /script    Add a window event listener so the Sandstorm shell can provide the\n  URL to you.   script \nvar messageListener = function(event) {\n  if (event.data.rpcId ===  0 ) {\n    if (event.data.error) {\n      console.log( ERROR:   + event.data.error);\n    } else {\n      var el = document.getElementById( offer-iframe );\n      el.setAttribute( src , event.data.uri);\n    }\n  }\n};\n\nwindow.addEventListener( message , messageListener); /script   As an implementation detail: the  rpcId  in the  event.data  response\nis the same as the value provided to the  renderTemplate  request. We\nused  \"0\"  here; you can choose any value.   When your page loads, make the request.   script \ndocument.addEventListener( DOMContentLoaded , fillIframe); /script    Your offer template will now contain text such as:   You can use the 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9 key to reach me at https://alpha-api.sandstorm.io/.  Note : API tokens created this way must be used within 5 minutes,\nor else they  automatically\nexpire . To\nprevent this from becoming a serious problem, the Sandstorm shell\nautomatically refreshes the IFRAME every 5 minutes.", 
            "title": "Creating an offer template"
        }, 
        {
            "location": "/developing/http-apis/#parameters-to-rendertemplate", 
            "text": "renderTemplate()  accepts the following parameters:    rpcId :  String  of a message ID that will be passed back to your\n  code.    template :  String  to display to the user, where  $API_HOST \n  and  $API_TOKEN  will be replaced.    petname :  String (optional)  of a name that this API token will\n  have, when the user lists the API tokens and sharing links they have\n  generated.    roleAssignment :  roleAssignmentPattern (optional)  of\n  permissions to apply to inbound requests. Use this to create API\n  tokens with limited permissions, such as a read-only view.    forSharing :  Boolean (optional)  true if this token should\n  represent the anonymous user. You can use this to detach the token\n  from the user who created it.  Note  that this also allows users\n  to redeem it as a sharing link of the form\n   https://sandstorm.example.com/shared/$API_TOKEN .", 
            "title": "Parameters to renderTemplate()"
        }, 
        {
            "location": "/developing/http-apis/#about-webkeys", 
            "text": "When a user clicks on the key icon within app, it creates a webkey , which is a\ncombination of an endpoint URL and an API token separated by a  # . An\nexample is:  https://alpha-api.sandstorm.io#49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9  This format is intentionally chosen to look like a valid URL that\ncould be opened in a browser. Eventually, when such a URL is loaded\ndirectly in a browser, Sandstorm will show the user information about\nthe API and possibly offer the ability to explore the API and initiate\nrequests for debugging purposes. As of this writing, these features\nare not yet implemented.  The part of the webkey before the  #  is the API endpoint for the\nserver (in this case, for alpha.sandstorm.io). After the  #  is the\nAPI token. So, to make a request to the webkey specified above, you\nmight use the following  curl  command:  curl -H \"Authorization: Bearer 49Np9sqkYV4g_FpOQk1p0j1yJlvoHrZm9SVhQt7H2-9\" https://alpha-api.sandstorm.io", 
            "title": "About WebKeys"
        }, 
        {
            "location": "/developing/http-apis/#bearer-tokens-vs-basic-auth", 
            "text": "Typically, HTTP APIs on Sandstorm should be accessed using an OAuth\n2.0-style Bearer token in an Authorization header:      Authorization: Bearer  token   Because an  Authorization  header is required, it is impossible for a\nweb browser to open a Sandstorm HTTP API directly in a browser\nwindow. This is intentional: this prevents Sandstorm apps from\nexecuting arbitrary scripts from the API host.  Some apps are unable to use Bearer tokens; they can use HTTP Basic\nauth. The Sandstorm code maintains a  whitelist of  User-Agent \nstrings \nthat are allowed to use Basic auth. If your Sandstorm app has a client\nthat cannot use an Authoriztion header, consider  filing a\nbug  requesting the\nwhite-listing of its user-agent value.", 
            "title": "Bearer tokens vs. Basic auth"
        }, 
        {
            "location": "/developing/email-from-apps/", 
            "text": "Using email from your Sandstorm app\n\n\nUsing e-mail in your Sandstorm app is accomplished through the Cap'n\nProto interfaces defined in\n\nhack-session.capnp\n\nand\n\nemail.capnp\n. This\nbecomes a little more complicated if you're using\nsandstorm-http-bridge in your app (as most apps do), since you don't\nhave direct access to the HackSession/HackSessionContext. Below, we\nwill go over using either sandstorm-http-bridge or using the\nHackSession directly.\n\n\nNote: Provisional API\n\n\nThe current implementation of e-mail is hacky and not intended to be\nthe long-term solution. In the long term, users will be able to\nconnect e-mail addresses to their Sandstorm account and then grant\nthem to apps as capabilities through the Powerbox UI. Since the\nPowerbox and persistent capabilities are not yet implemented -- much\nless the ability to connect e-mails -- we are providing a hack so that\ndevelopers can get started on such apps now. The hack involves\nassigning a randomly-generated e-mail address to each app instance\nthat wants e-mail, but also allowing the \"From\" header to be set to\nany e-mail address that the user has proven they own.\n\n\nOverview\n\n\nWhen you launch an e-mail application on Sandstorm, it is assigned a\nrandom e-mail address at your server, like\n\"JBuaKxjkwiJq7oksS@alpha.sandstorm.io\". Any e-mail sent to that\naddress is delivered to the app. The idea is not that you'd actually\nuse this address publicly, but rather that you should set up e-mail\nforwarding from your real address to this address. For example, GMail\nallows you to set up such forwarding while still keeping a copy in\nyour GMail inbox, and even lets you do the forwarding conditionally\nbased on a filter.  Additionally, most domain registrars have the\nability to set up basic e-mail forwarding, so if you have your own\ndomain, it's easy to set up an address that redirects to a Sandstorm\napp.\n\n\nWhen you send e-mail from a Sandstorm app, we allow you to set the\n\"From\" header either to your app's random address or to your verified\nSandstorm login address. In the future, we'd like to add the ability\nto attach additional verified addresses to your account. Either way,\nthe message's envelope return address is always the app's address. As\na result, the mail recipient may see that the message was sent \"via\"\nyour server.\n\n\nIn order to prevent abuse, E-mail usage is rate-limited\nper-user. Currently, the limits default to 50 messages per day and no\nmore than 20 recipients on any one message. We'd like to loosen these\nlimits in the future by doing more careful abuse monitoring.\n\n\nUsing sandstorm-http-bridge\n\n\nReceiving\n\n\nIn this case, receipt of e-mails is already handled for you. Upon your\ngrain receiving an e-mail, it will be written to \n/var/mail/new\n. This\nfollows the \nmaildir\n\nconvention, and many e-mail apps will be able to use this out of the\nbox.\n\n\nSending\n\n\nSending e-mails is a bit more tricky. For now, you have to use the\nCap'n Proto\n\nHackSessionContext\n\ninterface that is re-exported by\nsandstorm-http-bridge. sandstorm-http-bridge creates a socket at\n\n/tmp/sandstorm-api\n and exports a bootstrap\n\nSandstormHttpBridge\n\ncapability on it. You will need to call \ngetSessionContext()\n with the\nID that sandstorm-http-bridge places in the \nX-Sandstorm-Session-Id\n\nheader. The result will be a \nSessionContext\n that can be cast to a\n\nHackSessionContext\n. For example, using pycapnp, you can get the\n\nHackSessionContext\n as follows:\n\n\nimport socket\nimport sys\nimport capnp\nimport sandstorm_http_bridge_capnp\nimport hack_session_capnp\n\n# Assume that we were passed the session ID as a commandline argument.\nsession_id = sys.argv[1]\n\ns = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\ns.connect(\n/tmp/sandstorm-api\n)\n\nclient = capnp.TwoPartyClient(s)\nbridge = client.ez_restore().cast_as(sandstorm_http_bridge_capnp.SandstormHttpBridge)\nsession_context = bridge.get_session_context({\nid\n : session_id}).wait().context\nemail_cap = session_context.cast_as(hack_session_capnp.HackSessionContext)\n\n\n\n\nNow that you have a HackSessionContext, just follow the directions\nbelow under \nSending with\nHackSessionContext\n.\n\n\nUsing HackSession/HackSessionContext\n\n\nReceiving through HackSession\n\n\nYour \nUIView.newSession\n method (refer to\n\ngrain.capnp\n) must return a\nHackEmailSession. In your HackEmailSession capability, you must\nimplement the \nsend\n method, which will be called whenever an e-mail\nis sent to the grain.\n\n\nSending with HackSessionContext\n\n\nA HackSessionContext is obtained upon call of \nUIView.newSession\n\n(refer to\n\ngrain.capnp\n). You will be\npassed a HackSessionContext as the 2nd paramater, and it is up to your\napp to store/use it.\n\n\nNow that you have the HackSessionContext, sending e-mails is easy:\n\n\nreq = email_cap.send_request()\nemail = req.email\n\n# only getUserAddress() or the grain's public address are allowed here\n# use setattr to deal with 'from' being a reserved keyword in Python\nsetattr(email, 'from', email_cap.getUserAddress().wait())\nemail.to = {address: 'example@example.com'}\nemail.subject = 'Example e-mail'\nemail.text = 'This is an example e-mail'\n\nreq.send().wait()", 
            "title": "Email from apps"
        }, 
        {
            "location": "/developing/email-from-apps/#using-email-from-your-sandstorm-app", 
            "text": "Using e-mail in your Sandstorm app is accomplished through the Cap'n\nProto interfaces defined in hack-session.capnp \nand email.capnp . This\nbecomes a little more complicated if you're using\nsandstorm-http-bridge in your app (as most apps do), since you don't\nhave direct access to the HackSession/HackSessionContext. Below, we\nwill go over using either sandstorm-http-bridge or using the\nHackSession directly.", 
            "title": "Using email from your Sandstorm app"
        }, 
        {
            "location": "/developing/email-from-apps/#note-provisional-api", 
            "text": "The current implementation of e-mail is hacky and not intended to be\nthe long-term solution. In the long term, users will be able to\nconnect e-mail addresses to their Sandstorm account and then grant\nthem to apps as capabilities through the Powerbox UI. Since the\nPowerbox and persistent capabilities are not yet implemented -- much\nless the ability to connect e-mails -- we are providing a hack so that\ndevelopers can get started on such apps now. The hack involves\nassigning a randomly-generated e-mail address to each app instance\nthat wants e-mail, but also allowing the \"From\" header to be set to\nany e-mail address that the user has proven they own.", 
            "title": "Note: Provisional API"
        }, 
        {
            "location": "/developing/email-from-apps/#overview", 
            "text": "When you launch an e-mail application on Sandstorm, it is assigned a\nrandom e-mail address at your server, like\n\"JBuaKxjkwiJq7oksS@alpha.sandstorm.io\". Any e-mail sent to that\naddress is delivered to the app. The idea is not that you'd actually\nuse this address publicly, but rather that you should set up e-mail\nforwarding from your real address to this address. For example, GMail\nallows you to set up such forwarding while still keeping a copy in\nyour GMail inbox, and even lets you do the forwarding conditionally\nbased on a filter.  Additionally, most domain registrars have the\nability to set up basic e-mail forwarding, so if you have your own\ndomain, it's easy to set up an address that redirects to a Sandstorm\napp.  When you send e-mail from a Sandstorm app, we allow you to set the\n\"From\" header either to your app's random address or to your verified\nSandstorm login address. In the future, we'd like to add the ability\nto attach additional verified addresses to your account. Either way,\nthe message's envelope return address is always the app's address. As\na result, the mail recipient may see that the message was sent \"via\"\nyour server.  In order to prevent abuse, E-mail usage is rate-limited\nper-user. Currently, the limits default to 50 messages per day and no\nmore than 20 recipients on any one message. We'd like to loosen these\nlimits in the future by doing more careful abuse monitoring.", 
            "title": "Overview"
        }, 
        {
            "location": "/developing/email-from-apps/#using-sandstorm-http-bridge", 
            "text": "Receiving  In this case, receipt of e-mails is already handled for you. Upon your\ngrain receiving an e-mail, it will be written to  /var/mail/new . This\nfollows the  maildir \nconvention, and many e-mail apps will be able to use this out of the\nbox.  Sending  Sending e-mails is a bit more tricky. For now, you have to use the\nCap'n Proto HackSessionContext \ninterface that is re-exported by\nsandstorm-http-bridge. sandstorm-http-bridge creates a socket at /tmp/sandstorm-api  and exports a bootstrap SandstormHttpBridge \ncapability on it. You will need to call  getSessionContext()  with the\nID that sandstorm-http-bridge places in the  X-Sandstorm-Session-Id \nheader. The result will be a  SessionContext  that can be cast to a HackSessionContext . For example, using pycapnp, you can get the HackSessionContext  as follows:  import socket\nimport sys\nimport capnp\nimport sandstorm_http_bridge_capnp\nimport hack_session_capnp\n\n# Assume that we were passed the session ID as a commandline argument.\nsession_id = sys.argv[1]\n\ns = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\ns.connect( /tmp/sandstorm-api )\n\nclient = capnp.TwoPartyClient(s)\nbridge = client.ez_restore().cast_as(sandstorm_http_bridge_capnp.SandstormHttpBridge)\nsession_context = bridge.get_session_context({ id  : session_id}).wait().context\nemail_cap = session_context.cast_as(hack_session_capnp.HackSessionContext)  Now that you have a HackSessionContext, just follow the directions\nbelow under  Sending with\nHackSessionContext .", 
            "title": "Using sandstorm-http-bridge"
        }, 
        {
            "location": "/developing/email-from-apps/#using-hacksessionhacksessioncontext", 
            "text": "Receiving through HackSession  Your  UIView.newSession  method (refer to grain.capnp ) must return a\nHackEmailSession. In your HackEmailSession capability, you must\nimplement the  send  method, which will be called whenever an e-mail\nis sent to the grain.  Sending with HackSessionContext  A HackSessionContext is obtained upon call of  UIView.newSession \n(refer to grain.capnp ). You will be\npassed a HackSessionContext as the 2nd paramater, and it is up to your\napp to store/use it.  Now that you have the HackSessionContext, sending e-mails is easy:  req = email_cap.send_request()\nemail = req.email\n\n# only getUserAddress() or the grain's public address are allowed here\n# use setattr to deal with 'from' being a reserved keyword in Python\nsetattr(email, 'from', email_cap.getUserAddress().wait())\nemail.to = {address: 'example@example.com'}\nemail.subject = 'Example e-mail'\nemail.text = 'This is an example e-mail'\n\nreq.send().wait()", 
            "title": "Using HackSession/HackSessionContext"
        }, 
        {
            "location": "/vagrant-spk/design/", 
            "text": "vagrant-spk design document\n\n\nThis page documents the initial design goals of\n\nvagrant-spk\n. Therefore it is a statement of \nhope\n, not a statement\nof \nfact.\n Given that, please take it with a pinch of salt.\n\n\nYou can find the current implementation at\n\nsandstorm-io/vagrant-spk\n.\n\n\nAbout vagrant-spk\n\n\nvagrant-spk\n is a tool that makes it easy to take a web application\nthat runs on Linux and make a Sandstorm package from it. It is called\n\nvagrant-spk\n because it relies on Vagrant, a tool that makes it\n(supposedly) easy to create disposable virtual Linux systems.\n\n\nvagrant-spk\n emphasizes:\n\n\n\n\nClear process\n: This documentation should serve as a clear guide for how to package an app for Sandstorm. The purpose of each step should be clear, and it should be easy to debug problems.\n\n\nSupport for many platforms\n: Packaging an app for Sandstorm with \nvagrant-spk\n should work properly on Windows, Mac, and Linux.\n\n\nUseful defaults, with deviation possible\n: If the tooling can choose a default that is likely to work for people, it does so; it also documents how to make a different choice if you have to.\n\n\nRe-usability\n: The work that you do to package the app should be usable by other people, and it should be useful to you when you need to upgrade the app to its latest version.\n\n\nHumility\n: \nvagrant-spk\n is a convenience tool, but nothing in it a \ncore\n part of Sandstorm. Therefore, if other people come up with a better tool for creating SPKs, it will be possible for that future tool to take over the ecosystem.\n\n\n\n\nTo package an app for Sandstorm with \nvagrant-spk\n, you will need to follow these steps:\n\n\n\n\nInstall \nvagrant-spk\n, so that it is on your $PATH.\n\n\nInstall Vagrant on your system.\n\n\nRun \nvagrant-spk setupvm lemp\n within the app's main source tree, to create template files that will be used by the packaging process.  'lemp' here refers to a particular software stack (linux/nginx/mysql/php) that should be run in the package; we may add support for other stacks in the future.\n\n\nRun \nvagrant-spk up\n from the same folder to launch the VM, install a developer-mode Sandstorm instance, and install and configure nginx/php/mysql for the app.\n\n\nRun \nvagrant-spk init\n to create a \nsandstorm-pkgdef.capnp\n file describing the app.  Modify it to correct things like e.g. app name and action text.\n\n\nGet your app ready for the Sandstorm sandbox. This will mean ensuring the app runs properly at all.\n\n\nRun \nvagrant-spk dev\n to verify if the app runs within Sandstorm. If not, loop back to \"Get your app ready\".\n\n\nRun \nvagrant-spk pack\n to create an SPK file, containing your app and all its dependencies.\n\n\nDistribute your SPK file to yourself (on your own Sandstorm instance) and (optionally) add it to the Sandstorm App List.\n\n\nOptional, but recommended: Push the files created by \nvagrant-spk\n into version control.\n\n\n\n\nRight now, \nvagrant-spk\n is built primarily with PHP/MySQL apps in\nmind. We hope to enhance it over time to work for a wider variety of\napps.\n\n\nTo read how to package a sample PHP/MySQL app for Sandstorm, read the\n\nfive minute packaging tutorial\n.\n\n\nInstallation plans\n\n\nHow are Windows people going to execute a shell script?\n\n\nThen again, should we grow up and make it a Python script (and\nprobably limit its dependencies to the Python standard library)? If\nso, then we can use e.g. py2exe and make it a single EXE file that you\nplace somewhere that's always on the %PATH%.\n\n\nWe could write it in Go. Hmm. Or we could write it in C++. Or we could\nwrite it in JavaScript and for Windows convenience, use JSDB:\nhttp://jsdb.org/ which allows\n\n\nTurns out NSIS offers a way to modify %PATH%, if we need to go down that road:\n\n\n\n\nhttp://nsis.sourceforge.net/Path_Manipulation\n\n\nhttps://stackoverflow.com/questions/11272066/nsis-how-to-set-an-environment-variable-in-system-variable\n\n\n\n\nCreate packaging template files, with vagrant-spk init\n\n\n\nIf you see the following instead:\n\n\n\n\n\n$ ls index.\n\nls: cannot access index.\n: No such file or directory\n\n\n\nYou probably need to use `cd` to switch into the directory containing the app you want to package.\n\n## Original proposed result of vagrant-spk init\n\n\n\n\n\n$ vagrant-spk init\n\n\n\nIt will create the following files, which you will customize over the course of this guide.\n\n* `.sandstorm/Vagrantfile` - This file contains information defining a virtual machine.\n* `.sandstorm/provision.sh` - This file contains commands to run when creating the virtual machine. You'll customize it below if needed.\n* `.sandstorm/sandstorm-pkgdef.capnp` - This file contains information about the package, such as its name.\n* `.sandstorm/sandstorm-files.list` - This is a list of all the files from the operating system that will become part of the SPK.\n\nIf you have a `.gitignore` file, it will add these lines to it:\n\n\n\n\n\n.sandstorm/on-instance-start-initial-var/\n.sandstorm/tmp/\n.sandstorm/build-result/\n\n\n\nFeel free to add all these changes into git, if you like, and commit.\n\n## Start a virtual machine to run your app\n\n### Click around to do setup tasks\n\nSome PHP/MySQL apps require manual interaction with their web interface to set up a config file and sample data. Now is a good time to do those tasks.\n\n## Get your app ready for the Sandstorm sandbox\n\n### Overview\n\nWhen a user of an app starts an instance in Sandstorm, Sandstorm does the following:\n\n* Unpack the contents of the SPK into a new directory.\n* Start a fresh container with the SPK content mapped in _read-only_.\n* Create an empty directory at `/var` specific to this one instance.\n* _Prepare the instance_ by running all the scripts, if any, in the `.sandstorm/on-instance-create.d/` directory. By default, this also includes copying the contents of `.sandstorm/on-instance-start-initial-var/` into `/var`.\n* _Run the app_ by running all the scripts in the `.sandstorm/on-instance-start.d/` directory.\n* _Provide HTTP headers_ indicating user identity and access level to the app. (See the separate doc on [User Authentication](User-Authentication) on the topic.)\n\n(If you are curious, some of this infrastructure is built-in to Sandstorm, and some is provided by `vagrant-spk`; see also `.sandstorm/sandstorm-pkgdev.capnp` to learn more about the boundary.)\n\nTherefore, you will need to create a snapshot of `/var` that is loaded into each app instance. The steps below indicate how to do that.\n\n### Steps\n\nTo improve clarity, let's temporarily stop the nginx and mysql services. (The easiest way to get them back is to run `vagrant reload`, which reboots the Linux virtual machine and starts all services that would normally auto-start.)\n\nTo do that, run the following from the `.sandstorm` directory:\n\n\n\n\n\n$ vagrant ssh\n$ sudo service nginx stop\n$ sudo service mysql stop\n\n\n\nTo verify that nginx has truly stopped, visit http://localhost:8000/ in your browser now. You will notice that your browser shows you an error page, whereas earlier it showed the app you were packaging.\n\nIf your app needs data in `/var` to run properly -- for example, if it needs a MySQL or sqlite database that you have already created -- you can copy that into the `.sandstorm/on-instance-start-initial-var/` directory with the following commands:\n\n\n\n\n\n$ rsync -av /var/. /opt/app/.sandstorm/on-instace-start-initial-var/\n\n\n\nThat should be all you need to do within while logged into the virtual machine. So you can run this command to go back to leave the `vagrant ssh` session.\n\n\n\n\n\n$ exit\n\n\n\nMake sure you are in the `.sandstorm/` directory, then run:\n\n\n\n\n\n$ vagrant-spk dev\n\n\n\nThis will do the following:\n\n* Start Sandstorm within the Vagrant box, and\n* Make your app available to it.\n\nSo now if you visit http://local.sandstorm.io:6080/ , you should see the ability to start an instance of your app.\n\nDoes it work properly? Great! Try a second instance!\n\nAt this point, you might notice that the button to start an instance of your app is labeled \nNew Sample App\n. You probably want to change the name from \nNew Sample App\n to something better by editing `.sandstorm/sandstorm-pkgdev.capnp`.\n\nNote that it's _essential_ that you try out the app during this phase. Sandstorm emphasizes small SPK files, and we achieve this by tracing the app when `spk dev` is running, storing a list of files the app truly access. You can feel comfortable knowing that none of your personal files are available within the Vagrant virtual machine, so none of your personal files will be embedded in the SPK file.\n\nNow, quit `vagrant-spk dev` by typing `Ctrl-C` on your keyboard. The tooling will generate a `.sandstorm/sandstorm-files.list` that you can inspect.\n\n## Create the SPK file, with vagrant-spk pack\n\nFinally, you can pack all the files of your app and the operating system components that it used by running this command:\n\n\n\n\n\n$ vagrant-spk pack\n\n\n\nThis creates a file called:\n\n\n\n\n\n.sandstorm/build-result/package.spk\n```\n\n\nYou can add this to your own Sandstorm server, or upload it to your web hosting and ask us to add it to the Sandstorm App List.\n\n\nDistribute the SPK file!\n\n\nDistribute your SPK file to yourself (on your own Sandstorm instance) and (optionally) add it to the Sandstorm App List.\n\n\nAdd these files to version control\n\n\nOptional, but recommended: Push the files created by vagrant-spk into version control.\n\n\nBack up your key\n\n\nAlways a good idea.\n\n\nKnown ways to improve this\n\n\n\n\nDocument how to handle the MySQL content specifically, and what MySQL username/password the app should use. The general plan is:\n\n\nPre-install MySQL, and have a hard-coded username \n password that apps should use, and\n\n\nTell people to rsync the MySQL data into the var snapshot directory, so that there is a clear moment where they do that snapshotting (and therefore they know how to modify it).", 
            "title": "vagrant-spk design document"
        }, 
        {
            "location": "/vagrant-spk/design/#vagrant-spk-design-document", 
            "text": "This page documents the initial design goals of vagrant-spk . Therefore it is a statement of  hope , not a statement\nof  fact.  Given that, please take it with a pinch of salt.  You can find the current implementation at sandstorm-io/vagrant-spk .", 
            "title": "vagrant-spk design document"
        }, 
        {
            "location": "/vagrant-spk/design/#about-vagrant-spk", 
            "text": "vagrant-spk  is a tool that makes it easy to take a web application\nthat runs on Linux and make a Sandstorm package from it. It is called vagrant-spk  because it relies on Vagrant, a tool that makes it\n(supposedly) easy to create disposable virtual Linux systems.  vagrant-spk  emphasizes:   Clear process : This documentation should serve as a clear guide for how to package an app for Sandstorm. The purpose of each step should be clear, and it should be easy to debug problems.  Support for many platforms : Packaging an app for Sandstorm with  vagrant-spk  should work properly on Windows, Mac, and Linux.  Useful defaults, with deviation possible : If the tooling can choose a default that is likely to work for people, it does so; it also documents how to make a different choice if you have to.  Re-usability : The work that you do to package the app should be usable by other people, and it should be useful to you when you need to upgrade the app to its latest version.  Humility :  vagrant-spk  is a convenience tool, but nothing in it a  core  part of Sandstorm. Therefore, if other people come up with a better tool for creating SPKs, it will be possible for that future tool to take over the ecosystem.   To package an app for Sandstorm with  vagrant-spk , you will need to follow these steps:   Install  vagrant-spk , so that it is on your $PATH.  Install Vagrant on your system.  Run  vagrant-spk setupvm lemp  within the app's main source tree, to create template files that will be used by the packaging process.  'lemp' here refers to a particular software stack (linux/nginx/mysql/php) that should be run in the package; we may add support for other stacks in the future.  Run  vagrant-spk up  from the same folder to launch the VM, install a developer-mode Sandstorm instance, and install and configure nginx/php/mysql for the app.  Run  vagrant-spk init  to create a  sandstorm-pkgdef.capnp  file describing the app.  Modify it to correct things like e.g. app name and action text.  Get your app ready for the Sandstorm sandbox. This will mean ensuring the app runs properly at all.  Run  vagrant-spk dev  to verify if the app runs within Sandstorm. If not, loop back to \"Get your app ready\".  Run  vagrant-spk pack  to create an SPK file, containing your app and all its dependencies.  Distribute your SPK file to yourself (on your own Sandstorm instance) and (optionally) add it to the Sandstorm App List.  Optional, but recommended: Push the files created by  vagrant-spk  into version control.   Right now,  vagrant-spk  is built primarily with PHP/MySQL apps in\nmind. We hope to enhance it over time to work for a wider variety of\napps.  To read how to package a sample PHP/MySQL app for Sandstorm, read the five minute packaging tutorial .", 
            "title": "About vagrant-spk"
        }, 
        {
            "location": "/vagrant-spk/design/#installation-plans", 
            "text": "How are Windows people going to execute a shell script?  Then again, should we grow up and make it a Python script (and\nprobably limit its dependencies to the Python standard library)? If\nso, then we can use e.g. py2exe and make it a single EXE file that you\nplace somewhere that's always on the %PATH%.  We could write it in Go. Hmm. Or we could write it in C++. Or we could\nwrite it in JavaScript and for Windows convenience, use JSDB:\nhttp://jsdb.org/ which allows  Turns out NSIS offers a way to modify %PATH%, if we need to go down that road:   http://nsis.sourceforge.net/Path_Manipulation  https://stackoverflow.com/questions/11272066/nsis-how-to-set-an-environment-variable-in-system-variable", 
            "title": "Installation plans"
        }, 
        {
            "location": "/vagrant-spk/design/#create-packaging-template-files-with-vagrant-spk-init", 
            "text": "If you see the following instead:  $ ls index. \nls: cannot access index. : No such file or directory  \nYou probably need to use `cd` to switch into the directory containing the app you want to package.\n\n## Original proposed result of vagrant-spk init  $ vagrant-spk init  \nIt will create the following files, which you will customize over the course of this guide.\n\n* `.sandstorm/Vagrantfile` - This file contains information defining a virtual machine.\n* `.sandstorm/provision.sh` - This file contains commands to run when creating the virtual machine. You'll customize it below if needed.\n* `.sandstorm/sandstorm-pkgdef.capnp` - This file contains information about the package, such as its name.\n* `.sandstorm/sandstorm-files.list` - This is a list of all the files from the operating system that will become part of the SPK.\n\nIf you have a `.gitignore` file, it will add these lines to it:  .sandstorm/on-instance-start-initial-var/\n.sandstorm/tmp/\n.sandstorm/build-result/  \nFeel free to add all these changes into git, if you like, and commit.\n\n## Start a virtual machine to run your app\n\n### Click around to do setup tasks\n\nSome PHP/MySQL apps require manual interaction with their web interface to set up a config file and sample data. Now is a good time to do those tasks.\n\n## Get your app ready for the Sandstorm sandbox\n\n### Overview\n\nWhen a user of an app starts an instance in Sandstorm, Sandstorm does the following:\n\n* Unpack the contents of the SPK into a new directory.\n* Start a fresh container with the SPK content mapped in _read-only_.\n* Create an empty directory at `/var` specific to this one instance.\n* _Prepare the instance_ by running all the scripts, if any, in the `.sandstorm/on-instance-create.d/` directory. By default, this also includes copying the contents of `.sandstorm/on-instance-start-initial-var/` into `/var`.\n* _Run the app_ by running all the scripts in the `.sandstorm/on-instance-start.d/` directory.\n* _Provide HTTP headers_ indicating user identity and access level to the app. (See the separate doc on [User Authentication](User-Authentication) on the topic.)\n\n(If you are curious, some of this infrastructure is built-in to Sandstorm, and some is provided by `vagrant-spk`; see also `.sandstorm/sandstorm-pkgdev.capnp` to learn more about the boundary.)\n\nTherefore, you will need to create a snapshot of `/var` that is loaded into each app instance. The steps below indicate how to do that.\n\n### Steps\n\nTo improve clarity, let's temporarily stop the nginx and mysql services. (The easiest way to get them back is to run `vagrant reload`, which reboots the Linux virtual machine and starts all services that would normally auto-start.)\n\nTo do that, run the following from the `.sandstorm` directory:  $ vagrant ssh\n$ sudo service nginx stop\n$ sudo service mysql stop  \nTo verify that nginx has truly stopped, visit http://localhost:8000/ in your browser now. You will notice that your browser shows you an error page, whereas earlier it showed the app you were packaging.\n\nIf your app needs data in `/var` to run properly -- for example, if it needs a MySQL or sqlite database that you have already created -- you can copy that into the `.sandstorm/on-instance-start-initial-var/` directory with the following commands:  $ rsync -av /var/. /opt/app/.sandstorm/on-instace-start-initial-var/  \nThat should be all you need to do within while logged into the virtual machine. So you can run this command to go back to leave the `vagrant ssh` session.  $ exit  \nMake sure you are in the `.sandstorm/` directory, then run:  $ vagrant-spk dev  \nThis will do the following:\n\n* Start Sandstorm within the Vagrant box, and\n* Make your app available to it.\n\nSo now if you visit http://local.sandstorm.io:6080/ , you should see the ability to start an instance of your app.\n\nDoes it work properly? Great! Try a second instance!\n\nAt this point, you might notice that the button to start an instance of your app is labeled  New Sample App . You probably want to change the name from  New Sample App  to something better by editing `.sandstorm/sandstorm-pkgdev.capnp`.\n\nNote that it's _essential_ that you try out the app during this phase. Sandstorm emphasizes small SPK files, and we achieve this by tracing the app when `spk dev` is running, storing a list of files the app truly access. You can feel comfortable knowing that none of your personal files are available within the Vagrant virtual machine, so none of your personal files will be embedded in the SPK file.\n\nNow, quit `vagrant-spk dev` by typing `Ctrl-C` on your keyboard. The tooling will generate a `.sandstorm/sandstorm-files.list` that you can inspect.\n\n## Create the SPK file, with vagrant-spk pack\n\nFinally, you can pack all the files of your app and the operating system components that it used by running this command:  $ vagrant-spk pack  \nThis creates a file called:  .sandstorm/build-result/package.spk\n```  You can add this to your own Sandstorm server, or upload it to your web hosting and ask us to add it to the Sandstorm App List.", 
            "title": "Create packaging template files, with vagrant-spk init"
        }, 
        {
            "location": "/vagrant-spk/design/#distribute-the-spk-file", 
            "text": "Distribute your SPK file to yourself (on your own Sandstorm instance) and (optionally) add it to the Sandstorm App List.", 
            "title": "Distribute the SPK file!"
        }, 
        {
            "location": "/vagrant-spk/design/#add-these-files-to-version-control", 
            "text": "Optional, but recommended: Push the files created by vagrant-spk into version control.", 
            "title": "Add these files to version control"
        }, 
        {
            "location": "/vagrant-spk/design/#back-up-your-key", 
            "text": "Always a good idea.", 
            "title": "Back up your key"
        }, 
        {
            "location": "/vagrant-spk/design/#known-ways-to-improve-this", 
            "text": "Document how to handle the MySQL content specifically, and what MySQL username/password the app should use. The general plan is:  Pre-install MySQL, and have a hard-coded username   password that apps should use, and  Tell people to rsync the MySQL data into the var snapshot directory, so that there is a clear moment where they do that snapshotting (and therefore they know how to modify it).", 
            "title": "Known ways to improve this"
        }, 
        {
            "location": "/developing/troubleshooting/", 
            "text": "This page lists common problems and work-arounds.\n\n\nThis page needs expansion! If you encounter a new problem and solve it, feel free to add it here. If you encounter a problem you don't know how to solve, try asking on Stack Overflow, and be sure to add the \"sandstorm.io\" tag to your question. Or, talk to us on IRC (#sandstorm on freenode) or \nsandstorm-dev\n.\n\n\nNote that language-specific issues should be documented in the language-specific guide pages, namely:\n\n\n\n\nPython\n\n\nRuby on Rails\n\n\nPure client apps\n\n\n\n\nClicking a link in the app does not open the link\n\n\nSandstorm apps cannot navigate the user away from the app. Therefore, app\nauthors should set \ntarget=\"_blank\"\n on links within the app.\n\n\nA convenient way to do this automatically for all links in the page is to add\nthe following HTML to your document's \nhead\n:\n\n\nbase target=\n_blank\n\n\n\n\n\nA blank white screen renders where the app should be\n\n\nThis can happen when a Sandstorm app in development doesn't know its\ncorrect base URL and serves a HTTP redirect away from the Sandstorm\nserver. Sandstorm blocks that redirect, resulting in a white grain\nframe.\n\n\nTo find out if you're running into this issue, open the Javascript\nconsole in your browser and look for a \nContent-Security-Policy\n\nviolation. If you see a message about navigation being blocked, then\nvery likely you are seeing this error.\n\n\nIf possible, configure the app to use a base URL of \n''\n, literally\nthe empty string. Then it will send HTTP redirects without\nspecifying a base URL. If that isn't possible, Sandstorm apps should\nlook at the\n\n\nSandstorm apps should look at the \nHost:\n header for a base URL if\nthey need one.\n\n\nKeyError: 'getpwuid(): uid not found: 1000'\n\n\nThis is a Python bug. See \nthe Python packaging guide\n for a work-around.\n\n\nEROFS\n or \"Read-only filesystem\"\n\n\nOnly the \n/var\n directory is writable; the rest of the filesystem (which contains the contents of your app package) is read-only.\n\n\nIf your app wants to write to locations other than \n/var\n, and it's not easy to change the app's code, one work-around is to create a symlink from the location you app wants to modify to a location under \n/var\n.  This won't work for all applications however.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/developing/troubleshooting/#clicking-a-link-in-the-app-does-not-open-the-link", 
            "text": "Sandstorm apps cannot navigate the user away from the app. Therefore, app\nauthors should set  target=\"_blank\"  on links within the app.  A convenient way to do this automatically for all links in the page is to add\nthe following HTML to your document's  head :  base target= _blank", 
            "title": "Clicking a link in the app does not open the link"
        }, 
        {
            "location": "/developing/troubleshooting/#a-blank-white-screen-renders-where-the-app-should-be", 
            "text": "This can happen when a Sandstorm app in development doesn't know its\ncorrect base URL and serves a HTTP redirect away from the Sandstorm\nserver. Sandstorm blocks that redirect, resulting in a white grain\nframe.  To find out if you're running into this issue, open the Javascript\nconsole in your browser and look for a  Content-Security-Policy \nviolation. If you see a message about navigation being blocked, then\nvery likely you are seeing this error.  If possible, configure the app to use a base URL of  '' , literally\nthe empty string. Then it will send HTTP redirects without\nspecifying a base URL. If that isn't possible, Sandstorm apps should\nlook at the  Sandstorm apps should look at the  Host:  header for a base URL if\nthey need one.", 
            "title": "A blank white screen renders where the app should be"
        }, 
        {
            "location": "/developing/troubleshooting/#keyerror-getpwuid-uid-not-found-1000", 
            "text": "This is a Python bug. See  the Python packaging guide  for a work-around.", 
            "title": "KeyError: 'getpwuid(): uid not found: 1000'"
        }, 
        {
            "location": "/developing/troubleshooting/#erofs-or-read-only-filesystem", 
            "text": "Only the  /var  directory is writable; the rest of the filesystem (which contains the contents of your app package) is read-only.  If your app wants to write to locations other than  /var , and it's not easy to change the app's code, one work-around is to create a symlink from the location you app wants to modify to a location under  /var .  This won't work for all applications however.", 
            "title": "EROFS or \"Read-only filesystem\""
        }, 
        {
            "location": "/developing/raw-packaging-guide/", 
            "text": "Raw packaging guide\n\n\nThis tutorial will show you how to package an app for Sandstorm using\nthe raw \nspk\n tooling, helping you understand Sandstorm at a deeper\nlevel.\n\n\nNote:\n If you're new to Sandstorm packaging, or don't run Linux as\nyour main operating system, please read the \nFive minute packaging\ntutorial\n first!\n\n\nA Sandstorm application package includes the entire userspace needed\nto run your app, including all binaries, libraries, modules,\netc. Normally, figuring out exactly what to put in a package could be\ntedious. Sandstorm makes it easy by employing a trick: it watches your\nserver running on your development machine and pulls in all the files\nthe server uses.\n\n\nLet's walk through an example.\n\n\n(If you get stuck, see \nPackaging Troubleshooting\n.)\n\n\nPrerequisites\n\n\n\n\nLearn about Sandstorm, if you haven't already.\n\n\nTry using Sandstorm\n to get a feel for how it operates.\n\n\n\n\nRead the App Developer Handbook\n to understand the higher-level design issues faced by Sandstorm apps.\n\n\n\n\n\n\nInstall Sandstorm on your local machine.\n\n\n\n\nInstall Linux. Kernel version 3.13 or later. \nUbuntu\n 14.04 is sufficient.\n\n\nInstall Sandstorm: \ncurl https://install.sandstorm.io | bash\n\n\nYou will use this local Sandstorm server for development, so make sure it's running.\n\n\nMake sure to make yourself a member of the server's group, usually called \nsandstorm\n.\n  You may have to log out and back in before this takes effect.\n\n\n\n\n\n\n\n\nFramework-specific tools/guides\n\n\nFor some frameworks, we have special tools and/or guides to help you package apps more easily:\n\n\n\n\nMeteor\n: Use \nmeteor-spk\n.\n\n\nPython: See \nPython\n.\n\n\nRuby on Rails: See \nRuby on Rails\n.\n\n\nPure-client/browser-side: (e.g. \nUnhosted\n-style) See \nPure client apps\n.\n\n\n(more soon)\n\n\n\n\nEven if your framework is listed above, you should still read everything on this page as well in order to better understand Sandstorm.\n\n\nGeneric steps\n\n\nWrite an app\n\n\nYou can write your app on absolutely any tech stack that runs on Linux. Write a web app the way you normally would. Make sure it stores all data under \n/var\n, because the rest of the filesystem will be read-only when running in Sandstorm.\n\n\nFor the sake of this tutorial, we'll use this simple \nNode.js\n app, which will call \nmain.js\n:\n\n\nvar http = require('http');\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n}).listen(10000, '127.0.0.1');\nconsole.log('Server running at http://127.0.0.1:10000/');\n\n\n\nMake sure you have Node installed, so that this app runs when you type:\n\n\nnode main.js\n\n\n\nCreate a Sandstorm package definition\n\n\nIn your app's source directory, type:\n\n\nspk init -p 10000 -- node main.js\n\n\n\nThis tells Sandstorm that the command to start your app is \nnode main.js\n and that it can then connect to the HTTP interface on port 10000.\n\n\nThis command will write the file \nsandstorm-pkgdef.capnp\n capturing the new configuration. Feel free to open it up and see what has been written. You can adjust a lot of things here.\n\n\nTest your app in dev mode\n\n\nAgain in your package directory, type:\n\n\nspk dev\n\n\n\nThis command temporarily registers your app with your locally-installed Sandstorm server. If you browse to your server and look at your files menu, you'll now see that your app is available there and you can create a new instance. Do so, and make sure it works.\n\n\nWhile in dev mode, make sure to test \nall\n of the features of your app. Sandstorm is watching what your app does and is making a list of all of your app's runtime dependencies, so it can make a package out of them. If you don't test a feature in dev mode, it might not work in production.\n\n\nYour app's console (debug) output can be viewed by clicking the wrench icon in the top bar.\n\n\nIf something is not working and your own debug logs aren't helping, you may also want to check the Sandstorm server's main logs in:\n\n\n/opt/sandstorm/var/log/sandstorm.log\n\n\n\nWhen done testing, press \nCtrl+C\n at your terminal to exit dev mode.\n\n\nInspect the file list\n\n\nThe \nspk\n tool has created a text file called \nsandstorm-files.list\n listing all the files used by your app. Open it in a text editor and verify that it looks reasonable. You may in particular want to verify that it hasn't pulled in any personal files from your system, although the default configuration hides \n/home\n and \n/var\n which should stop most leaks. If any files look wrong, you should remove them from the list, and then edit \nsandstorm-pkgdef.capnp\n to list those files as \"hidden\" so that they don't get re-added to the list the next time you run in dev mode. You should probably also re-run \nspk dev\n and test your app again.\n\n\nPay particular attention to files taken from \n/etc\n. Unfortunately, many apps rely on configuration found it \n/etc\n for basic operation, but files in \n/etc\n are often fairly specific to your host system and thus may not belong in your app package. If you want to override a file from \n/etc\n that your app needs, simply create at \netc\n directory in your source tree and put a different version of the file there. The default \nsandstorm-pkgdef.capnp\n maps \n.\n over \n/\n, so it will prefer \n./etc/foo\n over \n/etc/foo\n to satisfy a requirement for \netc/foo\n.\n\n\nBuild your package\n\n\nType:\n\n\nspk pack my-app.spk\n\n\n\nThis will build \nmy-app.spk\n for distribution. You can upload this to any Sandstorm server by going to the \n/install\n URL.\n\n\nPublish your app\n\n\nIf you packaged a cool app to Sandstorm, \nwe want to know about it\n!\n\n\nYou should check out the \napp publishing guide\n for details on how to submit your app to the \nApp Market\n.\n\n\nTips and Tricks\n\n\nAccessing external resources\n\n\nBy default, your app does not have network access, even on the server side. It can only answer HTTP request from the user. If you need access to things in the outside world, you will have to request them through the Sandstorm APIs. Guides for accessing specific kinds of external resources -- including sending outgoing HTTP requests, sending and receiving e-mail, etc. -- can be found \nin the full developer documentation\n.\n\n\nReproducible builds\n\n\nThe approach described above of copying files directly off your development machine is great for getting up-and-running quickly, but not great for long-term maintenance. As your project gets more serious, you'll want to think about setting up a hermetic build environment that other developers can easily reproduce.\n\n\nBy editing \nsandstorm-pkgdef.capnp\n, you can tell Sandstorm not to look for files on your actual host system, but rather look in some other directory that you set up yourself. So, you could create a clean \"chroot\" environment inside a separate directory, then tell Sandstorm to look for files there. The details of how to set up chroot environments are beyond the scope of this document, but are already widely-understood and not specific to Sandstorm. \nTry Googling it.\n\n\nTesting updates\n\n\nWhen you later make changes to your app, you can test it against existing data created with an older version. Whenever you run \nspk dev\n, the development version of the app will temporarily override any installed version, even when opening preexisting files.\n\n\nKeyrings\n\n\nYour app package is cryptographically signed (using Ed25519, if you care). The public key acts as the application's global ID. All packages signed with the same key represent different releases of the same app.\n\n\nWhen you ran \nspk init\n, Sandstorm created a new keypair for you. You can see your app's ID in \nsandstorm-pkgdef.capnp\n. The corresponding private key was placed on your Sandstorm keyring, which by default is stored at \n$HOME/.sandstorm-keyring\n. You need to keep this file safe! If you lose it, you won't be able to build updates of your app, and if someone steals it, they'll be able to publish updates for your app.\n\n\nWhen running in dev mode (\nspk dev\n), the keyring is not actually needed. Since you're publishing on a local server over which you have complete control anyway, the server just trusts the ID you give it. This means that you need not distribute your private key to every developer working on your app. Only the person building releases needs to have the key.\n\n\nKeyrings can be merged by concatenating them (with plain old \ncat\n). To pull specific keys out of your keyring to send to people, use the \nspk getkey\n command (type \nspk help getkey\n for usage information).\n\n\nCurrently, keyrings are not encrypted, which means they are vulnerable to any software running under your user account. This is probably bad and will be improved eventually, though in general if you have malware running as yourself then you're pretty screwed already.\n\n\nPackage IDs\n\n\nYou can get your data-package-id by running the following command:\n\n\nsha256sum package.spk | head -c 32; echo\n\n\n\nThis is no longer particularly important info now that the app market has launched, and this is handled automatically.\n\n\nWhat makes a good Sandstorm app?\n\n\nNot every web app makes sense as a Sandstorm app. Sandstorm is specifically intended for apps that store data which is logically owned by users. Each instance of an app is owned by an individual end user -- \nnot\n the app's developer. The user may share their instance with other users and collaborate, but ultimately each instance belongs to an individual.\n\n\nThings that make sense as Sandstorm apps:\n\n\n\n\nDocument editors, spreadsheets, and similar content creation.\n\n\nE-mail/chat/communications.\n\n\nCalendars, to-do lists, personal task management.\n\n\nRSS readers.\n\n\nPersonal file/media storage.\n\n\nBlogging apps (including microblogging).\n\n\nPersonal profiles.\n\n\nFederated social networks.\n\n\n\n\nThings that do not make sense as Sandstorm apps:\n\n\n\n\nPublic search engines.\n\n\nNews portals.\n\n\nLarge discussion forums (although a federated forum where each user owns the threads they created could make sense).\n\n\nContent distribution services.\n\n\nStorefronts.\n\n\nCentralized social networks.\n\n\n\n\nUsers can create multiple instances of any app they install. Each instance is, by default, isolated from the others, and can be independently shared. Apps should strive to implement instances with a level of granularity that makes sharing make sense. For example, a document editor app should host every document in a separate instance, so that users can use the Sandstorm platform's sharing features to share access to their documents.", 
            "title": "Raw packaging guide"
        }, 
        {
            "location": "/developing/raw-packaging-guide/#raw-packaging-guide", 
            "text": "This tutorial will show you how to package an app for Sandstorm using\nthe raw  spk  tooling, helping you understand Sandstorm at a deeper\nlevel.  Note:  If you're new to Sandstorm packaging, or don't run Linux as\nyour main operating system, please read the  Five minute packaging\ntutorial  first!  A Sandstorm application package includes the entire userspace needed\nto run your app, including all binaries, libraries, modules,\netc. Normally, figuring out exactly what to put in a package could be\ntedious. Sandstorm makes it easy by employing a trick: it watches your\nserver running on your development machine and pulls in all the files\nthe server uses.  Let's walk through an example.  (If you get stuck, see  Packaging Troubleshooting .)", 
            "title": "Raw packaging guide"
        }, 
        {
            "location": "/developing/raw-packaging-guide/#prerequisites", 
            "text": "Learn about Sandstorm, if you haven't already.  Try using Sandstorm  to get a feel for how it operates.   Read the App Developer Handbook  to understand the higher-level design issues faced by Sandstorm apps.    Install Sandstorm on your local machine.   Install Linux. Kernel version 3.13 or later.  Ubuntu  14.04 is sufficient.  Install Sandstorm:  curl https://install.sandstorm.io | bash  You will use this local Sandstorm server for development, so make sure it's running.  Make sure to make yourself a member of the server's group, usually called  sandstorm .\n  You may have to log out and back in before this takes effect.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/developing/raw-packaging-guide/#framework-specific-toolsguides", 
            "text": "For some frameworks, we have special tools and/or guides to help you package apps more easily:   Meteor : Use  meteor-spk .  Python: See  Python .  Ruby on Rails: See  Ruby on Rails .  Pure-client/browser-side: (e.g.  Unhosted -style) See  Pure client apps .  (more soon)   Even if your framework is listed above, you should still read everything on this page as well in order to better understand Sandstorm.", 
            "title": "Framework-specific tools/guides"
        }, 
        {
            "location": "/developing/raw-packaging-guide/#generic-steps", 
            "text": "Write an app  You can write your app on absolutely any tech stack that runs on Linux. Write a web app the way you normally would. Make sure it stores all data under  /var , because the rest of the filesystem will be read-only when running in Sandstorm.  For the sake of this tutorial, we'll use this simple  Node.js  app, which will call  main.js :  var http = require('http');\nhttp.createServer(function (req, res) {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n}).listen(10000, '127.0.0.1');\nconsole.log('Server running at http://127.0.0.1:10000/');  Make sure you have Node installed, so that this app runs when you type:  node main.js  Create a Sandstorm package definition  In your app's source directory, type:  spk init -p 10000 -- node main.js  This tells Sandstorm that the command to start your app is  node main.js  and that it can then connect to the HTTP interface on port 10000.  This command will write the file  sandstorm-pkgdef.capnp  capturing the new configuration. Feel free to open it up and see what has been written. You can adjust a lot of things here.  Test your app in dev mode  Again in your package directory, type:  spk dev  This command temporarily registers your app with your locally-installed Sandstorm server. If you browse to your server and look at your files menu, you'll now see that your app is available there and you can create a new instance. Do so, and make sure it works.  While in dev mode, make sure to test  all  of the features of your app. Sandstorm is watching what your app does and is making a list of all of your app's runtime dependencies, so it can make a package out of them. If you don't test a feature in dev mode, it might not work in production.  Your app's console (debug) output can be viewed by clicking the wrench icon in the top bar.  If something is not working and your own debug logs aren't helping, you may also want to check the Sandstorm server's main logs in:  /opt/sandstorm/var/log/sandstorm.log  When done testing, press  Ctrl+C  at your terminal to exit dev mode.  Inspect the file list  The  spk  tool has created a text file called  sandstorm-files.list  listing all the files used by your app. Open it in a text editor and verify that it looks reasonable. You may in particular want to verify that it hasn't pulled in any personal files from your system, although the default configuration hides  /home  and  /var  which should stop most leaks. If any files look wrong, you should remove them from the list, and then edit  sandstorm-pkgdef.capnp  to list those files as \"hidden\" so that they don't get re-added to the list the next time you run in dev mode. You should probably also re-run  spk dev  and test your app again.  Pay particular attention to files taken from  /etc . Unfortunately, many apps rely on configuration found it  /etc  for basic operation, but files in  /etc  are often fairly specific to your host system and thus may not belong in your app package. If you want to override a file from  /etc  that your app needs, simply create at  etc  directory in your source tree and put a different version of the file there. The default  sandstorm-pkgdef.capnp  maps  .  over  / , so it will prefer  ./etc/foo  over  /etc/foo  to satisfy a requirement for  etc/foo .  Build your package  Type:  spk pack my-app.spk  This will build  my-app.spk  for distribution. You can upload this to any Sandstorm server by going to the  /install  URL.  Publish your app  If you packaged a cool app to Sandstorm,  we want to know about it !  You should check out the  app publishing guide  for details on how to submit your app to the  App Market .", 
            "title": "Generic steps"
        }, 
        {
            "location": "/developing/raw-packaging-guide/#tips-and-tricks", 
            "text": "Accessing external resources  By default, your app does not have network access, even on the server side. It can only answer HTTP request from the user. If you need access to things in the outside world, you will have to request them through the Sandstorm APIs. Guides for accessing specific kinds of external resources -- including sending outgoing HTTP requests, sending and receiving e-mail, etc. -- can be found  in the full developer documentation .  Reproducible builds  The approach described above of copying files directly off your development machine is great for getting up-and-running quickly, but not great for long-term maintenance. As your project gets more serious, you'll want to think about setting up a hermetic build environment that other developers can easily reproduce.  By editing  sandstorm-pkgdef.capnp , you can tell Sandstorm not to look for files on your actual host system, but rather look in some other directory that you set up yourself. So, you could create a clean \"chroot\" environment inside a separate directory, then tell Sandstorm to look for files there. The details of how to set up chroot environments are beyond the scope of this document, but are already widely-understood and not specific to Sandstorm.  Try Googling it.  Testing updates  When you later make changes to your app, you can test it against existing data created with an older version. Whenever you run  spk dev , the development version of the app will temporarily override any installed version, even when opening preexisting files.  Keyrings  Your app package is cryptographically signed (using Ed25519, if you care). The public key acts as the application's global ID. All packages signed with the same key represent different releases of the same app.  When you ran  spk init , Sandstorm created a new keypair for you. You can see your app's ID in  sandstorm-pkgdef.capnp . The corresponding private key was placed on your Sandstorm keyring, which by default is stored at  $HOME/.sandstorm-keyring . You need to keep this file safe! If you lose it, you won't be able to build updates of your app, and if someone steals it, they'll be able to publish updates for your app.  When running in dev mode ( spk dev ), the keyring is not actually needed. Since you're publishing on a local server over which you have complete control anyway, the server just trusts the ID you give it. This means that you need not distribute your private key to every developer working on your app. Only the person building releases needs to have the key.  Keyrings can be merged by concatenating them (with plain old  cat ). To pull specific keys out of your keyring to send to people, use the  spk getkey  command (type  spk help getkey  for usage information).  Currently, keyrings are not encrypted, which means they are vulnerable to any software running under your user account. This is probably bad and will be improved eventually, though in general if you have malware running as yourself then you're pretty screwed already.  Package IDs  You can get your data-package-id by running the following command:  sha256sum package.spk | head -c 32; echo  This is no longer particularly important info now that the app market has launched, and this is handled automatically.  What makes a good Sandstorm app?  Not every web app makes sense as a Sandstorm app. Sandstorm is specifically intended for apps that store data which is logically owned by users. Each instance of an app is owned by an individual end user --  not  the app's developer. The user may share their instance with other users and collaborate, but ultimately each instance belongs to an individual.  Things that make sense as Sandstorm apps:   Document editors, spreadsheets, and similar content creation.  E-mail/chat/communications.  Calendars, to-do lists, personal task management.  RSS readers.  Personal file/media storage.  Blogging apps (including microblogging).  Personal profiles.  Federated social networks.   Things that do not make sense as Sandstorm apps:   Public search engines.  News portals.  Large discussion forums (although a federated forum where each user owns the threads they created could make sense).  Content distribution services.  Storefronts.  Centralized social networks.   Users can create multiple instances of any app they install. Each instance is, by default, isolated from the others, and can be independently shared. Apps should strive to implement instances with a level of granularity that makes sharing make sense. For example, a document editor app should host every document in a separate instance, so that users can use the Sandstorm platform's sharing features to share access to their documents.", 
            "title": "Tips and Tricks"
        }, 
        {
            "location": "/developing/raw-python/", 
            "text": "Python and raw Sandstorm\n\n\nIf you're interested in integrating Python with raw Sandstorm APIs and\ngenerating SPK files by hand, here is a brief collection of information\nyou will need to know.\n\n\nNote\n: This highly-technical documentation explains the inner\nworkings of Python on Sandstorm. If you want to package a Python web\napp for Sandstorm, and would like a well-tested and well-documented\nway to do that, read the \nfive minute vagrant-spk packaging\ntutorial\n instead!\n\n\nIntegrating with raw Sandstorm APIs\n\n\nTo use raw Sandstorm Cap'n Proto APIs, you can use\n\npycapnp\n.\n\n\nPackaging gotchas\n\n\nKeyError: 'getpwuid(): uid not found: 1000'\n\n\nDue to a \nbug in Python\n, an exception will be thrown at startup if Python can't determine the current uid's home directory. In general, the concept of a \"home directory\" does not make sense in Sandstorm.\n\n\nThis can be worked around by defining the \nHOME\n environment variable in \nsandstorm-pkgdef.capnp\n. Look for the \nenviron\n field and add \nHOME\n to it like so:\n\n\nenviron = [\n    # Note that this defines the *entire* environment seen by your app.\n    (key = \"PATH\", value = \"/usr/local/bin:/usr/bin:/bin\"),\n    (key = \"HOME\", value = \"/var\")\n  ]", 
            "title": "Raw integration of Python"
        }, 
        {
            "location": "/developing/raw-python/#python-and-raw-sandstorm", 
            "text": "If you're interested in integrating Python with raw Sandstorm APIs and\ngenerating SPK files by hand, here is a brief collection of information\nyou will need to know.  Note : This highly-technical documentation explains the inner\nworkings of Python on Sandstorm. If you want to package a Python web\napp for Sandstorm, and would like a well-tested and well-documented\nway to do that, read the  five minute vagrant-spk packaging\ntutorial  instead!", 
            "title": "Python and raw Sandstorm"
        }, 
        {
            "location": "/developing/raw-python/#integrating-with-raw-sandstorm-apis", 
            "text": "To use raw Sandstorm Cap'n Proto APIs, you can use pycapnp .", 
            "title": "Integrating with raw Sandstorm APIs"
        }, 
        {
            "location": "/developing/raw-python/#packaging-gotchas", 
            "text": "KeyError: 'getpwuid(): uid not found: 1000'  Due to a  bug in Python , an exception will be thrown at startup if Python can't determine the current uid's home directory. In general, the concept of a \"home directory\" does not make sense in Sandstorm.  This can be worked around by defining the  HOME  environment variable in  sandstorm-pkgdef.capnp . Look for the  environ  field and add  HOME  to it like so:  environ = [\n    # Note that this defines the *entire* environment seen by your app.\n    (key = \"PATH\", value = \"/usr/local/bin:/usr/bin:/bin\"),\n    (key = \"HOME\", value = \"/var\")\n  ]", 
            "title": "Packaging gotchas"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/", 
            "text": "Raw integration guide for Ruby on Rails apps on Sandstorm\n\n\nNote\n: This highly-technical documentation explains the inner\nworkings of Ruby on Rails on Sandstorm. If you want to package a Rails\napp for Sandstorm, consider reading the \nfive minute vagrant-spk\npackaging tutorial\n instead, and\nusing the \nDIY stack\n.\n\n\nIntroduction\n\n\nThis guide collects some wisdom\ngained from working on Sandstorm ports of\n\nGitLab\n\nand \nLobsters\n.\nIf you want to see the concrete details\nin action, you should explore those repositories.\nIn fact, cloning\n\nlobsters-sandstorm\n\nwould probably give you a decent good starting point\nfor doing your own app port.\n\n\nThis guide assumes that you are familiar with the basics of raw\npackaging of Sandstorm apps, as outlined in the \nraw packaging\nguide\n.\n\n\nSome of the information here might also be useful for\nporting non-Rails Ruby apps.\n\n\nRuby installation\n\n\nWe want to install Ruby in such a way that:\n\n\n\n\nWe have precise control over which version is installed.\n\n\nThe installation path is the same on our development system as it will be in the packaged app.\n     (Ruby installations tend not to deal well with getting relocated.)\n\n\nWe don't need to include our home directory in the packaged app.\n\n\n\n\nWe can satisfy these constraints by installing either\n\nRBenv\n\nor \nRVM\n in \n/usr/local\n.\n\n\nRBenv / Ruby-Build\n\n\nRBenv can be installed following steps like these:\n\n\n$ sudo git clone https://github.com/sstephenson/rbenv.git /usr/local/rbenv\n$ sudo git clone https://github.com/sstephenson/ruby-build.git /usr/local/rbenv/plugins/ruby-build\n$ sudo groupadd rbenv\n$ sudo usermod -a -G rbenv `whoami`\n$ sudo chgrp -R rbenv /usr/local/rbenv\n$ sudo chmod -R g=rwx /usr/local/rbenv\n\n\n\n\nTo activate it, you'll need to add this to your \n~/.bashrc\n:\n\n\nexport RBENV_ROOT=/usr/local/rbenv\nexport PATH=\n$RBENV_ROOT/bin:$PATH\n\neval \n$(rbenv init -)\n\n\n\n\n\nNow install the ruby needed by your app. For example,\n\n\n$ rbenv install 2.1.5\n\n\n\n\nRVM\n\n\nRVM should work too, but we haven't tested it.\n\n\nNote that relative RPATHs currently\n\ndon't work on Sandstorm\n,\nwhich means that you won't be able to use RVM's binary Ruby distributions.\nYou can work around this by making sure\nto build Ruby from source, e.g.\n\n\n$ rvm install 2.1.5 --disable-binary\n\n\n\n\nProject Setup\n\n\nDirectory Structure\n\n\nTo cleanly separate concerns,\nwe recommend that you start a new Git repository\nthat brings in the original project as a subdirectory.\nFor example, in our Lobsters port,\nwe created a \nnew repo\n\ncalled \"lobsters-sandstorm\",\ncontaining a \nMakefile\n\nwith a recipe that \ngit clone\ns our\n\nfork of the original Lobsters repo\n.\n\n\nSymlinks\n\n\nRails projects have a standard directory structure,\nwith subdirectories including \napp/\n, \nconfig/\n, \npublic/\n,\nand others.\nOf these, \ntmp/\n and \nlog/\n are notable\nin that they need to be writable at run time.\nTo allow these to function in a packaged Sandstorm\napp, you'll need to add them as symlinks, e.g.:\n\n\n$ ln -s /tmp tmp\n$ ln -s /var/log log\n\n\n\n\nNote that the \n/tmp\n directory mounted for apps\nhas a limited capacity, currently 16MB per\napp instance.\n\n\nDatabase Configuration\n\n\nActiveRecord conveniently allows us to use SQLite,\nwhich, for Sandstorm apps, is usually a much better fit\nthan MySQL and PostgreSQL.\nTo use it, make sure that your \nGemfile\n includes\nthe \"sqlite3\" gem, and make sure\nyour \nconfig/database.yml\n looks something like:\n\n\nproduction:\n  adapter: sqlite3\n  pool: 5\n  timeout: 5000\n  database: /var/sqlite3/db.sqlite3\n\n\n\n\nIt might also make sense to\ninclude an initialized database\nas part of the packaged app,\nso that your start script\ncan just copy it over to writable storage\nwhen the app first boots.\n\n\ngems\n\n\nMake sure you have Bundler installed:\n\n\n$ gem install bundler\n\n\n\n\nNow you can install your project's dependencies.\nIt's best to put them in a local directory, like this:\n\n\n$ bundle install --path .bundle --without test development\n\n\n\n\nRuby PATH\n\n\nIn your app, it's best to avoid the\nfancy shell setup code that RVM and RBenv\ntypically rely on. Instead, you should\ndirectly use whatever Ruby binary you need.\nFor example, if you are using RBenv and Ruby 2.1.5, this would\nentail adding \n/usr/local/rbenv/versions/2.1.5/bin\n to your \nPATH\n.\n\n\nSession Secret\n\n\nTo freshly generate a new secret on each\nstartup of the app, and pass it in through an environment variable,\nmake sure that you have a \nconfig/secrets.yml\n like this:\n\n\nproduction:\n  secret_key_base: \n%= ENV[\nSECRET_KEY_BASE\n] %\n\n\n\n\n\nand that you add a line like this to your startup scripts:\n\n\nexport SECRET_KEY_BASE=`base64 /dev/urandom | head -c 30`\n\n\n\n\nPrecompile Assets\n\n\nMake sure that your \nconfig/environments/production.rb\n is configured like this:\n\n\nconfig.serve_static_assets = true # serve the precompiled assets\nconfig.assets.compile = false     # don't try to compile assets on the fly\n\nconfig.assets.configure do |env|\n  # override the default location of tmp/cache/assets\n  env.cache = ActiveSupport::Cache::FileStore.new(\nread-only-cache/assets\n)\nend\n\n\n\n\nNow running this command\n\n\n$ RAILS_ENV=production ./bin/rake assets:precompile\n\n\n\n\nshould generate assets in \nread-only-cache/assets\n and \npublic/assets\n.\n\n\nLogin\n\n\nSandstorm can handle login for your app.\nIt proxies all requests and inserts special headers\nindicating the name and ID of authenticated users.\nHow you use this information depends on your app's\nauthentication scheme and User model.\n\n\nDevise\n\n\nDevise\n\nis a authentication library commonly used by Rails apps.\nIt has a mechanism for adding pluggable authentication shemes\ncalled \"strategies\". To hook into it, you can add something\nlike this to \nconfig/initializers/sandstorm_strategy.rb\n:\n\n\nmodule Devise\n  module Strategies\n    class Sandstorm \n Authenticatable\n      def authenticate!\n        userid = request.headers['HTTP_X_SANDSTORM_USER_ID'].encode(Encoding::UTF_8)\n        username = URI.unescape(request.headers['HTTP_X_SANDSTORM_USERNAME']).force_encoding(Encoding::UTF_8)\n        u = User.where(username: userid).first\n        if !u\n          opts = {}\n          opts[:name] = username\n          opts[:id] = userid\n          u = User.new(opts)\n          if u.save\n            Rails.logger.info 'User was successfully created.'\n          else\n            Rails.logger.error 'User could not be created'\n            Rails.logger.error u.errors\n          end\n        end\n\n        success!(u)\n      end\n      def valid?\n        !!request.headers['HTTP_X_SANDSTORM_USER_ID']\n      end\n    end\n  end\nend\n\n\n\n\nAnd then edit \nconfig/initializers/devise.rb\n to have the following block somewhere in \nDevise.setup\n:\n\n\nDevise.setup do |config|\n  ...\n  config.warden do |manager|\n    manager.intercept_401 = false\n    manager.strategies.add(:sandstorm, Devise::Strategies::Sandstorm)\n    manager.default_strategies(:scope =\n :user).unshift :sandstorm\n  end\nend\n\n\n\n\nBoot Time\n\n\nRails apps are not typically optimized for startup time.\nHowever, fast startup is very important\nfor Sandstorm apps, because they are aggressively spun down when not in use.\nWorse, Ruby's strategy for loading gems\ndoes not interact well with \nspk dev\n, so startup times\nin development mode can get quite long -- sometimes on the order of minutes.\n\n\nYou have a few ways to deal with this.\n\n\nThe first is to remove dependencies that don't make\nsense for a Sandstorm port.\nFor example, any gems that handle authentication can\nbe removed, because you're just going to rely on Sandstorm for authentication.\nThis includes omniauth, rack-attack and oauth gems.\nAlso, you can probably do away with fancier web servers like\nUnicorn and Thin; WEBrick ought to work just fine for a Sandstorm app.\n\n\nIf your app uses a task runner like Foreman,\nit might be adding a full second to your (non-dev-mode) startup time!\nIt's more efficient to launch your processes from startup shell scripts,\nand maybe append something like\n\n2\n1 | awk '{print \"sidekiq: \" $0}'\n\nso you can distinguish the log output.\n\n\nbundle exec\n is also somewhat expensive, and all that it does is populate\nenvironment variables.\n\n\nIf you're feeling particularly ambitious, you could\ntry to eliminate entirely your app's runtime dependency on Bundler,\nas discussed in \nthis blog post\n.\nIf you're feeling even more ambitious, you could develop a general tool\nthat statically does what Bundler.setup and Bundler.require do dynamically.\n\n\nFinally, you should realize that you don't need to do all your\ndevelopment through \nspk dev\n. If you \nspk pack\n and install your\napp, you can still edit the code in-place in the \nvar/sandstorm/apps/\npkdId\n\ndirectory where it was installed.\n\n\nMiscellany\n\n\nReferer header\n\n\nSandstorm does not forward the \nReferer\n header,\nso things like \nredirect_to :back\n will fail.\n\n\nAccept header\n\n\nThe \nX-Requested-With\n header is not on Sandstorm's whitelist of headers to\nforward. This can confuse Rails in some cases. You may find it useful\nto add this monkey patch as \nconfig/initializers/sandstorm_accept_header.rb\n:\n\n\n# For obscure reasons, if Rails gets an XMLHttpRequest with an Accept header like\n# \napplication/json, text/javascript, */*; q=0.01\n and does not get an\n# X-Requested-With header, it will report that HTML is the desired format in calls\n# to `respond_to`. This monkey patch should fix the problem. I think the worst\n# possible side effect is that certain old browsers might display some content wrong.\nmodule ActionDispatch\n  module Http\n    module MimeNegotiation\n      def valid_accept_header\n        true\n      end\n    end\n  end\nend\n\n\n\n\nJavascript Runtime\n\n\nThe execjs gem wants a javascript runtime to exist on startup.\nIf you precompile your assets,\nthere's a good chance that you don't actually\nneed a javascript runtime in your packaged app.\nIn that case, you can get away with adding an empty \nusr/bin/node\n file\nto your app, just to appease execjs. (Note that the file has to be marked\nexecutable.)\n\n\nFor example, in your source directory, do:\n\n\ntouch empty-file\nchmod +x empty-file\n\n\n\nThen add this to your \nsearchPath\n in \nsandstorm-pkgdef.capnp\n:\n\n\n(sourcePath = \"empty-file\", packagePath = \"usr/bin/node\"),\n\n\n\nMigrations\n\n\nLogically, we want to do \nrake db:migrate\n every time we start up the app,\nbut that might be really expensive.\nInstead, your app should write its version somewhere\nand invoke \nrake db:migrate\n only when it detects a change.", 
            "title": "Raw integration of Ruby on Rails"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#raw-integration-guide-for-ruby-on-rails-apps-on-sandstorm", 
            "text": "Note : This highly-technical documentation explains the inner\nworkings of Ruby on Rails on Sandstorm. If you want to package a Rails\napp for Sandstorm, consider reading the  five minute vagrant-spk\npackaging tutorial  instead, and\nusing the  DIY stack .", 
            "title": "Raw integration guide for Ruby on Rails apps on Sandstorm"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#introduction", 
            "text": "This guide collects some wisdom\ngained from working on Sandstorm ports of GitLab \nand  Lobsters .\nIf you want to see the concrete details\nin action, you should explore those repositories.\nIn fact, cloning lobsters-sandstorm \nwould probably give you a decent good starting point\nfor doing your own app port.  This guide assumes that you are familiar with the basics of raw\npackaging of Sandstorm apps, as outlined in the  raw packaging\nguide .  Some of the information here might also be useful for\nporting non-Rails Ruby apps.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#ruby-installation", 
            "text": "We want to install Ruby in such a way that:   We have precise control over which version is installed.  The installation path is the same on our development system as it will be in the packaged app.\n     (Ruby installations tend not to deal well with getting relocated.)  We don't need to include our home directory in the packaged app.   We can satisfy these constraints by installing either RBenv \nor  RVM  in  /usr/local .  RBenv / Ruby-Build  RBenv can be installed following steps like these:  $ sudo git clone https://github.com/sstephenson/rbenv.git /usr/local/rbenv\n$ sudo git clone https://github.com/sstephenson/ruby-build.git /usr/local/rbenv/plugins/ruby-build\n$ sudo groupadd rbenv\n$ sudo usermod -a -G rbenv `whoami`\n$ sudo chgrp -R rbenv /usr/local/rbenv\n$ sudo chmod -R g=rwx /usr/local/rbenv  To activate it, you'll need to add this to your  ~/.bashrc :  export RBENV_ROOT=/usr/local/rbenv\nexport PATH= $RBENV_ROOT/bin:$PATH \neval  $(rbenv init -)   Now install the ruby needed by your app. For example,  $ rbenv install 2.1.5  RVM  RVM should work too, but we haven't tested it.  Note that relative RPATHs currently don't work on Sandstorm ,\nwhich means that you won't be able to use RVM's binary Ruby distributions.\nYou can work around this by making sure\nto build Ruby from source, e.g.  $ rvm install 2.1.5 --disable-binary", 
            "title": "Ruby installation"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#project-setup", 
            "text": "Directory Structure  To cleanly separate concerns,\nwe recommend that you start a new Git repository\nthat brings in the original project as a subdirectory.\nFor example, in our Lobsters port,\nwe created a  new repo \ncalled \"lobsters-sandstorm\",\ncontaining a  Makefile \nwith a recipe that  git clone s our fork of the original Lobsters repo .  Symlinks  Rails projects have a standard directory structure,\nwith subdirectories including  app/ ,  config/ ,  public/ ,\nand others.\nOf these,  tmp/  and  log/  are notable\nin that they need to be writable at run time.\nTo allow these to function in a packaged Sandstorm\napp, you'll need to add them as symlinks, e.g.:  $ ln -s /tmp tmp\n$ ln -s /var/log log  Note that the  /tmp  directory mounted for apps\nhas a limited capacity, currently 16MB per\napp instance.  Database Configuration  ActiveRecord conveniently allows us to use SQLite,\nwhich, for Sandstorm apps, is usually a much better fit\nthan MySQL and PostgreSQL.\nTo use it, make sure that your  Gemfile  includes\nthe \"sqlite3\" gem, and make sure\nyour  config/database.yml  looks something like:  production:\n  adapter: sqlite3\n  pool: 5\n  timeout: 5000\n  database: /var/sqlite3/db.sqlite3  It might also make sense to\ninclude an initialized database\nas part of the packaged app,\nso that your start script\ncan just copy it over to writable storage\nwhen the app first boots.  gems  Make sure you have Bundler installed:  $ gem install bundler  Now you can install your project's dependencies.\nIt's best to put them in a local directory, like this:  $ bundle install --path .bundle --without test development  Ruby PATH  In your app, it's best to avoid the\nfancy shell setup code that RVM and RBenv\ntypically rely on. Instead, you should\ndirectly use whatever Ruby binary you need.\nFor example, if you are using RBenv and Ruby 2.1.5, this would\nentail adding  /usr/local/rbenv/versions/2.1.5/bin  to your  PATH .  Session Secret  To freshly generate a new secret on each\nstartup of the app, and pass it in through an environment variable,\nmake sure that you have a  config/secrets.yml  like this:  production:\n  secret_key_base:  %= ENV[ SECRET_KEY_BASE ] %   and that you add a line like this to your startup scripts:  export SECRET_KEY_BASE=`base64 /dev/urandom | head -c 30`  Precompile Assets  Make sure that your  config/environments/production.rb  is configured like this:  config.serve_static_assets = true # serve the precompiled assets\nconfig.assets.compile = false     # don't try to compile assets on the fly\n\nconfig.assets.configure do |env|\n  # override the default location of tmp/cache/assets\n  env.cache = ActiveSupport::Cache::FileStore.new( read-only-cache/assets )\nend  Now running this command  $ RAILS_ENV=production ./bin/rake assets:precompile  should generate assets in  read-only-cache/assets  and  public/assets .", 
            "title": "Project Setup"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#login", 
            "text": "Sandstorm can handle login for your app.\nIt proxies all requests and inserts special headers\nindicating the name and ID of authenticated users.\nHow you use this information depends on your app's\nauthentication scheme and User model.  Devise  Devise \nis a authentication library commonly used by Rails apps.\nIt has a mechanism for adding pluggable authentication shemes\ncalled \"strategies\". To hook into it, you can add something\nlike this to  config/initializers/sandstorm_strategy.rb :  module Devise\n  module Strategies\n    class Sandstorm   Authenticatable\n      def authenticate!\n        userid = request.headers['HTTP_X_SANDSTORM_USER_ID'].encode(Encoding::UTF_8)\n        username = URI.unescape(request.headers['HTTP_X_SANDSTORM_USERNAME']).force_encoding(Encoding::UTF_8)\n        u = User.where(username: userid).first\n        if !u\n          opts = {}\n          opts[:name] = username\n          opts[:id] = userid\n          u = User.new(opts)\n          if u.save\n            Rails.logger.info 'User was successfully created.'\n          else\n            Rails.logger.error 'User could not be created'\n            Rails.logger.error u.errors\n          end\n        end\n\n        success!(u)\n      end\n      def valid?\n        !!request.headers['HTTP_X_SANDSTORM_USER_ID']\n      end\n    end\n  end\nend  And then edit  config/initializers/devise.rb  to have the following block somewhere in  Devise.setup :  Devise.setup do |config|\n  ...\n  config.warden do |manager|\n    manager.intercept_401 = false\n    manager.strategies.add(:sandstorm, Devise::Strategies::Sandstorm)\n    manager.default_strategies(:scope =  :user).unshift :sandstorm\n  end\nend", 
            "title": "Login"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#boot-time", 
            "text": "Rails apps are not typically optimized for startup time.\nHowever, fast startup is very important\nfor Sandstorm apps, because they are aggressively spun down when not in use.\nWorse, Ruby's strategy for loading gems\ndoes not interact well with  spk dev , so startup times\nin development mode can get quite long -- sometimes on the order of minutes.  You have a few ways to deal with this.  The first is to remove dependencies that don't make\nsense for a Sandstorm port.\nFor example, any gems that handle authentication can\nbe removed, because you're just going to rely on Sandstorm for authentication.\nThis includes omniauth, rack-attack and oauth gems.\nAlso, you can probably do away with fancier web servers like\nUnicorn and Thin; WEBrick ought to work just fine for a Sandstorm app.  If your app uses a task runner like Foreman,\nit might be adding a full second to your (non-dev-mode) startup time!\nIt's more efficient to launch your processes from startup shell scripts,\nand maybe append something like 2 1 | awk '{print \"sidekiq: \" $0}' \nso you can distinguish the log output.  bundle exec  is also somewhat expensive, and all that it does is populate\nenvironment variables.  If you're feeling particularly ambitious, you could\ntry to eliminate entirely your app's runtime dependency on Bundler,\nas discussed in  this blog post .\nIf you're feeling even more ambitious, you could develop a general tool\nthat statically does what Bundler.setup and Bundler.require do dynamically.  Finally, you should realize that you don't need to do all your\ndevelopment through  spk dev . If you  spk pack  and install your\napp, you can still edit the code in-place in the  var/sandstorm/apps/ pkdId \ndirectory where it was installed.", 
            "title": "Boot Time"
        }, 
        {
            "location": "/developing/raw-ruby-on-rails/#miscellany", 
            "text": "Referer header  Sandstorm does not forward the  Referer  header,\nso things like  redirect_to :back  will fail.  Accept header  The  X-Requested-With  header is not on Sandstorm's whitelist of headers to\nforward. This can confuse Rails in some cases. You may find it useful\nto add this monkey patch as  config/initializers/sandstorm_accept_header.rb :  # For obscure reasons, if Rails gets an XMLHttpRequest with an Accept header like\n#  application/json, text/javascript, */*; q=0.01  and does not get an\n# X-Requested-With header, it will report that HTML is the desired format in calls\n# to `respond_to`. This monkey patch should fix the problem. I think the worst\n# possible side effect is that certain old browsers might display some content wrong.\nmodule ActionDispatch\n  module Http\n    module MimeNegotiation\n      def valid_accept_header\n        true\n      end\n    end\n  end\nend  Javascript Runtime  The execjs gem wants a javascript runtime to exist on startup.\nIf you precompile your assets,\nthere's a good chance that you don't actually\nneed a javascript runtime in your packaged app.\nIn that case, you can get away with adding an empty  usr/bin/node  file\nto your app, just to appease execjs. (Note that the file has to be marked\nexecutable.)  For example, in your source directory, do:  touch empty-file\nchmod +x empty-file  Then add this to your  searchPath  in  sandstorm-pkgdef.capnp :  (sourcePath = \"empty-file\", packagePath = \"usr/bin/node\"),  Migrations  Logically, we want to do  rake db:migrate  every time we start up the app,\nbut that might be really expensive.\nInstead, your app should write its version somewhere\nand invoke  rake db:migrate  only when it detects a change.", 
            "title": "Miscellany"
        }, 
        {
            "location": "/developing/raw-pure-client-apps/", 
            "text": "Porting pure client apps\n\n\nApps which are designed to do all work on the client side (in the\nbrowser) are particularly easy to port to Sandstorm. Apps written in\nthe \nUnhosted\n style or using\n\nremoteStorage\n generally fall into this\ncategory.\n\n\nFor such apps, we recommend basing your server on our \nRaw API\nExample\n. In\nfact, you can likely fork that code and use it nearly verbatim; just\ndrop your client-side HTML, CSS, and Javascript into the \nclient\n\ndirectory and adjust your code to do storage via HTTP GET/PUT/DELETE\nrequests under \n/var\n.\n\n\nKeep in mind that each Sandstorm app instance should represent a\nsingle \"document\", or otherwise the minimal unit of data that a user\nmight want to share independently. So, if your app currently features\n\"save\" and \"load\" actions that ask for a location, remove that, and\ninstead automatically save to a hard-coded location under \n/var\n.\n\n\nCaveat: Collaboration\n\n\nThe down side of pure-client apps is that they are hard to make\ncollaborative. If multiple users open a file at once, they will likely\nclobber each other's changes. Once your app is on Sandstorm, you may\nwant to consider extending it for collaboration by implementing a\nWebSocket connection that receives an event stream from other\nclients. In the server code, you will need to extend \nWebSessionImpl\n\nto override the \nopenWebSocket()\n method of \nWebSession\n. Feel free to\nask \nsandstorm-dev\n if\nyou need help.", 
            "title": "Raw integration of pure client apps"
        }, 
        {
            "location": "/developing/raw-pure-client-apps/#porting-pure-client-apps", 
            "text": "Apps which are designed to do all work on the client side (in the\nbrowser) are particularly easy to port to Sandstorm. Apps written in\nthe  Unhosted  style or using remoteStorage  generally fall into this\ncategory.  For such apps, we recommend basing your server on our  Raw API\nExample . In\nfact, you can likely fork that code and use it nearly verbatim; just\ndrop your client-side HTML, CSS, and Javascript into the  client \ndirectory and adjust your code to do storage via HTTP GET/PUT/DELETE\nrequests under  /var .  Keep in mind that each Sandstorm app instance should represent a\nsingle \"document\", or otherwise the minimal unit of data that a user\nmight want to share independently. So, if your app currently features\n\"save\" and \"load\" actions that ask for a location, remove that, and\ninstead automatically save to a hard-coded location under  /var .", 
            "title": "Porting pure client apps"
        }, 
        {
            "location": "/developing/raw-pure-client-apps/#caveat-collaboration", 
            "text": "The down side of pure-client apps is that they are hard to make\ncollaborative. If multiple users open a file at once, they will likely\nclobber each other's changes. Once your app is on Sandstorm, you may\nwant to consider extending it for collaboration by implementing a\nWebSocket connection that receives an event stream from other\nclients. In the server code, you will need to extend  WebSessionImpl \nto override the  openWebSocket()  method of  WebSession . Feel free to\nask  sandstorm-dev  if\nyou need help.", 
            "title": "Caveat: Collaboration"
        }, 
        {
            "location": "/administering/", 
            "text": "Administering Sandstorm\n\n\nRunning Sandstorm on your own server\n\n\nThese documents help you get your own Sandstorm server set up the way you want it.\n\n\n\n\nInstalling\n: \nEasy way\n | \nHard way\n\n\nEmail\n: \nSending\n | \nReceiving (running an email server)\n\n\nDNS\n: \nSandcats.io dynamic DNS\n | \nWildcard hosts\n\n\nConfiguring\n: \nDemo mode\n | \nBackups\n \n\n\nTroubleshooting\n: \nSelf-hosting FAQ", 
            "title": "Overview"
        }, 
        {
            "location": "/administering/#administering-sandstorm", 
            "text": "", 
            "title": "Administering Sandstorm"
        }, 
        {
            "location": "/administering/#running-sandstorm-on-your-own-server", 
            "text": "These documents help you get your own Sandstorm server set up the way you want it.   Installing :  Easy way  |  Hard way  Email :  Sending  |  Receiving (running an email server)  DNS :  Sandcats.io dynamic DNS  |  Wildcard hosts  Configuring :  Demo mode  |  Backups    Troubleshooting :  Self-hosting FAQ", 
            "title": "Running Sandstorm on your own server"
        }, 
        {
            "location": "/install/", 
            "text": "Installation\n\n\nThere are many options for installing Sandstorm with various trade-offs. Choose the one that is most comfortable for you.\n\n\nSandstorm requires Linux x86_64, with kernel version 3.13 or later.\n\n\nOption 1: HTTPS-verified install\n\n\nThe easiest way to install Sandstorm is by running:\n\n\ncurl https://install.sandstorm.io | bash\n\n\n\n\nOption 2: GitHub-verified install\n\n\nIf you are uncomfortable with \ncurl|bash\n, another option is to \ndownload install.sh from our GitHub repository\n and then run it:\n\n\nwget https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/install.sh\nbash install.sh\n\n\n\n\nThis verifies that you're running our published installer script, even in the unlikely event that someone has compromised our download server or HTTPS certificate. The installer will verify signatures on all additional files it downloads.\n\n\nOption 3: PGP-verified install\n\n\nIf you'd rather not trust HTTPS at all, even from GitHub, another option is PGP-verified install.\n\n\n\n\n\n\nIf you aren't experienced with GPG already, let's do these instructions in a new empty workspace to avoid confusion. (If you know what you're doing, you can skip this.)\n\n\nexport GNUPGHOME=$(mktemp -d)\n\n\n\n\n\n\nDownload and import the Sandstorm releases keyring.\n\n\ncurl https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/keys/release-keyring.gpg | \\\n    gpg --import\n\n\n\n\n\n\nObtain the PGP key fingerprint of a Sandstorm developer you trust. There are several ways to do this:\n\n\n\n\nWeb of trust (for PGP experts).\n\n\nMeet us in person\n and ask for our business cards.\n\n\nUse our Keybase profiles, for example: \nKenton Varda (kentonv)\n, \nAsheesh Laroia (asheesh)\n, \nDrew Fisher (zarvox)\n\n\n\n\n\n\n\n\nDownload that developer's corresponding release key certificate \nfrom the Sandstorm github repo\n. For example, if you chose Kenton:\n\n\nwget https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/keys/release-certificate.kentonv.sig\n\n\n\n\n\n\nVerify the certificate with GPG. For example:\n\n\ngpg --decrypt release-certificate.kentonv.sig\n\n\nThe output looks something like (emphasis added):\n\n\nAs of September 2015, Sandstorm releases are signed with the PGP key with\nfingerprint 160D 2D57 7518 B58D 94C9  800B 63F2 2749 9DA8 CCBD. This assertion\nwill be updated monthly; do not trust this certificate after October 2015.\n\n\ngpg: Signature made Wed 23 Sep 2015 04:20:25 PM PDT using RSA key ID 440DDCF1\ngpg: Good signature from \"Kenton Varda \nkentonv@keybase.io\n\"\ngpg:                 aka \"Kenton Varda \ntemporal@gmail.com\n\"\ngpg:                 aka \"Kenton Varda \nkenton@sandstorm.io\n\"\ngpg:                 aka \"Kenton Varda \nkenton@kentonshouse.com\n\"\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.\n\n\nPrimary key fingerprint: 8802 23DF 25AA 25A9 433A  F0FB 4067 8458 440D DCF1\n\n\nRead the signed statement (top bolded part) and decide if it checks out, and make sure the fingerprint of the signer (bottom bolded part) matches the one you trust. Note that you can ignore GPG's warning that the signature isn't trusted because you're checking the fingerprint directly (an advanced user would instead have pre-arranged to trust the key and could thus ignore the fingerprint).\n\n\nIf you have the Keybase tools installed, you can use this much-friendlier command instead:\n\n\nkeybase decrypt -S kentonv release-certificate.kentonv.sig\n\n\n\n\n\n\nDownload the installer script and its signature.\n\n\nwget https://install.sandstorm.io/install.sh\nwget https://install.sandstorm.io/install.sh.sig\n\n\n\n\n\n\nVerify the signature, making sure the signing key's fingerprint matches the one from the certificate.\n\n\ngpg --verify install.sh.sig install.sh\n\n\n\n\n\n\nRun the installer.\n\n\nbash install.sh\n\n\n\n\n\n\n(Aside: You may wonder why our \"release certificates\" are signed natural-language statements, rather than using PGP key signing. The answer is that PGP key signing, or at least the GPG interface, does not seem well-equipped to handle expiring signatures that must be refreshed monthly. We'd like to improve this; please let us know if you have ideas!)\n\n\nOption 4: Installing from Source\n\n\nPrerequisites\n\n\nPlease install the following:\n\n\n\n\nLinux x86_64, with kernel version 3.13 or later\n\n\nC and C++ standard libraries and headers\n\n\nGNU Make\n\n\nlibcap\n with headers\n\n\nxz\n\n\nzip\n\n\nunzip\n\n\nstrace\n\n\ncurl\n\n\nImageMagick\n\n\ndiscount (markdown parser)\n\n\nClang compiler\n version 3.4 or better\n\n\nMeteor\n\n\n\n\nOn Debian or Ubuntu, you should be able to get all these with:\n\n\nsudo apt-get install build-essential libcap-dev xz-utils zip \\\n    unzip imagemagick strace curl clang-3.4 discount git\ncurl https://install.meteor.com/ | sh\n\n\n\nGet the source code\n\n\nGet the source code from the git repository:\n\n\ngit clone https://github.com/sandstorm-io/sandstorm.git\n\n\n\nBuilding / installing the binaries\n\n\nBuild the Sandstorm bundle:\n\n\ncd sandstorm\nmake\n\n\n\n(Note: You should \nnot\n use \n-j\n, as we only use make as a meta-build system. The major components will utilize all CPU cores.)\n\n\nInstall it:\n\n\nmake install\n\n\n\nThis installs your locally-built bundle just as would get if you had installed using\n\nhttps://install.sandstorm.io\n. You will be asked various configuration questions. If you intend\nto hack on Sandstorm itself, you should choose to run the server to run under your local user\naccount (the default is to create a separate user called \nsandstorm\n).\n\n\nIf Sandstorm is already installed, you can update to your newly-built version like so:\n\n\nmake update\n\n\n\nNote that this only works if you installed Sandstorm to run at startup. Otherwise, you will\nhave to manually do:\n\n\n/path/to/sandstorm update sandstorm-0.tar.xz\n\n\n\nHacking on the shell\n\n\nYou can run the shell (front-end) in dev mode so that you can modify it without rebuilding the\nwhole bundle for every change. Just do:\n\n\ncd shell\nsudo service sandstorm stop-fe\n./run-dev.sh\n\n\n\nNow connect to your local server like you normally would.\n\n\nLater, when you are done hacking, you may want to restart the installed front-end:\n\n\nsudo service sandstorm start-fe\n\n\n\nHacking on the C++\n\n\nIf you're going to edit C++, you will want to install \nEkam\n, the build system used by Sandstorm. Be sure to read Ekam's wiki to understand how it works.\n\n\nOnce \nekam\n is in your path, you can use \nmake continuous\n in order to start an Ekam continuous build of Sandstorm. While this build is running, you can also run other \nmake\n commands in a separate window. This will automatically synchronize with your continuous build rather than starting a second build.\n\n\nTo do a debug build, run make like:\n\n\nmake continuous CXXFLAGS=\"-g\"\n\n\n\nIf you suspect you'll be hacking on Sandstorm's dependencies as well, you may want to follow the dependency symlink trick described in the Ekam readme.\n\n\nTips\n\n\n\n\nIf installing Sandstorm under LXC / Docker, you will need to choose the option to\n  install as a non-root user. Unfortunately, this means the development tools will not\n  work. This is due to the interaction between Sandstorm and Docker's use of Linux\n  containerization features and missing features in the Linux kernel which we\n  hope will be fixed eventually. For non-development purposes, Sandstorm should run just fine\n  under Docker.\n\n\nIf you want to run on port 80, we recommend setting up an \nnginx\n reverse\n  proxy rather than trying to get Node to open port 80 directly.  Make sure to configure\n  \nWebSocket forwarding\n, which requires nginx\n  1.3.13 or better.\n\n\nIf you want SSL, then you will definitely need an nginx proxy (or something equivalent). You will\n  further need to use a wildcard certificate.\n\n\n\n\nFor reference,\n\nnginx-example.conf\n\ncontains the http server part of nginx config used by Sandstorm Alpha.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#installation", 
            "text": "There are many options for installing Sandstorm with various trade-offs. Choose the one that is most comfortable for you.  Sandstorm requires Linux x86_64, with kernel version 3.13 or later.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/#option-1-https-verified-install", 
            "text": "The easiest way to install Sandstorm is by running:  curl https://install.sandstorm.io | bash", 
            "title": "Option 1: HTTPS-verified install"
        }, 
        {
            "location": "/install/#option-2-github-verified-install", 
            "text": "If you are uncomfortable with  curl|bash , another option is to  download install.sh from our GitHub repository  and then run it:  wget https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/install.sh\nbash install.sh  This verifies that you're running our published installer script, even in the unlikely event that someone has compromised our download server or HTTPS certificate. The installer will verify signatures on all additional files it downloads.", 
            "title": "Option 2: GitHub-verified install"
        }, 
        {
            "location": "/install/#option-3-pgp-verified-install", 
            "text": "If you'd rather not trust HTTPS at all, even from GitHub, another option is PGP-verified install.    If you aren't experienced with GPG already, let's do these instructions in a new empty workspace to avoid confusion. (If you know what you're doing, you can skip this.)  export GNUPGHOME=$(mktemp -d)    Download and import the Sandstorm releases keyring.  curl https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/keys/release-keyring.gpg | \\\n    gpg --import    Obtain the PGP key fingerprint of a Sandstorm developer you trust. There are several ways to do this:   Web of trust (for PGP experts).  Meet us in person  and ask for our business cards.  Use our Keybase profiles, for example:  Kenton Varda (kentonv) ,  Asheesh Laroia (asheesh) ,  Drew Fisher (zarvox)     Download that developer's corresponding release key certificate  from the Sandstorm github repo . For example, if you chose Kenton:  wget https://raw.githubusercontent.com/sandstorm-io/sandstorm/master/keys/release-certificate.kentonv.sig    Verify the certificate with GPG. For example:  gpg --decrypt release-certificate.kentonv.sig  The output looks something like (emphasis added):  As of September 2015, Sandstorm releases are signed with the PGP key with\nfingerprint 160D 2D57 7518 B58D 94C9  800B 63F2 2749 9DA8 CCBD. This assertion\nwill be updated monthly; do not trust this certificate after October 2015.  gpg: Signature made Wed 23 Sep 2015 04:20:25 PM PDT using RSA key ID 440DDCF1\ngpg: Good signature from \"Kenton Varda  kentonv@keybase.io \"\ngpg:                 aka \"Kenton Varda  temporal@gmail.com \"\ngpg:                 aka \"Kenton Varda  kenton@sandstorm.io \"\ngpg:                 aka \"Kenton Varda  kenton@kentonshouse.com \"\ngpg: WARNING: This key is not certified with a trusted signature!\ngpg:          There is no indication that the signature belongs to the owner.  Primary key fingerprint: 8802 23DF 25AA 25A9 433A  F0FB 4067 8458 440D DCF1  Read the signed statement (top bolded part) and decide if it checks out, and make sure the fingerprint of the signer (bottom bolded part) matches the one you trust. Note that you can ignore GPG's warning that the signature isn't trusted because you're checking the fingerprint directly (an advanced user would instead have pre-arranged to trust the key and could thus ignore the fingerprint).  If you have the Keybase tools installed, you can use this much-friendlier command instead:  keybase decrypt -S kentonv release-certificate.kentonv.sig    Download the installer script and its signature.  wget https://install.sandstorm.io/install.sh\nwget https://install.sandstorm.io/install.sh.sig    Verify the signature, making sure the signing key's fingerprint matches the one from the certificate.  gpg --verify install.sh.sig install.sh    Run the installer.  bash install.sh    (Aside: You may wonder why our \"release certificates\" are signed natural-language statements, rather than using PGP key signing. The answer is that PGP key signing, or at least the GPG interface, does not seem well-equipped to handle expiring signatures that must be refreshed monthly. We'd like to improve this; please let us know if you have ideas!)", 
            "title": "Option 3: PGP-verified install"
        }, 
        {
            "location": "/install/#option-4-installing-from-source", 
            "text": "Prerequisites  Please install the following:   Linux x86_64, with kernel version 3.13 or later  C and C++ standard libraries and headers  GNU Make  libcap  with headers  xz  zip  unzip  strace  curl  ImageMagick  discount (markdown parser)  Clang compiler  version 3.4 or better  Meteor   On Debian or Ubuntu, you should be able to get all these with:  sudo apt-get install build-essential libcap-dev xz-utils zip \\\n    unzip imagemagick strace curl clang-3.4 discount git\ncurl https://install.meteor.com/ | sh  Get the source code  Get the source code from the git repository:  git clone https://github.com/sandstorm-io/sandstorm.git  Building / installing the binaries  Build the Sandstorm bundle:  cd sandstorm\nmake  (Note: You should  not  use  -j , as we only use make as a meta-build system. The major components will utilize all CPU cores.)  Install it:  make install  This installs your locally-built bundle just as would get if you had installed using https://install.sandstorm.io . You will be asked various configuration questions. If you intend\nto hack on Sandstorm itself, you should choose to run the server to run under your local user\naccount (the default is to create a separate user called  sandstorm ).  If Sandstorm is already installed, you can update to your newly-built version like so:  make update  Note that this only works if you installed Sandstorm to run at startup. Otherwise, you will\nhave to manually do:  /path/to/sandstorm update sandstorm-0.tar.xz  Hacking on the shell  You can run the shell (front-end) in dev mode so that you can modify it without rebuilding the\nwhole bundle for every change. Just do:  cd shell\nsudo service sandstorm stop-fe\n./run-dev.sh  Now connect to your local server like you normally would.  Later, when you are done hacking, you may want to restart the installed front-end:  sudo service sandstorm start-fe  Hacking on the C++  If you're going to edit C++, you will want to install  Ekam , the build system used by Sandstorm. Be sure to read Ekam's wiki to understand how it works.  Once  ekam  is in your path, you can use  make continuous  in order to start an Ekam continuous build of Sandstorm. While this build is running, you can also run other  make  commands in a separate window. This will automatically synchronize with your continuous build rather than starting a second build.  To do a debug build, run make like:  make continuous CXXFLAGS=\"-g\"  If you suspect you'll be hacking on Sandstorm's dependencies as well, you may want to follow the dependency symlink trick described in the Ekam readme.", 
            "title": "Option 4: Installing from Source"
        }, 
        {
            "location": "/install/#tips", 
            "text": "If installing Sandstorm under LXC / Docker, you will need to choose the option to\n  install as a non-root user. Unfortunately, this means the development tools will not\n  work. This is due to the interaction between Sandstorm and Docker's use of Linux\n  containerization features and missing features in the Linux kernel which we\n  hope will be fixed eventually. For non-development purposes, Sandstorm should run just fine\n  under Docker.  If you want to run on port 80, we recommend setting up an  nginx  reverse\n  proxy rather than trying to get Node to open port 80 directly.  Make sure to configure\n   WebSocket forwarding , which requires nginx\n  1.3.13 or better.  If you want SSL, then you will definitely need an nginx proxy (or something equivalent). You will\n  further need to use a wildcard certificate.   For reference, nginx-example.conf \ncontains the http server part of nginx config used by Sandstorm Alpha.", 
            "title": "Tips"
        }, 
        {
            "location": "/administering/sandcats/", 
            "text": "About Sandcats.io\n\n\nSandcats.io is a free-of-cost dynamic DNS service and HTTPS\ncertificate service run by the Sandstorm development team. In a\nnutshell:\n\n\n\n\n\n\nSandstorm users can have a free domain name of the form\n  \nexample.sandcats.io\n.\n\n\n\n\n\n\nSandstorm can automatically set up that domain, including a valid\n  HTTPS certificate for it.\n\n\n\n\n\n\nIt's an official part of Sandstorm and we recommend people use it!\n\n\n\n\n\n\nIn more detail:\n\n\n\n\n\n\nUsers host their own servers. A hostname like \nexample.sandcats.io\n\n  points at the IP address of someone's server, and that server holds\n  its own private keys.\n\n\n\n\n\n\nIt assumes your server should be reachable from the global Internet.\n\n\n\n\n\n\nIt's an optional service. Keep reading this page to learn how to\n  stop using it.\n\n\n\n\n\n\nThe purpose is to help people who run their own server have a working\nhostname and HTTPS (TLS/SSL) certificate without having to think hard\nabout the domain name system or public key infrastructure.\n\n\nFeatures\n\n\nSandcats is \nintegrated into the Sandstorm installer\n so that when\nyou install Sandstorm, you get working DNS, including wildcard DNS,\nas well as working HTTPS for the main Sandstorm interface.\n\n\nThe Sandcats backend is \nfree, open source software\n under the\nApache License 2.0; you can \nview and participate in the\nproject\n.\n\n\nThe Sandcats DNS service provides \n60-second\n latency for IP address\nupdates via a custom UDP protocol to detect address changes. To\nachieve this low latency, when Sandcats integration is enabled, your\nSandstorm server sends a UDP ping message to the central Sandcats\nservice every 60 seconds.\n\n\nThe Sandcats certificate service (for providing users with valid\nHTTPS) provides seven-day certificates and an API for automatic\nrenewal.\n\n\nSandcats uses \nHTTPS client certificates\n for authentication, which\nSandstorm and the install script manage for users. You can find\nthese certificates under \n/opt/sandstorm/var/sandcats\n by\ndefault. Please save these somewhere safe so you can hold onto your\ndomain.\n\n\nHow the HTTPS service works\n\n\nThe Sandstorm install script, when it runs on your server, generates a\nprivate key and certificate signing request that it sends to the\nSandcats.io service (via the \n/getcertificate\n JSON-RPC endpoint).\n\n\nSandcats verifies that the request is coming from the owner of this\nparticular \nexample.sandcats.io\n domain name, and if so, passes the\nrequest along to GlobalSign for signing. The install script receives\nthe signed certificate and places it in\n\n/opt/sandstorm/var/sandcats/https/example.sandcats.io/\n.\n\n\nWhen Sandstorm starts, it looks in the above directory for keys \n\ncertificates and uses the first certificate that is valid.\n\n\nThese certificates expire weekly, so Sandstorm also checks every\n(approximately) 2 hours if the certificate it is using is on the last\n3 days of its lifetime. If so, Sandstorm takes the same action as the\ninstall script: generate new key, generate certificate signing\nrequest, send that to Sandcats.io, store the response. (As an\nimplementation detail, these certs technically last 9 days, but we\nrenew them every 7 days.)\n\n\nSandstorm automatically starts using new certificates without needing\nintervention from the server operator. You can read the code that\npowers that in \nmeteor-bundle-main.js\n in the \nsandstorm\n git\nrepository.\n\n\nRecovering your domain\n\n\nEmail-based recovery:\n\n\nIf you have lost your three \nid_rsa\n files: When you are installing\nSandstorm on a new server, you can \nrecover a domain\n automatically\nby using the Sandstorm installer and typing \nhelp\n at the Sandcats\nprompts.\n\n\nFile-based recovery:\n\n\nTo manually recover a domain:\n\n\n\n\n\n\nFind your three three \nid_rsa\n certificate files (usually\n  \n/opt/sandstorm/var/sandcats\n) and keep them safe somewhere.\n\n\n\n\n\n\nDo a new Sandstorm install, probably to \n/opt/sandstorm\n.\n\n\n\n\n\n\nCopy those three \nid_rsa\n certificate files into the Sandcats\n  directory (usually \n/opt/sandstorm/var/sandcats\n).\n\n\n\n\n\n\nIn your new Sandstorm install, ensure you have your \nBASE_URL\n and\n  \nWILDCARD_HOST\n set properly in your \nsandstorm.conf\n.\n\n\n\n\n\n\nEdit \nsandstorm.conf\n to contain this line:\n  \nSANDCATS_BASE_DOMAIN=sandcats.io\n\n\n\n\n\n\nNow restart Sandstorm \nsandstorm stop ; sandstorm start\n, and wait\n  at least 60 seconds.\n\n\n\n\n\n\nYour DNS hostname should have auto-updated. Check that DNS is\n  working with \nnslookup \nmyname\n.sandcats.io\n from another\n  machine. This will help eliminate DNS as an issue when trying to\n  access your server.\n\n\n\n\n\n\nDisabling the sandcats service\n\n\nIf you want to run Sandstorm without the Sandcats service, remove the\n\n\nSANDCATS_BASE_DOMAIN=...\n\n\n\n\nline from your \n/opt/sandstorm/sandstorm.conf\n. That will disable the\nfunctionality. Note that this does not delete any domains you\nregistered. It does cause them to stop updating.\n\n\nTerms of service, privacy policy, \n contact information\n\n\nSandcats.io has the following formal documents:\n\n\n\n\nSandcats.io privacy policy\n\n\nSandcats.io terms of service\n\n\n\n\nIf you have more questions, or are having trouble, email:\n\n\nsupport@sandstorm.io", 
            "title": "Sandcats dynamic DNS"
        }, 
        {
            "location": "/administering/sandcats/#about-sandcatsio", 
            "text": "Sandcats.io is a free-of-cost dynamic DNS service and HTTPS\ncertificate service run by the Sandstorm development team. In a\nnutshell:    Sandstorm users can have a free domain name of the form\n   example.sandcats.io .    Sandstorm can automatically set up that domain, including a valid\n  HTTPS certificate for it.    It's an official part of Sandstorm and we recommend people use it!    In more detail:    Users host their own servers. A hostname like  example.sandcats.io \n  points at the IP address of someone's server, and that server holds\n  its own private keys.    It assumes your server should be reachable from the global Internet.    It's an optional service. Keep reading this page to learn how to\n  stop using it.    The purpose is to help people who run their own server have a working\nhostname and HTTPS (TLS/SSL) certificate without having to think hard\nabout the domain name system or public key infrastructure.", 
            "title": "About Sandcats.io"
        }, 
        {
            "location": "/administering/sandcats/#features", 
            "text": "Sandcats is  integrated into the Sandstorm installer  so that when\nyou install Sandstorm, you get working DNS, including wildcard DNS,\nas well as working HTTPS for the main Sandstorm interface.  The Sandcats backend is  free, open source software  under the\nApache License 2.0; you can  view and participate in the\nproject .  The Sandcats DNS service provides  60-second  latency for IP address\nupdates via a custom UDP protocol to detect address changes. To\nachieve this low latency, when Sandcats integration is enabled, your\nSandstorm server sends a UDP ping message to the central Sandcats\nservice every 60 seconds.  The Sandcats certificate service (for providing users with valid\nHTTPS) provides seven-day certificates and an API for automatic\nrenewal.  Sandcats uses  HTTPS client certificates  for authentication, which\nSandstorm and the install script manage for users. You can find\nthese certificates under  /opt/sandstorm/var/sandcats  by\ndefault. Please save these somewhere safe so you can hold onto your\ndomain.", 
            "title": "Features"
        }, 
        {
            "location": "/administering/sandcats/#how-the-https-service-works", 
            "text": "The Sandstorm install script, when it runs on your server, generates a\nprivate key and certificate signing request that it sends to the\nSandcats.io service (via the  /getcertificate  JSON-RPC endpoint).  Sandcats verifies that the request is coming from the owner of this\nparticular  example.sandcats.io  domain name, and if so, passes the\nrequest along to GlobalSign for signing. The install script receives\nthe signed certificate and places it in /opt/sandstorm/var/sandcats/https/example.sandcats.io/ .  When Sandstorm starts, it looks in the above directory for keys  \ncertificates and uses the first certificate that is valid.  These certificates expire weekly, so Sandstorm also checks every\n(approximately) 2 hours if the certificate it is using is on the last\n3 days of its lifetime. If so, Sandstorm takes the same action as the\ninstall script: generate new key, generate certificate signing\nrequest, send that to Sandcats.io, store the response. (As an\nimplementation detail, these certs technically last 9 days, but we\nrenew them every 7 days.)  Sandstorm automatically starts using new certificates without needing\nintervention from the server operator. You can read the code that\npowers that in  meteor-bundle-main.js  in the  sandstorm  git\nrepository.", 
            "title": "How the HTTPS service works"
        }, 
        {
            "location": "/administering/sandcats/#recovering-your-domain", 
            "text": "Email-based recovery:  If you have lost your three  id_rsa  files: When you are installing\nSandstorm on a new server, you can  recover a domain  automatically\nby using the Sandstorm installer and typing  help  at the Sandcats\nprompts.  File-based recovery:  To manually recover a domain:    Find your three three  id_rsa  certificate files (usually\n   /opt/sandstorm/var/sandcats ) and keep them safe somewhere.    Do a new Sandstorm install, probably to  /opt/sandstorm .    Copy those three  id_rsa  certificate files into the Sandcats\n  directory (usually  /opt/sandstorm/var/sandcats ).    In your new Sandstorm install, ensure you have your  BASE_URL  and\n   WILDCARD_HOST  set properly in your  sandstorm.conf .    Edit  sandstorm.conf  to contain this line:\n   SANDCATS_BASE_DOMAIN=sandcats.io    Now restart Sandstorm  sandstorm stop ; sandstorm start , and wait\n  at least 60 seconds.    Your DNS hostname should have auto-updated. Check that DNS is\n  working with  nslookup  myname .sandcats.io  from another\n  machine. This will help eliminate DNS as an issue when trying to\n  access your server.", 
            "title": "Recovering your domain"
        }, 
        {
            "location": "/administering/sandcats/#disabling-the-sandcats-service", 
            "text": "If you want to run Sandstorm without the Sandcats service, remove the  SANDCATS_BASE_DOMAIN=...  line from your  /opt/sandstorm/sandstorm.conf . That will disable the\nfunctionality. Note that this does not delete any domains you\nregistered. It does cause them to stop updating.", 
            "title": "Disabling the sandcats service"
        }, 
        {
            "location": "/administering/sandcats/#terms-of-service-privacy-policy-contact-information", 
            "text": "Sandcats.io has the following formal documents:   Sandcats.io privacy policy  Sandcats.io terms of service   If you have more questions, or are having trouble, email:  support@sandstorm.io", 
            "title": "Terms of service, privacy policy, &amp; contact information"
        }, 
        {
            "location": "/administering/email/", 
            "text": "Email in Sandstorm\n\n\nThis tutorial will show you how to setup your personal sandstorm instance with support for e-mail.\n\n\nFirst, a quick rundown of how email works in sandstorm. Sandstorm is\nrunning an SMTP server on port 30025 that will accept email of the\nform \npublicId\n@\nhostname\n. \npublicId\n is randomly generated for every\ngrain that handles e-mail, and \nhostname\n is extracted from the\n\nBASE_URL\n parameter in sandstorm.conf (which is initially created by\nthe installer script). Outgoing e-mail is sent through an external\nSMTP server, controllable by the \nSMTP Url\n configuration under Admin\nSettings (the \nMAIL_URL\n parameter in \nsandstorm.conf\n has been\ndeprecated). When sending e-mails, the only valid \"From\" addresses are\nthe grain's generated \npublicId\n@\nhostname\n address, or the verified\nemail from the user's account (e.g. the e-mail address obtained via\nGoogle or Github login). The interfaces for sending/receiving e-mails\nare available in\n\nhack-session.capnp\n.\n\n\nOutgoing SMTP\n\n\nAll you need to do is configure the \nSMTP Url\n field under Admin Settings to a working SMTP server that will accept e-mails with the SMTP envelope's bounce address set to your grain's local address. If running at home, you can usually use your ISP's SMTP server. Otherwise, \nSendgrid\n, \nMailgun\n, and \nMandrill\n also provide such services, some with free tiers. The SMTP Url looks like this:\n\n\nsmtp://USERNAME:PASSWORD@SMTP_HOST:SMTP_PORT\n\n\n\n\nIf \nUSERNAME\n is in the form of an email address, like\n\nuser@example.com\n, then the \n@\n will need to be URL-encoded as \n%40\n.\n\n\nReceiving email into Sandstorm app instances\n\n\nPrerequisites\n\n\n\n\nA personal domain at which you are running your Sandstorm server.\n\n\nBasic knowledge of how to configure DNS records for your domain.\n\n\nnginx\n\n\nA working outgoing SMTP server.\n\n\n\n\nSetup DNS\n\n\nThis is relatively straightfoward if you know how to configure your domain's DNS records. All you need to do is add an MX record pointing to your sandstorm server.\n\n\nProxy SMTP\n\n\nSandstorm's SMTP server runs on port 30025, and is intended to sit behind a reverse proxy. The easiest way to do accomplish this is with nginx. Add the following to your \nnginx.conf\n:\n\n\nmail {\n    ssl_certificate /etc/keys/my-ssl.crt;\n    ssl_certificate_key /etc/keys/my-ssl.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    ssl_prefer_server_ciphers on;\n\n    server {\n        listen 25;\n        server_name sandstorm.example.com;\n        auth_http localhost:8008/fake-smtp-auth;\n        protocol smtp;\n        timeout 30s;\n        proxy on;\n        xclient off;\n        smtp_auth none;\n        starttls on;\n    }\n\n    server {\n        listen 465;\n        server_name sandstorm.example.com;\n        auth_http localhost:8008/fake-smtp-auth;\n        protocol smtp;\n        timeout 30s;\n        proxy on;\n        xclient off;\n        smtp_auth none;\n        ssl on;\n    }\n}\n\n\n\nnginx requires that you provide an authentication handler for all SMTP proxies. We don't actually need authentication because our server is only meant to receive e-mail destined for this host (it will not relay). So, we have to set up a fake authentication handler. In the part of your nginx config where you defined your HTTP servers (e.g. \n/etc/nginx/sites-available/default\n), add this fake server for SMTP auth purposes:\n\n\n# Fake SMTP authorizor which always accepts. Put this in your http block.\nserver {\n    listen 127.0.0.1:8008;\n    server_name localhost;\n\n    location /fake-smtp-auth {\n        add_header Auth-Server 127.0.0.1;\n        add_header Auth-Port 30025;\n        return 200;\n    }\n}", 
            "title": "Email"
        }, 
        {
            "location": "/administering/email/#email-in-sandstorm", 
            "text": "This tutorial will show you how to setup your personal sandstorm instance with support for e-mail.  First, a quick rundown of how email works in sandstorm. Sandstorm is\nrunning an SMTP server on port 30025 that will accept email of the\nform  publicId @ hostname .  publicId  is randomly generated for every\ngrain that handles e-mail, and  hostname  is extracted from the BASE_URL  parameter in sandstorm.conf (which is initially created by\nthe installer script). Outgoing e-mail is sent through an external\nSMTP server, controllable by the  SMTP Url  configuration under Admin\nSettings (the  MAIL_URL  parameter in  sandstorm.conf  has been\ndeprecated). When sending e-mails, the only valid \"From\" addresses are\nthe grain's generated  publicId @ hostname  address, or the verified\nemail from the user's account (e.g. the e-mail address obtained via\nGoogle or Github login). The interfaces for sending/receiving e-mails\nare available in hack-session.capnp .", 
            "title": "Email in Sandstorm"
        }, 
        {
            "location": "/administering/email/#outgoing-smtp", 
            "text": "All you need to do is configure the  SMTP Url  field under Admin Settings to a working SMTP server that will accept e-mails with the SMTP envelope's bounce address set to your grain's local address. If running at home, you can usually use your ISP's SMTP server. Otherwise,  Sendgrid ,  Mailgun , and  Mandrill  also provide such services, some with free tiers. The SMTP Url looks like this:  smtp://USERNAME:PASSWORD@SMTP_HOST:SMTP_PORT  If  USERNAME  is in the form of an email address, like user@example.com , then the  @  will need to be URL-encoded as  %40 .", 
            "title": "Outgoing SMTP"
        }, 
        {
            "location": "/administering/email/#receiving-email-into-sandstorm-app-instances", 
            "text": "Prerequisites   A personal domain at which you are running your Sandstorm server.  Basic knowledge of how to configure DNS records for your domain.  nginx  A working outgoing SMTP server.   Setup DNS  This is relatively straightfoward if you know how to configure your domain's DNS records. All you need to do is add an MX record pointing to your sandstorm server.  Proxy SMTP  Sandstorm's SMTP server runs on port 30025, and is intended to sit behind a reverse proxy. The easiest way to do accomplish this is with nginx. Add the following to your  nginx.conf :  mail {\n    ssl_certificate /etc/keys/my-ssl.crt;\n    ssl_certificate_key /etc/keys/my-ssl.key;\n    ssl_session_timeout 5m;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    ssl_prefer_server_ciphers on;\n\n    server {\n        listen 25;\n        server_name sandstorm.example.com;\n        auth_http localhost:8008/fake-smtp-auth;\n        protocol smtp;\n        timeout 30s;\n        proxy on;\n        xclient off;\n        smtp_auth none;\n        starttls on;\n    }\n\n    server {\n        listen 465;\n        server_name sandstorm.example.com;\n        auth_http localhost:8008/fake-smtp-auth;\n        protocol smtp;\n        timeout 30s;\n        proxy on;\n        xclient off;\n        smtp_auth none;\n        ssl on;\n    }\n}  nginx requires that you provide an authentication handler for all SMTP proxies. We don't actually need authentication because our server is only meant to receive e-mail destined for this host (it will not relay). So, we have to set up a fake authentication handler. In the part of your nginx config where you defined your HTTP servers (e.g.  /etc/nginx/sites-available/default ), add this fake server for SMTP auth purposes:  # Fake SMTP authorizor which always accepts. Put this in your http block.\nserver {\n    listen 127.0.0.1:8008;\n    server_name localhost;\n\n    location /fake-smtp-auth {\n        add_header Auth-Server 127.0.0.1;\n        add_header Auth-Port 30025;\n        return 200;\n    }\n}", 
            "title": "Receiving email into Sandstorm app instances"
        }, 
        {
            "location": "/administering/demo/", 
            "text": "Demo mode\n\n\nThis page documents some features of the Sandstorm demo mode, which is the mode in which \ndemo.sandstorm.io\n runs. The code for demo mode is in the main Sandstorm repository but usually is not enabled.\n\n\nPurpose of demo mode\n\n\nThe main purpose of the demo mode is to let people learn more about the Sandstorm platform by using a Sandstorm instance without having to think about registering for an account.\n\n\nA secondary purpose, the code for which is not yet fully implemented, is to enable people to try out Sandstorm \napps\n without having to think about registering for an account or \"installing\" the app.\n\n\nData deletion\n\n\nA demo user and their data is deleted one hour after the user is created. To learn about how, read the \ncode implementing the demo\n.\n\n\nAt the time of writing, the period of data deletion is not configurable.\n\n\nEnabling demo mode\n\n\nDemo mode is mainly intended to run on \ndemo.sandstorm.io\n, since the purpose is to show you what Sandstorm looks like before you've installed it. That said, you can enable it on your own installation.\n\n\nTo enable demo mode, add the following line to \nsandstorm.conf\n:\n\n\nALLOW_DEMO_ACCOUNTS=true\n\n\n\n\nApp demos\n\n\nWhen a Sandstorm instance allows demo accounts, a visitor can surf to:\n\n\n/appdemo/:appId\n\n\n(where \nappId\n is the key ID of an app installed on that server).\n\n\nAt that URL, we show a screen to the visitor indicating that their data will vanish in a hour. When they click on the \"Try appName\" button, they find themselves in a working instance of the app.\n\n\nThis hinges on the app named by \nappId\n being installed on the server.\n\n\nYour app's ID can be found near the top of the package definition file (\nsandstorm-pkgdef.capnp\n), where it will be defined something like this:\n\n\nconst pkgdef :Spk.PackageDefinition = (\n  id = \"nqmcqs9spcdpmqyuxemf0tsgwn8awfvswc58wgk375g4u25xv6yh\",\n\n\n\nTo find the ID of an already-built \n.spk\n package, run \nspk unpack\n on it; it will print the ID to the console. For apps on the \nSandstorm app list\n, you can also look at the \ndata-app-id\n attribute on the \"install\" button.", 
            "title": "Demo mode"
        }, 
        {
            "location": "/administering/demo/#demo-mode", 
            "text": "This page documents some features of the Sandstorm demo mode, which is the mode in which  demo.sandstorm.io  runs. The code for demo mode is in the main Sandstorm repository but usually is not enabled.", 
            "title": "Demo mode"
        }, 
        {
            "location": "/administering/demo/#purpose-of-demo-mode", 
            "text": "The main purpose of the demo mode is to let people learn more about the Sandstorm platform by using a Sandstorm instance without having to think about registering for an account.  A secondary purpose, the code for which is not yet fully implemented, is to enable people to try out Sandstorm  apps  without having to think about registering for an account or \"installing\" the app.", 
            "title": "Purpose of demo mode"
        }, 
        {
            "location": "/administering/demo/#data-deletion", 
            "text": "A demo user and their data is deleted one hour after the user is created. To learn about how, read the  code implementing the demo .  At the time of writing, the period of data deletion is not configurable.", 
            "title": "Data deletion"
        }, 
        {
            "location": "/administering/demo/#enabling-demo-mode", 
            "text": "Demo mode is mainly intended to run on  demo.sandstorm.io , since the purpose is to show you what Sandstorm looks like before you've installed it. That said, you can enable it on your own installation.  To enable demo mode, add the following line to  sandstorm.conf :  ALLOW_DEMO_ACCOUNTS=true", 
            "title": "Enabling demo mode"
        }, 
        {
            "location": "/administering/demo/#app-demos", 
            "text": "When a Sandstorm instance allows demo accounts, a visitor can surf to:  /appdemo/:appId  (where  appId  is the key ID of an app installed on that server).  At that URL, we show a screen to the visitor indicating that their data will vanish in a hour. When they click on the \"Try appName\" button, they find themselves in a working instance of the app.  This hinges on the app named by  appId  being installed on the server.  Your app's ID can be found near the top of the package definition file ( sandstorm-pkgdef.capnp ), where it will be defined something like this:  const pkgdef :Spk.PackageDefinition = (\n  id = \"nqmcqs9spcdpmqyuxemf0tsgwn8awfvswc58wgk375g4u25xv6yh\",  To find the ID of an already-built  .spk  package, run  spk unpack  on it; it will print the ID to the console. For apps on the  Sandstorm app list , you can also look at the  data-app-id  attribute on the \"install\" button.", 
            "title": "App demos"
        }, 
        {
            "location": "/administering/backups/", 
            "text": "You can backup an individual grain by clicking the download backup\nicon at the top of your sandstorm app. The entire sandstorm\ninstallation can be backed up safely by stopping sandstorm:\n\n\nsudo service stop sandstorm\n\n\n\nand taking a filesystem snapshot of \n/opt/sandstorm\n. If your\nfilesystem doesn't support online snapshots you can make a quick\nbackup by running:\n\n\ncp -a /opt/sandstorm [the destination of your backup]\n\n\n\nAlternatively one can make a backup using tar\n\n\ntar -cf [location of tar archive] /opt/sandstorm\n\n\n\nThen restart sandstorm to end the interruption:\n\n\nsudo service start sandstorm", 
            "title": "Backups"
        }, 
        {
            "location": "/administering/wildcard/", 
            "text": "To run Sandstorm, you must assign it a wildcard host, in which it can\ngenerate new hostnames as-needed. For instance, you might set up\nSandstorm to run at \nexample.com\n and assign it the wildcard\n\n*.example.com\n.\n\n\nSetting up wildcard DNS and especially SSL can be difficult and\ncostly, which commonly leads to the question: \"Why does Sandstorm need\nthis?\" This page seeks to answer the questions.\n\n\nIt's all about security.\n\n\nSandstorm is designed to implement strong sandboxing of apps, such\nthat users need not worry about the risk that a malicious -- or simply\nbuggy -- app might interfere with other apps or the rest of the\nnetwork. Our goal is for the network admins to be able to say: \"As\nlong as it's on Sandstorm, you can run whatever apps you want, because\nwe trust Sandstorm to keep things secure.\"\n\n\nUsing a wildcard host is just one part of \nSandstorm's security\nmodel\n.\n\n\nSandstorm handles this for localhost + sandcats users\n\n\nSandstorm runs \nlocal.sandstorm.io\n as a wildcard domain where\nboth \nlocal.sandstorm.io\n and all of its subdomains\n(\n*.local.sandstorm.io\n) point to \n127.0.0.1\n, the same as\n\nlocalhost\n. This allows you to conveniently run Sandstorm on\nyour own computer or a virtual machine for development and\ntesting by configuring it to use \nlocal.sandstorm.io\n and\n\n*.local.sandstorm.io\n, without needing to own a domain and\nconfigure wildcard DNS for a subdomain.\n\n\nFor the \nsandcats.io\n DNS service, each domain is also a wildcard\ndomain. This allows a self-hosted Sandstorm domain to operate\ncorrectly.\n\n\nFrequently-asked questions about wildcards\n\n\nHere are some common questions about Sandstorm's use of wildcards.\n\n\nHow does Sandstorm use its wildcard?\n\n\nEvery time you open a grain (an instance of a Sandstorm app), you\nbegin a new \"session\" with that grain. Every session is assigned a\nunique, cryptographically-random hostname. The session ends shortly\nafter you close the tab; after that, the hostname is disabled and is\nnever used again.\n\n\nEach session -- and thus each hostname -- belongs to a single\nuser. Using a cookie, Sandstorm ensures that no other user can access\nthe session's hostname. This cookie is enforced by Sandstorm, not the\napp; Sandstorm accomplishes this by acting as a proxy in front of the\napp that checks the cookie.\n\n\nWhy can't Sandstorm map every app under one domain, like \nexample.com/app-name\n?\n\n\nDue to \"same-origin policy\" as specified in web standards, it is\nimpossible to isolate apps hosted within the same \"origin\",\ni.e. hostname. If two tabs or frames are in the same origin, then\nJavascript in each is permitted to arbitrarily modify the contents of\nthe other, including executing arbitrary code. This makes it totally\nimpossible for these apps to defend themselves from each other even if\nthey tried. Hence, it is absolutely necessary for every app to be on a\nseparate host.\n\n\nWhy can't Sandstorm use one hostname per app, like \napp-name.example.com\n? Then admins could configure specifically those hosts.\n\n\nMultiple reasons:\n\n\n\n\n\n\nSandstorm aims to make app installation a one-click process. If\n  every time a new app is installed, the user must edit DNS records\n  and issue a new SSL certificate, one of the platform's most valuable\n  features is lost.\n\n\n\n\n\n\nSandstorm does not just isolate apps from each other, but isolates\n  individual resources within an app. For example, with Etherpad (a\n  document editor), Sandstorm creates a new Etherpad instance in its\n  own isolated container for every Etherpad document you create. This\n  protects against potential security problems in Etherpad which may\n  have allowed a user with access to one document to improperly obtain\n  access to other documents -- Etherpad has in fact had several such\n  bugs in the last few months, but none of them affected Etherpad on\n  Sandstorm.\n\n\n\n\n\n\nWhy a new hostname for every session, rather than for every document?\n\n\nRandomized, unguessable hostnames can help mitigate certain common\nsecurity bugs in apps, such as \nXSRF\n, \nreflected XSS\n, and\n\nclickjacking\n attacks. All of these attacks involve an attacker\ntricking the user's browser into performing actions on another site\nusing the user's credentials. But for any of these attacks to work,\nthe attacker must know the address to attack. If every user gets a\ndifferent hostname, and indeed the hostnames change frequently, then\nit is much harder to launch these kinds of attacks.\n\n\nNote that because DNS requests are made in cleartext, random hostnames\nwill not defend against an attacker who has the ability to snoop\nnetwork traffic coming from the user's machine. Therefore, apps should\nstill implement their own defenses against these attacks as they\nalways have. But, when a bug slips through (as they commonly do),\nrandomized hostnames make an attack much, much more difficult to pull\noff, which is still a big win.\n\n\nCan Sandstorm contact the DNS and SSL servers to request creation of each new host on-demand, rather than require a wildcard?\n\n\nWhile theoretically possible, Sandstorm would need to do generate a\nnew hostname every time the user opens a document. This would lead to\nundesirably high load on DNS and SSL systems.", 
            "title": "Wildcard hosts"
        }, 
        {
            "location": "/administering/wildcard/#its-all-about-security", 
            "text": "Sandstorm is designed to implement strong sandboxing of apps, such\nthat users need not worry about the risk that a malicious -- or simply\nbuggy -- app might interfere with other apps or the rest of the\nnetwork. Our goal is for the network admins to be able to say: \"As\nlong as it's on Sandstorm, you can run whatever apps you want, because\nwe trust Sandstorm to keep things secure.\"  Using a wildcard host is just one part of  Sandstorm's security\nmodel .", 
            "title": "It's all about security."
        }, 
        {
            "location": "/administering/wildcard/#sandstorm-handles-this-for-localhost-sandcats-users", 
            "text": "Sandstorm runs  local.sandstorm.io  as a wildcard domain where\nboth  local.sandstorm.io  and all of its subdomains\n( *.local.sandstorm.io ) point to  127.0.0.1 , the same as localhost . This allows you to conveniently run Sandstorm on\nyour own computer or a virtual machine for development and\ntesting by configuring it to use  local.sandstorm.io  and *.local.sandstorm.io , without needing to own a domain and\nconfigure wildcard DNS for a subdomain.  For the  sandcats.io  DNS service, each domain is also a wildcard\ndomain. This allows a self-hosted Sandstorm domain to operate\ncorrectly.", 
            "title": "Sandstorm handles this for localhost + sandcats users"
        }, 
        {
            "location": "/administering/wildcard/#frequently-asked-questions-about-wildcards", 
            "text": "Here are some common questions about Sandstorm's use of wildcards.  How does Sandstorm use its wildcard?  Every time you open a grain (an instance of a Sandstorm app), you\nbegin a new \"session\" with that grain. Every session is assigned a\nunique, cryptographically-random hostname. The session ends shortly\nafter you close the tab; after that, the hostname is disabled and is\nnever used again.  Each session -- and thus each hostname -- belongs to a single\nuser. Using a cookie, Sandstorm ensures that no other user can access\nthe session's hostname. This cookie is enforced by Sandstorm, not the\napp; Sandstorm accomplishes this by acting as a proxy in front of the\napp that checks the cookie.  Why can't Sandstorm map every app under one domain, like  example.com/app-name ?  Due to \"same-origin policy\" as specified in web standards, it is\nimpossible to isolate apps hosted within the same \"origin\",\ni.e. hostname. If two tabs or frames are in the same origin, then\nJavascript in each is permitted to arbitrarily modify the contents of\nthe other, including executing arbitrary code. This makes it totally\nimpossible for these apps to defend themselves from each other even if\nthey tried. Hence, it is absolutely necessary for every app to be on a\nseparate host.  Why can't Sandstorm use one hostname per app, like  app-name.example.com ? Then admins could configure specifically those hosts.  Multiple reasons:    Sandstorm aims to make app installation a one-click process. If\n  every time a new app is installed, the user must edit DNS records\n  and issue a new SSL certificate, one of the platform's most valuable\n  features is lost.    Sandstorm does not just isolate apps from each other, but isolates\n  individual resources within an app. For example, with Etherpad (a\n  document editor), Sandstorm creates a new Etherpad instance in its\n  own isolated container for every Etherpad document you create. This\n  protects against potential security problems in Etherpad which may\n  have allowed a user with access to one document to improperly obtain\n  access to other documents -- Etherpad has in fact had several such\n  bugs in the last few months, but none of them affected Etherpad on\n  Sandstorm.    Why a new hostname for every session, rather than for every document?  Randomized, unguessable hostnames can help mitigate certain common\nsecurity bugs in apps, such as  XSRF ,  reflected XSS , and clickjacking  attacks. All of these attacks involve an attacker\ntricking the user's browser into performing actions on another site\nusing the user's credentials. But for any of these attacks to work,\nthe attacker must know the address to attack. If every user gets a\ndifferent hostname, and indeed the hostnames change frequently, then\nit is much harder to launch these kinds of attacks.  Note that because DNS requests are made in cleartext, random hostnames\nwill not defend against an attacker who has the ability to snoop\nnetwork traffic coming from the user's machine. Therefore, apps should\nstill implement their own defenses against these attacks as they\nalways have. But, when a bug slips through (as they commonly do),\nrandomized hostnames make an attack much, much more difficult to pull\noff, which is still a big win.  Can Sandstorm contact the DNS and SSL servers to request creation of each new host on-demand, rather than require a wildcard?  While theoretically possible, Sandstorm would need to do generate a\nnew hostname every time the user opens a document. This would lead to\nundesirably high load on DNS and SSL systems.", 
            "title": "Frequently-asked questions about wildcards"
        }, 
        {
            "location": "/administering/reverse-proxy/", 
            "text": "This document helps you serve Sandstorm with HTTPS and take the port (6080) out the URL.\n\n\nnginx\n will listen on port 80 to redirect HTTP to HTTPS on port 443.\nOn port 443, it will reverse proxy Sandstorm on port 6080.\n\n\nPrerequisites\n\n\nCreate DNS entries for \nexample.com\n and \n*.example.com\n.\n\n\nObtain or generate a key and TLS certificate with \nexample.com\n and \n*.example.com\n in subjectAltName.\n\n\nInstall \nnginx\n with your package manager.\n\n\nConfiguration\n\n\nnginx\n\n\nCopy \nnginx-example.conf\n to \n/etc/nginx/sites-enabled/\n.\n\n\nnginx-example.conf\n may be renamed to anything, such as \nexample.com.conf\n.\n\n\nAlter the \nconf\n file.\n\n\n\n\nAll \nserver_name\n lines should match your DNS entries.\n\n\nPoint \nssl_certificate\n and \nssl_certificate_key\n to your corresponding TLS certificate and key files.\n\n\n\n\nlisten 80;\nserver_name example.com *.example.com;\n\nlisten 443 ssl;\nserver_name example.com *.example.com;\n\nssl_certificate /etc/keys/example.com.crt;\nssl_certificate_key /etc/keys/example.com.key;\n\n\n\n\nTest your nginx configuration:\n\nsudo nginx -t\n\n\nSandstorm\n\n\nSpecify HTTPS, and remove port numbers from the base URL and wildcard host.\n\n\n/opt/sandstorm/sandstorm.conf\n\n\nBASE_URL=https://example.com\nWILDCARD_HOST=*.example.com\n\n\n\n\nRun\n\n\nFinally, start NGINX, and restart Sandstorm to use the new config.\n\n\nsudo service nginx restart\nsudo /opt/sandstorm/sandstorm restart", 
            "title": "Reverse Proxy"
        }, 
        {
            "location": "/administering/reverse-proxy/#prerequisites", 
            "text": "Create DNS entries for  example.com  and  *.example.com .  Obtain or generate a key and TLS certificate with  example.com  and  *.example.com  in subjectAltName.  Install  nginx  with your package manager.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/administering/reverse-proxy/#configuration", 
            "text": "nginx  Copy  nginx-example.conf  to  /etc/nginx/sites-enabled/ .  nginx-example.conf  may be renamed to anything, such as  example.com.conf .  Alter the  conf  file.   All  server_name  lines should match your DNS entries.  Point  ssl_certificate  and  ssl_certificate_key  to your corresponding TLS certificate and key files.   listen 80;\nserver_name example.com *.example.com;\n\nlisten 443 ssl;\nserver_name example.com *.example.com;\n\nssl_certificate /etc/keys/example.com.crt;\nssl_certificate_key /etc/keys/example.com.key;  Test your nginx configuration: sudo nginx -t  Sandstorm  Specify HTTPS, and remove port numbers from the base URL and wildcard host.  /opt/sandstorm/sandstorm.conf  BASE_URL=https://example.com\nWILDCARD_HOST=*.example.com", 
            "title": "Configuration"
        }, 
        {
            "location": "/administering/reverse-proxy/#run", 
            "text": "Finally, start NGINX, and restart Sandstorm to use the new config.  sudo service nginx restart\nsudo /opt/sandstorm/sandstorm restart", 
            "title": "Run"
        }, 
        {
            "location": "/administering/ssl/", 
            "text": "Sandstorm and HTTPS\n\n\nIf you are using a hostname like \nexample.sandcats.io\n, then you\nlikely already have working HTTPS (SSL) for your hostname. Keep\nreading to learn how this feature works and enable it/disable it.\n\n\nThis page also documents other options for HTTPS for a Sandstorm\nserver.\n\n\nSandstorm's built-in HTTPS (if you use a \nsandcats.io\n domain)\n\n\nFor new Sandstorm installations, HTTPS is enabled by\ndefault. Sandstorm listens on port 443 for HTTPS connections and port\n80 for HTTP connections.\n\n\nThis is implemented through the \nsandstorm.conf\n file. HTTPS mode is\nenabled by setting the \nHTTPS_PORT=443\n configuration option, causing\nthe Sandstorm software on your server to bind port 443.\n\n\nSandstorm also listens on port 80 (via \nPORT=80\n). When there is a\n\nHTTPS_PORT\n configured, and a request comes in for the Sandstorm\nshell or a wildcard host over HTTP, Sandstorm delivers a redirect to\nHTTPS.\n\n\nSandstorm grains can publish static content to the web on whatever\ndomain the user wants. Sandstorm serves this static publishing over\nboth HTTP and HTTPS, since Sandstorm software can't currently get a\nvalid HTTPS certificate for all domain names.\n\n\nEnabling HTTPS for an existing \nsandcats.io\n Sandstorm server\n\n\nIf you are using the \nsandcats.io\n DNS service, you can migrate from\nrunning Sandstorm on port 6080 (perhaps with a reverse-proxy) to\nhaving Sandstorm own port 443 (HTTPS) and port 80 (HTTP).\n\n\nIf you are using nginx to speak HTTPS on port 443 and HTTP on port 80,\nyou should disable that before proceeding.\n\n\nIn this example, we presume your server is on\n\nexample.sandcats.io\n. We also assume your Sandstorm server runs on\nport 6080 currently.\n\n\nThis process will require reconfiguring any OAuth login providers like\nGoogle or GitHub, so it may take you up to thirty minutes to complete.\n\n\nFirst, enable HTTPS by modifying your Sandstorm configuration file.\nOne way to do that is to open it with nano:\n\n\nsudo nano -w /opt/sandstorm/sandstorm.conf\n\n\n\n\nAdd \nHTTPS_PORT=\n to the bottom of the file:\n\n\nHTTPS_PORT=443\n\n\n\n\nFind these settings and modify them:\n\n\nBASE_URL=https://example.sandcats.io\nWILDCARD_HOST=*.example.sandcats.io\nPORT=80,6080\n\n\n\n\nNote on customization:\n if you stick to the default \nHTTPS_PORT\n of\n443, make sure to remove \n:6080\n from \nBASE_URL\n and\n\nWILDCARD_HOST\n. If you prefer a non-default port, you must specify it\nin \nBASE_URL\n and \nWILDCARD_HOST\n. If you want Sandstorm to listen for\nHTTP on ports other than 80, you can customize the \nPORT=\n line.\n\n\nSave the file and exit your editor. If you are using \nnano\n you can\ndo this \nCtrl-w\n then \nenter\n then \nCtrl-x\n.\n\n\nStop and start Sandstorm:\n\n\nsudo sandstorm restart\n\n\n\n\nSandstorm will begin to set up HTTPS, and if you want to watch the\nprocess, you can run this command:\n\n\nsudo tail -f /opt/sandstorm/var/log/sandstorm.log\n\n\n\n\nThe first launch with HTTPS enabled may take one or two minutes while\nSandstorm configures keys.\n\n\nNote on login providers\n: If you had Google or GitHub login enabled\n(or other OAuth providers), the change in \nBASE_URL\n means that you\nneed to reconfigure those services. You can log into Sandstorm in a\nspecial admin mode by running:\n\n\nsudo sandstorm admin-token\n\n\n\n\nOnce you are viewing the admin page, you should disable and then\nre-enable GitHub, Google, and any other OAuth-based login\nproviders. This process will typically require visiting the Google and\nGitHub websites.\n\n\nOnce you click \nSave\n at the bottom of the login configuration page,\nyou should sign in however you normally sign in, perhaps with a Google\nor GitHub account, by clicking \nSign in\n.\n\n\nCongratulations!\n You're now using HTTPS, also known as SSL and TLS.\n\n\nTechnical details\n\n\nAutomatic renewal.\n Sandstorm's built-in HTTPS uses the\n\nSandcats.io service\n to renew certificates without\nneeding any manual intervention.\n\n\n\n\n\nNo reverse proxy.\n This configuration removes the need for a\nreverse proxy or HTTPS terminator like \nnginx\n. If you want to set up\na reverse proxy, you would typically use \nBIND_IP=127.0.0.1\n and\n\nPORT=6080\n and choose a \nBASE_URL\n that reflects your external URL.\n\n\nServer Name Indication (SNI) is required.\n Sandstorm's built-in\nHTTPS support requires its clients to support Server Name Indication\n(SNI), which at the time of writing is supported by [over 97% of web\nclients[(http://caniuse.com/#feat=sni).  This is because Sandstorm\nrelies on nodejs's \nSNICallback\n API to smoothly start using new\ncertificates without restarting the server. Therefore, Sandstorm's\nbuilt-in HTTPS support presents an invalid certificate for\n\nclient-does-not-support-sni.sandstorm-requires-sni.invalid\n to\nclients that can't speak SNI to clarify that SNI is required. If you\nneed your Sandstorm installation to support non-SNI clients, you will\nneed to use a custom HTTPS teminator, or file a bug against Sandstorm.\n\n\nDuplicate content on multiple ports.\n If you are publishing content\nat \nexample.com\n and specify multiple values for \nPORT=\n, the content\nis available on each port. We used to be concerned that this might\nnegatively affect how sites hosted on Sandstorm are ranked in search\nengines; our research on \nhow duplicate content is handled by search\nengines\n\nreassures us that this will not be a problem. In the long run,\nconsider turning off port 6080 by removing it from the \nPORT=\n line.\nIf you think the Sandstorm code should support some customization on\nhow it handles multiple ports, please file a bug so we can make sure\nwe're serving your needs.\n\n\nSelf-hosted HTTPS with a custom certificate authority\n\n\nThe following is a process for self-hosted instances of Sandstorm to use SSL with sandcats.io DNS. These steps create a Certificate Authority (CA), corresponding CA Certificate, and the private and public keys for the \n[anything].sandcats.io\n and \n*.[anything].sandcats.io\n domains.\n\n\nNote\n: Web browsers will display a big red certificate error when you try to connect to this install. This tutorial is appropriate if you are OK with reconfiguring web browsers to trust a custom certificate authority that you will create during this tutorial. For automatically-trusted SSL configuration, you will need to use a sandcats.io hostname or follow instructions from a certificate authority.\n\n\n\n\n\n\nMake a copy openssl.cnf:\n\n\ncp /etc/ssl/openssl.cnf [directory_you_want_copy_to_be]\n\n\n\n\n\n\n\nAdd the following to the end of the copied \nopenssl.cnf\n file:\n\n\n[req]\nreq_extensions = v3_req\n\n[ v3_req ]\n\n# Extensions to add to a certificate request\n\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = [your-domain-name].sandcats.io\nDNS.2 = *.[your-domain-name].sandcats.io\n\n\n\n\n\n\n\nCreate the Certificate Authority (CA) Key:\n\n\nopenssl genrsa -out rootCA.key 4096\n\n\n\nrootCA.key\n is the file for the Certificate Authority (CA) key.\n\n\n\n\n\n\nSign the Certificate Authority (CA) Key and Create Certificate Authority (CA) certificate (Expires in 10 years):\n\n\nopenssl req -x509 -new -nodes -key rootCA.key -days 3650 -out rootCA.pem\n\n\n\nrootCA.pem\n is the file for the Certificate Authority (CA) certificate\n\n\n\n\n\n\nCreate Sandstorm Device Private Key:\n\n\nopenssl genrsa -out sandstorm.key 4096\n\n\n\nsandstorm.key\n is the Sandstorm Device Private Key\n\n\n\n\n\n\nCreate Sandstorm Device Certificate Signing Request (CSR) using the copied and edited openssl.cnf file:\n\n\nopenssl req -new -key sandstorm.key -out sandstorm.csr -config openssl.cnf\n\n\n\nsandstorm.csr\n is the Sandstorm Device Certificate Signing Request (CSR)\n\n\n\n\n\n\nCreate and sign the Sandstorm Certificate (Expire in 2 years):\n\n\nopenssl x509 -req -in sandstorm.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out sandstorm.crt -days 730 -extensions v3_req -extfile openssl.cnf\n\n\n\nsandstorm.crt\n is the Sandstorm Certificate\n\n\n\n\n\n\nImport the Certificate Authority (CA) Certificate (\nrootCA.pem\n) into the browser's that will be using Sandstorm. Some browsers may load grains without this step and ask users to add a security excpetion in order to fully load grains.\n\n\n\n\n\n\nCopy (FTP/SSH) the Sandstorm Certificate and Sandstorm Private Key to the nginx ssl directory, it may be \n/etc/nginx/ssl\n.\n\n\n\n\n\n\nChange these lines in your nginx conf file to reflect the new Sandstorm Certificate and Private Key filenames\n:\n\n\nssl_certificate /etc/nginx/ssl/sandstorm.crt;\nssl_certificate_key /etc/nginx/ssl/sandstorm.key;\n\n\n\n\n\n\n\nRestart nginx\n:\n\n\nsudo service nginx restart\n\n\n\n\n\n\n\nRestart Sandstorm:\n\n\nsudo sandstorm restart\n\n\n\nor\n\n\nsudo /opt/sandstorm/sandstorm restart\n\n\n\n\n\n\n\nCreated with help from:\n\n\n\n\nhttps://docs.sandstorm.io/en/latest/administering/reverse-proxy/\n\n\nhttp://datacenteroverlords.com/2012/03/01/creating-your-own-ssl-certificate-authority/\n\n\nhttps://wiki.cacert.org/FAQ/subjectAltName\n\n\nhttp://www.codeproject.com/Tips/833087/X-SSL-Certificates-With-Custom-Extensions\n\n\nhttp://markmail.org/message/grfu4qkr5v5xttc2\n\n\nhttp://blog.loftninjas.org/2008/11/11/configuring-ssl-requests-with-subjectaltname-with-openssl/", 
            "title": "HTTPS & SSL"
        }, 
        {
            "location": "/administering/ssl/#sandstorm-and-https", 
            "text": "If you are using a hostname like  example.sandcats.io , then you\nlikely already have working HTTPS (SSL) for your hostname. Keep\nreading to learn how this feature works and enable it/disable it.  This page also documents other options for HTTPS for a Sandstorm\nserver.  Sandstorm's built-in HTTPS (if you use a  sandcats.io  domain)  For new Sandstorm installations, HTTPS is enabled by\ndefault. Sandstorm listens on port 443 for HTTPS connections and port\n80 for HTTP connections.  This is implemented through the  sandstorm.conf  file. HTTPS mode is\nenabled by setting the  HTTPS_PORT=443  configuration option, causing\nthe Sandstorm software on your server to bind port 443.  Sandstorm also listens on port 80 (via  PORT=80 ). When there is a HTTPS_PORT  configured, and a request comes in for the Sandstorm\nshell or a wildcard host over HTTP, Sandstorm delivers a redirect to\nHTTPS.  Sandstorm grains can publish static content to the web on whatever\ndomain the user wants. Sandstorm serves this static publishing over\nboth HTTP and HTTPS, since Sandstorm software can't currently get a\nvalid HTTPS certificate for all domain names.  Enabling HTTPS for an existing  sandcats.io  Sandstorm server  If you are using the  sandcats.io  DNS service, you can migrate from\nrunning Sandstorm on port 6080 (perhaps with a reverse-proxy) to\nhaving Sandstorm own port 443 (HTTPS) and port 80 (HTTP).  If you are using nginx to speak HTTPS on port 443 and HTTP on port 80,\nyou should disable that before proceeding.  In this example, we presume your server is on example.sandcats.io . We also assume your Sandstorm server runs on\nport 6080 currently.  This process will require reconfiguring any OAuth login providers like\nGoogle or GitHub, so it may take you up to thirty minutes to complete.  First, enable HTTPS by modifying your Sandstorm configuration file.\nOne way to do that is to open it with nano:  sudo nano -w /opt/sandstorm/sandstorm.conf  Add  HTTPS_PORT=  to the bottom of the file:  HTTPS_PORT=443  Find these settings and modify them:  BASE_URL=https://example.sandcats.io\nWILDCARD_HOST=*.example.sandcats.io\nPORT=80,6080  Note on customization:  if you stick to the default  HTTPS_PORT  of\n443, make sure to remove  :6080  from  BASE_URL  and WILDCARD_HOST . If you prefer a non-default port, you must specify it\nin  BASE_URL  and  WILDCARD_HOST . If you want Sandstorm to listen for\nHTTP on ports other than 80, you can customize the  PORT=  line.  Save the file and exit your editor. If you are using  nano  you can\ndo this  Ctrl-w  then  enter  then  Ctrl-x .  Stop and start Sandstorm:  sudo sandstorm restart  Sandstorm will begin to set up HTTPS, and if you want to watch the\nprocess, you can run this command:  sudo tail -f /opt/sandstorm/var/log/sandstorm.log  The first launch with HTTPS enabled may take one or two minutes while\nSandstorm configures keys.  Note on login providers : If you had Google or GitHub login enabled\n(or other OAuth providers), the change in  BASE_URL  means that you\nneed to reconfigure those services. You can log into Sandstorm in a\nspecial admin mode by running:  sudo sandstorm admin-token  Once you are viewing the admin page, you should disable and then\nre-enable GitHub, Google, and any other OAuth-based login\nproviders. This process will typically require visiting the Google and\nGitHub websites.  Once you click  Save  at the bottom of the login configuration page,\nyou should sign in however you normally sign in, perhaps with a Google\nor GitHub account, by clicking  Sign in .  Congratulations!  You're now using HTTPS, also known as SSL and TLS.  Technical details  Automatic renewal.  Sandstorm's built-in HTTPS uses the Sandcats.io service  to renew certificates without\nneeding any manual intervention.   No reverse proxy.  This configuration removes the need for a\nreverse proxy or HTTPS terminator like  nginx . If you want to set up\na reverse proxy, you would typically use  BIND_IP=127.0.0.1  and PORT=6080  and choose a  BASE_URL  that reflects your external URL.  Server Name Indication (SNI) is required.  Sandstorm's built-in\nHTTPS support requires its clients to support Server Name Indication\n(SNI), which at the time of writing is supported by [over 97% of web\nclients[(http://caniuse.com/#feat=sni).  This is because Sandstorm\nrelies on nodejs's  SNICallback  API to smoothly start using new\ncertificates without restarting the server. Therefore, Sandstorm's\nbuilt-in HTTPS support presents an invalid certificate for client-does-not-support-sni.sandstorm-requires-sni.invalid  to\nclients that can't speak SNI to clarify that SNI is required. If you\nneed your Sandstorm installation to support non-SNI clients, you will\nneed to use a custom HTTPS teminator, or file a bug against Sandstorm.  Duplicate content on multiple ports.  If you are publishing content\nat  example.com  and specify multiple values for  PORT= , the content\nis available on each port. We used to be concerned that this might\nnegatively affect how sites hosted on Sandstorm are ranked in search\nengines; our research on  how duplicate content is handled by search\nengines \nreassures us that this will not be a problem. In the long run,\nconsider turning off port 6080 by removing it from the  PORT=  line.\nIf you think the Sandstorm code should support some customization on\nhow it handles multiple ports, please file a bug so we can make sure\nwe're serving your needs.", 
            "title": "Sandstorm and HTTPS"
        }, 
        {
            "location": "/administering/ssl/#self-hosted-https-with-a-custom-certificate-authority", 
            "text": "The following is a process for self-hosted instances of Sandstorm to use SSL with sandcats.io DNS. These steps create a Certificate Authority (CA), corresponding CA Certificate, and the private and public keys for the  [anything].sandcats.io  and  *.[anything].sandcats.io  domains.  Note : Web browsers will display a big red certificate error when you try to connect to this install. This tutorial is appropriate if you are OK with reconfiguring web browsers to trust a custom certificate authority that you will create during this tutorial. For automatically-trusted SSL configuration, you will need to use a sandcats.io hostname or follow instructions from a certificate authority.    Make a copy openssl.cnf:  cp /etc/ssl/openssl.cnf [directory_you_want_copy_to_be]    Add the following to the end of the copied  openssl.cnf  file:  [req]\nreq_extensions = v3_req\n\n[ v3_req ]\n\n# Extensions to add to a certificate request\n\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = [your-domain-name].sandcats.io\nDNS.2 = *.[your-domain-name].sandcats.io    Create the Certificate Authority (CA) Key:  openssl genrsa -out rootCA.key 4096  rootCA.key  is the file for the Certificate Authority (CA) key.    Sign the Certificate Authority (CA) Key and Create Certificate Authority (CA) certificate (Expires in 10 years):  openssl req -x509 -new -nodes -key rootCA.key -days 3650 -out rootCA.pem  rootCA.pem  is the file for the Certificate Authority (CA) certificate    Create Sandstorm Device Private Key:  openssl genrsa -out sandstorm.key 4096  sandstorm.key  is the Sandstorm Device Private Key    Create Sandstorm Device Certificate Signing Request (CSR) using the copied and edited openssl.cnf file:  openssl req -new -key sandstorm.key -out sandstorm.csr -config openssl.cnf  sandstorm.csr  is the Sandstorm Device Certificate Signing Request (CSR)    Create and sign the Sandstorm Certificate (Expire in 2 years):  openssl x509 -req -in sandstorm.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out sandstorm.crt -days 730 -extensions v3_req -extfile openssl.cnf  sandstorm.crt  is the Sandstorm Certificate    Import the Certificate Authority (CA) Certificate ( rootCA.pem ) into the browser's that will be using Sandstorm. Some browsers may load grains without this step and ask users to add a security excpetion in order to fully load grains.    Copy (FTP/SSH) the Sandstorm Certificate and Sandstorm Private Key to the nginx ssl directory, it may be  /etc/nginx/ssl .    Change these lines in your nginx conf file to reflect the new Sandstorm Certificate and Private Key filenames :  ssl_certificate /etc/nginx/ssl/sandstorm.crt;\nssl_certificate_key /etc/nginx/ssl/sandstorm.key;    Restart nginx :  sudo service nginx restart    Restart Sandstorm:  sudo sandstorm restart  or  sudo /opt/sandstorm/sandstorm restart    Created with help from:   https://docs.sandstorm.io/en/latest/administering/reverse-proxy/  http://datacenteroverlords.com/2012/03/01/creating-your-own-ssl-certificate-authority/  https://wiki.cacert.org/FAQ/subjectAltName  http://www.codeproject.com/Tips/833087/X-SSL-Certificates-With-Custom-Extensions  http://markmail.org/message/grfu4qkr5v5xttc2  http://blog.loftninjas.org/2008/11/11/configuring-ssl-requests-with-subjectaltname-with-openssl/", 
            "title": "Self-hosted HTTPS with a custom certificate authority"
        }, 
        {
            "location": "/administering/faq/", 
            "text": "One way to use Sandstorm is to run the software on your own server --\nwe call that \nself-hosting\n. This page answers common questions from\nself-hosters.\n\n\nHow do I log in, if there's a problem with logging in via the web?\n\n\nIf logging into your Sandstorm server over the web isn't working, you\ncan reset your Sandstorm's login providers. Resetting login providers\nwill retain all existing accounts, including account metadata such as\nwho is an admin.\n\n\nThese instructions assume you've installed Sandstorm as root, which is\nthe default recommendation. If not, remove the \nsudo\n from the\ninstructions below.\n\n\n\n\nUse e.g. \nssh\n to log into the server running Sandstorm.\n\n\n\n\nRun this command to deconfigure all existing OAuth-based login providers.\n\n\nsudo sandstorm reset-oauth\n\n\n\n\n\n\n\nOn success, it will print:\n\n\n  reset OAuth configuration\n\n\n\n\n\n\n\nRun this command to generate a token you can use to log in as an admin, for emergency administration.\n\n\nsudo sandstorm admin-token\n\n\n\n\n\n\n\nThis will print a message such as:\n\n\n  Generated new admin token.\n\n  Please proceed to http://sandstorm.example.com/admin/19bc20df04838fdc03101d898be075cc02de66f2\n  in order to access the admin settings page and configure your login system. This token will\n  expire in 15 min, and if you take too long, you will have to regenerate a new token with\n  `sandstorm admin-token`.\n\n\n\n\n\n\n\nVisit the link it printed out, which gives you emergency access to the server's admin panel.\n\n\n\n\n\n\nFrom there, configure the login providers of your choosing.\n\n\n\n\n\n\nNow, log in as yourself. If you log in as the first user that ever signed into this Sandstorm instance, then you will be an admin.\n\n\n\n\n\n\nWhy does Sandstorm require a wildcard host?\n\n\nSee \nWhy Sandstorm needs a wildcard host\n.\n\n\nWhy can't I access Sandstorm from the Internet, even though the server is running?\n\n\nIf your \nsandstorm.conf\n looks like this:\n\n\nSERVER_USER=sandstorm\nPORT=6080\nMONGO_PORT=6081\nBIND_IP=127.0.0.1\nBASE_URL=http://mydomain.com:6080\nWILDCARD_HOST=*.mydomain.com:6080\nMAIL_URL=\nUPDATE_CHANNEL=dev\n\n\n\n\nthen you need to change the \nBIND_IP\n value to \n0.0.0.0\n.\n\n\n(To be pedantic, this the unspecified IPv4 address. For IPv6\ncompatibility, you may want \n::\n instead. I haven't tested this yet.)\n\n\nWhat ports does Sandstorm need open?\n\n\nIf you have a strict firewall around the server running Sandstorm, or\nyou are at home and have to enable \"port forwarding\" on a home wifi\ngateway, here is a list of the ports Sandstorm needs. This applies on\ncloud providers like Amazon EC2, where the defaults allow no inbound\ntraffic.\n\n\nDefault configuration\n\n\n\n\nTCP port 6080\n\n\n\n\nOptionally\n\n\n\n\nTCP port 443\n\n\nTCP port 80\n\n\n\n\nWhat are the minimum hardware requirements?\n\n\n\n\nArchitecture: \namd64\n (aka x86_64)\n\n\nRAM: 1 GB\n\n\nDisk space: 5 GB\n\n\nSwap: Enabled, if possible\n\n\n\n\nYou can probably get away with less, but I wouldn't advise it.\n\n\nUsing a virtual machine from Amazon EC2, Google Compute Engine,\nLinode, Digital Ocean, etc., is fine; just make sure you have a recent\nLinux kernel. Ubuntu 14.04 is an easy and good choice of base\noperating system.\n\n\nSometimes I randomly see a lot of errors across the board, while other times the same functions work fine. What's going on?\n\n\nDo you have enough RAM? Linux will start randomly killing processes\nwhen it's low on RAM. Each grain you have open (or had open in the\nlast couple minutes) will probably consume 50MB-500MB of RAM,\ndepending on the app. We therefore recommend using a server with at\nleast 2GB. If you have less that that, see the next question.\n\n\nMy virtual machine doesn't have that much RAM, what can I do?\n\n\nIt might help to set up swap space. The following commands will set up\na file on-disk to use as swap:\n\n\ndd if=/dev/zero of=/swap.img bs=1M count=1024\nmkswap /swap.img\nswapon /swap.img\n\necho /swap.img swap swap defaults 0 0 \n /etc/fstab\n\n\n\nWhy do you support only Google, GitHub, and passwordless email for login?\n\n\nUsing Google or Github for login results in top-notch security and\nstraightforward federated authentication with very little work. This\nlets Sandstorm be focused on what it's good at. (We could add Twitter,\nFacebook, etc. login as well, but we are worried about people\nforgetting which one they used and ending up with multiple accounts.)\n\n\nFor email logins, we chose to avoid passwords entirely. Passwords have\na lot of problems. People choose bad passwords. People -- even smart\npeople -- are often fooled by well-crafted phishing attacks. And, of\ncourse, people regularly forget their passwords. In order to deal with\nthese threats, we believe that any password-based login system for\nSandstorm must, at the very least, support two-factor authentication\nand be backed by a human security team who can respond to\nhijackings. There must also be an automated password reset mechanism\nwhich must be well-designed and monitored to avoid\nattacks. Unfortunately, we don't have these things yet. Moreover, we\ndon't believe that building a secure password login system is the best\nway for Sandstorm to deliver something interesting to the ecosystem.\n\n\nAnother problem with password login is that it makes federation more\ncomplicated. When you federate with your friend's server, how does it\nauthenticate you? Not by password, obviously. Perhaps by OpenID or\nOAuth, but that is again a thing we would need to implement.\n\n\nIn short, we think these are the most secure options we can provide\nright now.\n\n\nA note about when and why we think security is important:\n\n\n\n\n\n\nFor self-hosted Sandstorm servers, we want to provide a secure experience.\n\n\n\n\n\n\nFor public Sandstorm servers supporting a large number of users, account security is essential.\n\n\n\n\n\n\nFor a development instance only accessible to \nlocalhost\n, login security may not be particularly important. You can enable the \ndev accounts\n feature to create accounts for testing apps.\n\n\n\n\n\n\nFederated login enables tracking, and passwordless email login enables\nanyone with temporary access to an email account to hijack an account.\nOne way to overcome these problems is by building GPG login so you can\ncreate an account based on your public key. You can track progress on\nthat effort in \nthis\nissue\n.\n\n\nWhy do I see an error when I try to launch an app, even when the Sandstorm interface works fine?\n\n\nSometimes Sandstorm seems to be working fine but can launch no apps.\n\n\nIf you see an error screen like this:\n\n\n\n\neven when the app management interface seems to work fine:\n\n\n\n\nThis typically relates to Sandstorm's need for \nwildcard\nDNS\n. Sandstorm runs each app \nsession\n on a unique,\ntemporary subdomain. Here's what to check:\n\n\n\n\nMake sure the \nWILDCARD_HOST\n has valid syntax.\n In the Sandstorm config file (typically \n/opt/sandstorm/sandstorm.conf\n, look for the \nWILDCARD_HOST\n config item. Note that this should not have a protocol as part of it. A valid line might be:\n\n\n\n\nWILDCARD_HOST=*.yourname.sandcats.io:6080\n\n\n\n\n\n\nMake sure wildcard DNS works for your chosen domain\n. See also \nthis issue in our repository\n. If setting up wildcard DNS is a hassle for you, consider using our free \nSandcats dynamic DNS\n service for your \nWILDCARD_HOST\n.", 
            "title": "Frequently asked questions"
        }, 
        {
            "location": "/administering/faq/#how-do-i-log-in-if-theres-a-problem-with-logging-in-via-the-web", 
            "text": "If logging into your Sandstorm server over the web isn't working, you\ncan reset your Sandstorm's login providers. Resetting login providers\nwill retain all existing accounts, including account metadata such as\nwho is an admin.  These instructions assume you've installed Sandstorm as root, which is\nthe default recommendation. If not, remove the  sudo  from the\ninstructions below.   Use e.g.  ssh  to log into the server running Sandstorm.   Run this command to deconfigure all existing OAuth-based login providers.  sudo sandstorm reset-oauth    On success, it will print:    reset OAuth configuration    Run this command to generate a token you can use to log in as an admin, for emergency administration.  sudo sandstorm admin-token    This will print a message such as:    Generated new admin token.\n\n  Please proceed to http://sandstorm.example.com/admin/19bc20df04838fdc03101d898be075cc02de66f2\n  in order to access the admin settings page and configure your login system. This token will\n  expire in 15 min, and if you take too long, you will have to regenerate a new token with\n  `sandstorm admin-token`.    Visit the link it printed out, which gives you emergency access to the server's admin panel.    From there, configure the login providers of your choosing.    Now, log in as yourself. If you log in as the first user that ever signed into this Sandstorm instance, then you will be an admin.", 
            "title": "How do I log in, if there's a problem with logging in via the web?"
        }, 
        {
            "location": "/administering/faq/#why-does-sandstorm-require-a-wildcard-host", 
            "text": "See  Why Sandstorm needs a wildcard host .", 
            "title": "Why does Sandstorm require a wildcard host?"
        }, 
        {
            "location": "/administering/faq/#why-cant-i-access-sandstorm-from-the-internet-even-though-the-server-is-running", 
            "text": "If your  sandstorm.conf  looks like this:  SERVER_USER=sandstorm\nPORT=6080\nMONGO_PORT=6081\nBIND_IP=127.0.0.1\nBASE_URL=http://mydomain.com:6080\nWILDCARD_HOST=*.mydomain.com:6080\nMAIL_URL=\nUPDATE_CHANNEL=dev  then you need to change the  BIND_IP  value to  0.0.0.0 .  (To be pedantic, this the unspecified IPv4 address. For IPv6\ncompatibility, you may want  ::  instead. I haven't tested this yet.)", 
            "title": "Why can't I access Sandstorm from the Internet, even though the server is running?"
        }, 
        {
            "location": "/administering/faq/#what-ports-does-sandstorm-need-open", 
            "text": "If you have a strict firewall around the server running Sandstorm, or\nyou are at home and have to enable \"port forwarding\" on a home wifi\ngateway, here is a list of the ports Sandstorm needs. This applies on\ncloud providers like Amazon EC2, where the defaults allow no inbound\ntraffic.  Default configuration   TCP port 6080   Optionally   TCP port 443  TCP port 80", 
            "title": "What ports does Sandstorm need open?"
        }, 
        {
            "location": "/administering/faq/#what-are-the-minimum-hardware-requirements", 
            "text": "Architecture:  amd64  (aka x86_64)  RAM: 1 GB  Disk space: 5 GB  Swap: Enabled, if possible   You can probably get away with less, but I wouldn't advise it.  Using a virtual machine from Amazon EC2, Google Compute Engine,\nLinode, Digital Ocean, etc., is fine; just make sure you have a recent\nLinux kernel. Ubuntu 14.04 is an easy and good choice of base\noperating system.", 
            "title": "What are the minimum hardware requirements?"
        }, 
        {
            "location": "/administering/faq/#sometimes-i-randomly-see-a-lot-of-errors-across-the-board-while-other-times-the-same-functions-work-fine-whats-going-on", 
            "text": "Do you have enough RAM? Linux will start randomly killing processes\nwhen it's low on RAM. Each grain you have open (or had open in the\nlast couple minutes) will probably consume 50MB-500MB of RAM,\ndepending on the app. We therefore recommend using a server with at\nleast 2GB. If you have less that that, see the next question.", 
            "title": "Sometimes I randomly see a lot of errors across the board, while other times the same functions work fine. What's going on?"
        }, 
        {
            "location": "/administering/faq/#my-virtual-machine-doesnt-have-that-much-ram-what-can-i-do", 
            "text": "It might help to set up swap space. The following commands will set up\na file on-disk to use as swap:  dd if=/dev/zero of=/swap.img bs=1M count=1024\nmkswap /swap.img\nswapon /swap.img\n\necho /swap.img swap swap defaults 0 0   /etc/fstab", 
            "title": "My virtual machine doesn't have that much RAM, what can I do?"
        }, 
        {
            "location": "/administering/faq/#why-do-you-support-only-google-github-and-passwordless-email-for-login", 
            "text": "Using Google or Github for login results in top-notch security and\nstraightforward federated authentication with very little work. This\nlets Sandstorm be focused on what it's good at. (We could add Twitter,\nFacebook, etc. login as well, but we are worried about people\nforgetting which one they used and ending up with multiple accounts.)  For email logins, we chose to avoid passwords entirely. Passwords have\na lot of problems. People choose bad passwords. People -- even smart\npeople -- are often fooled by well-crafted phishing attacks. And, of\ncourse, people regularly forget their passwords. In order to deal with\nthese threats, we believe that any password-based login system for\nSandstorm must, at the very least, support two-factor authentication\nand be backed by a human security team who can respond to\nhijackings. There must also be an automated password reset mechanism\nwhich must be well-designed and monitored to avoid\nattacks. Unfortunately, we don't have these things yet. Moreover, we\ndon't believe that building a secure password login system is the best\nway for Sandstorm to deliver something interesting to the ecosystem.  Another problem with password login is that it makes federation more\ncomplicated. When you federate with your friend's server, how does it\nauthenticate you? Not by password, obviously. Perhaps by OpenID or\nOAuth, but that is again a thing we would need to implement.  In short, we think these are the most secure options we can provide\nright now.  A note about when and why we think security is important:    For self-hosted Sandstorm servers, we want to provide a secure experience.    For public Sandstorm servers supporting a large number of users, account security is essential.    For a development instance only accessible to  localhost , login security may not be particularly important. You can enable the  dev accounts  feature to create accounts for testing apps.    Federated login enables tracking, and passwordless email login enables\nanyone with temporary access to an email account to hijack an account.\nOne way to overcome these problems is by building GPG login so you can\ncreate an account based on your public key. You can track progress on\nthat effort in  this\nissue .", 
            "title": "Why do you support only Google, GitHub, and passwordless email for login?"
        }, 
        {
            "location": "/administering/faq/#why-do-i-see-an-error-when-i-try-to-launch-an-app-even-when-the-sandstorm-interface-works-fine", 
            "text": "Sometimes Sandstorm seems to be working fine but can launch no apps.  If you see an error screen like this:   even when the app management interface seems to work fine:   This typically relates to Sandstorm's need for  wildcard\nDNS . Sandstorm runs each app  session  on a unique,\ntemporary subdomain. Here's what to check:   Make sure the  WILDCARD_HOST  has valid syntax.  In the Sandstorm config file (typically  /opt/sandstorm/sandstorm.conf , look for the  WILDCARD_HOST  config item. Note that this should not have a protocol as part of it. A valid line might be:   WILDCARD_HOST=*.yourname.sandcats.io:6080   Make sure wildcard DNS works for your chosen domain . See also  this issue in our repository . If setting up wildcard DNS is a hassle for you, consider using our free  Sandcats dynamic DNS  service for your  WILDCARD_HOST .", 
            "title": "Why do I see an error when I try to launch an app, even when the Sandstorm interface works fine?"
        }
    ]
}